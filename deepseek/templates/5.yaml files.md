Absolutely! Here's how to integrate YAML configuration with the Java implementation:

1. YAML Configuration Structure

Base Template Directory Structure

```
templates/
├── base/
│   ├── enrollment.yaml
│   └── eligibility.yaml
├── products/
│   ├── medical/
│   │   ├── base.yaml
│   │   ├── hmo.yaml
│   │   └── ppo.yaml
│   ├── dental/
│   │   └── base.yaml
│   └── vision/
│       └── base.yaml
├── markets/
│   ├── individual/
│   │   ├── base.yaml
│   │   └── aca.yaml
│   └── small_group/
│       └── base.yaml
└── states/
    ├── ca/
    │   ├── required.yaml
    │   └── medical.yaml
    └── ny/
        └── required.yaml
```

2. YAML Template Definitions

Base Enrollment Template

```yaml
# templates/base/enrollment.yaml
templateId: "base/enrollment"
metadata:
  description: "Base enrollment fields for all healthcare products"
  version: "1.0"
baseFields:
  member_demographics:
    member_name:
      targetField: "member_name"
      sourcePath: "member.demographics.fullName"
      required: true
    date_of_birth:
      targetField: "date_of_birth" 
      sourcePath: "member.demographics.dateOfBirth"
      transformFunction: "formatDate('MM/dd/yyyy')"
      required: true
    gender:
      targetField: "gender"
      sourcePath: "member.demographics.gender"
  contact_info:
    address:
      targetField: "mailing_address"
      sourcePath: "member.contact.address.full"
    phone:
      targetField: "primary_phone"
      sourcePath: "member.contact.phone.primary"
```

California Required Fields

```yaml
# templates/states/ca/required.yaml
templateId: "states/ca/required"
metadata:
  description: "California-specific required fields"
  state: "CA"
  applicableMarkets: ["INDIVIDUAL", "SMALL_GROUP", "LARGE_GROUP"]
additions:
  state_specific:
    translation_services:
      targetField: "translation_services_acknowledgment"
      sourcePath: "plan.features.translationServices"
      required: true
    dmhc_licensing:
      targetField: "dmhc_licensing_disclosure"
      sourcePath: "carrier.licensing.dmhc"
      required: true
    surprise_billing:
      targetField: "surprise_billing_protections"
      sourcePath: "plan.protections.surpriseBilling"
      required: true
```

Medical Base Product

```yaml
# templates/products/medical/base.yaml
templateId: "products/medical/base"
metadata:
  description: "Base medical product fields"
  productType: "MEDICAL"
baseFields:
  medical_specific:
    pcp_required:
      targetField: "primary_care_physician_required"
      sourcePath: "plan.network.requiresPCP"
    referrals_required:
      targetField: "specialist_referrals_required" 
      sourcePath: "plan.network.referralsRequired"
    emergency_services:
      targetField: "emergency_services_copay"
      sourcePath: "plan.costSharing.emergency"
```

Medical HMO Product

```yaml
# templates/products/medical/hmo.yaml
templateId: "products/medical/hmo"
extends: "products/medical/base"
metadata:
  description: "HMO-specific medical fields"
  planType: "HMO"
additions:
  hmo_specific:
    service_area:
      targetField: "hmo_service_area"
      sourcePath: "plan.network.serviceArea"
      required: true
    out_of_network:
      targetField: "out_of_network_coverage"
      sourcePath: "plan.coverage.outOfNetwork"
      transformFunction: "defaultValue('NOT_COVERED')"
```

Individual Market Template

```yaml
# templates/markets/individual/base.yaml
templateId: "markets/individual/base"
metadata:
  description: "Individual market enrollment fields"
  marketSegment: "INDIVIDUAL"
baseFields:
  individual_market:
    applicant_type:
      targetField: "applicant_type"
      sourcePath: "application.applicantType"
      required: true
    tax_household:
      targetField: "tax_household_size"
      sourcePath: "application.taxHousehold.size"
```

3. Updated Java Model Classes for YAML

```java
// YamlTemplateDefinition.java - Maps to YAML structure
@JsonPropertyOrder({"templateId", "extends", "includes", "metadata", "baseFields", "overrides", "additions"})
public class YamlTemplateDefinition {
    private String templateId;
    private String extendsTemplate;
    private List<String> includes = new ArrayList<>();
    private Map<String, Object> metadata = new HashMap<>();
    private Map<String, Map<String, YamlFieldMapping>> baseFields = new HashMap<>();
    private Map<String, Map<String, YamlFieldMapping>> overrides = new HashMap<>();
    private Map<String, Map<String, YamlFieldMapping>> additions = new HashMap<>();
    
    // Flattened structure for simple templates
    private Map<String, YamlFieldMapping> fields = new HashMap<>();
    
    // Getters and setters for YAML mapping
    @JsonProperty("templateId")
    public String getTemplateId() { return templateId; }
    
    @JsonProperty("templateId")
    public void setTemplateId(String templateId) { this.templateId = templateId; }
    
    @JsonProperty("extends")
    public String getExtendsTemplate() { return extendsTemplate; }
    
    @JsonProperty("extends")
    public void setExtendsTemplate(String extendsTemplate) { this.extendsTemplate = extendsTemplate; }
    
    // ... other getters and setters
    
    public Map<String, YamlFieldMapping> getAllFields() {
        Map<String, YamlFieldMapping> allFields = new HashMap<>();
        
        // Add fields from flattened structure
        allFields.putAll(fields);
        
        // Add fields from categorized structure
        baseFields.values().forEach(category -> allFields.putAll(category));
        additions.values().forEach(category -> allFields.putAll(category));
        overrides.values().forEach(category -> allFields.putAll(category));
        
        return allFields;
    }
}

// YamlFieldMapping.java - Field mapping in YAML
public class YamlFieldMapping {
    private String targetField;
    private String sourcePath;
    private String transformFunction;
    private boolean required = false;
    private String defaultValue;
    
    // Getters and setters
    public String getTargetField() { return targetField; }
    public void setTargetField(String targetField) { this.targetField = targetField; }
    
    public String getSourcePath() { return sourcePath; }
    public void setSourcePath(String sourcePath) { this.sourcePath = sourcePath; }
    
    public String getTransformFunction() { return transformFunction; }
    public void setTransformFunction(String transformFunction) { this.transformFunction = transformFunction; }
    
    public boolean isRequired() { return required; }
    public void setRequired(boolean required) { this.required = required; }
    
    public String getDefaultValue() { return defaultValue; }
    public void setDefaultValue(String defaultValue) { this.defaultValue = defaultValue; }
}
```

4. YAML Template Loader

```java
// YamlTemplateLoader.java - Loads templates from YAML files
@Component
public class YamlTemplateLoader {
    private final ObjectMapper yamlMapper;
    private final ResourcePatternResolver resourceResolver;
    
    public YamlTemplateLoader() {
        this.yamlMapper = new ObjectMapper(new YAMLFactory());
        this.yamlMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
        this.resourceResolver = new PathMatchingResourcePatternResolver();
    }
    
    public Map<String, TemplateDefinition> loadAllTemplates(String templateDirectory) throws IOException {
        Map<String, TemplateDefinition> templates = new HashMap<>();
        Resource[] resources = resourceResolver.getResources(
            "classpath:" + templateDirectory + "/**/*.yaml");
        
        for (Resource resource : resources) {
            try (InputStream inputStream = resource.getInputStream()) {
                YamlTemplateDefinition yamlDef = yamlMapper.readValue(inputStream, YamlTemplateDefinition.class);
                TemplateDefinition templateDef = convertToTemplateDefinition(yamlDef);
                templates.put(templateDef.getTemplateId(), templateDef);
            }
        }
        
        return templates;
    }
    
    private TemplateDefinition convertToTemplateDefinition(YamlTemplateDefinition yamlDef) {
        TemplateDefinition.Builder builder = new TemplateDefinition.Builder()
            .templateId(yamlDef.getTemplateId());
        
        // Handle inheritance
        if (yamlDef.getExtendsTemplate() != null) {
            builder.extendsTemplate(yamlDef.getExtendsTemplate());
        }
        
        // Handle includes
        yamlDef.getIncludes().forEach(builder::include);
        
        // Handle metadata
        yamlDef.getMetadata().forEach(builder::metadata);
        
        // Convert field mappings
        convertFieldMappings(yamlDef, builder);
        
        return builder.build();
    }
    
    private void convertFieldMappings(YamlTemplateDefinition yamlDef, TemplateDefinition.Builder builder) {
        // Convert flattened fields
        yamlDef.getFields().forEach((fieldName, yamlMapping) -> {
            FieldMapping mapping = convertYamlFieldMapping(yamlMapping, fieldName);
            builder.baseField(fieldName, mapping);
        });
        
        // Convert categorized base fields
        yamlDef.getBaseFields().forEach((category, fields) -> {
            fields.forEach((fieldName, yamlMapping) -> {
                FieldMapping mapping = convertYamlFieldMapping(yamlMapping, fieldName);
                builder.baseField(fieldName, mapping);
            });
        });
        
        // Convert additions
        yamlDef.getAdditions().forEach((category, fields) -> {
            fields.forEach((fieldName, yamlMapping) -> {
                FieldMapping mapping = convertYamlFieldMapping(yamlMapping, fieldName);
                builder.addition(fieldName, mapping);
            });
        });
        
        // Convert overrides
        yamlDef.getOverrides().forEach((category, fields) -> {
            fields.forEach((fieldName, yamlMapping) -> {
                FieldMapping mapping = convertYamlFieldMapping(yamlMapping, fieldName);
                builder.override(fieldName, mapping);
            });
        });
    }
    
    private FieldMapping convertYamlFieldMapping(YamlFieldMapping yamlMapping, String defaultFieldName) {
        String targetField = yamlMapping.getTargetField() != null ? 
            yamlMapping.getTargetField() : defaultFieldName;
            
        return new FieldMapping.Builder()
            .targetField(targetField)
            .sourcePath(yamlMapping.getSourcePath())
            .transformFunction(yamlMapping.getTransformFunction())
            .required(yamlMapping.isRequired())
            .build();
    }
}
```

5. Enhanced Template Registry with YAML Support

```java
// YamlTemplateRegistry.java - Extends registry with YAML loading
@Component
public class YamlTemplateRegistry extends TemplateRegistry {
    private final YamlTemplateLoader templateLoader;
    private final String templateDirectory;
    
    public YamlTemplateRegistry(YamlTemplateLoader templateLoader, 
                               @Value("${app.template.directory:templates}") String templateDirectory) {
        this.templateLoader = templateLoader;
        this.templateDirectory = templateDirectory;
    }
    
    @PostConstruct
    public void initializeTemplates() throws IOException {
        Map<String, TemplateDefinition> templates = templateLoader.loadAllTemplates(templateDirectory);
        templates.values().forEach(this::registerTemplate);
        
        log.info("Loaded {} templates from YAML configuration", templates.size());
    }
    
    public void reloadTemplates() throws IOException {
        // Clear existing templates
        // Re-load from YAML files
        // Useful for hot-reloading in development
    }
}
```

6. Spring Configuration

```java
// AppConfig.java - Spring configuration
@Configuration
public class AppConfig {
    
    @Bean
    public YamlTemplateLoader yamlTemplateLoader() {
        return new YamlTemplateLoader();
    }
    
    @Bean
    public YamlTemplateRegistry yamlTemplateRegistry(YamlTemplateLoader templateLoader) {
        return new YamlTemplateRegistry(templateLoader);
    }
    
    @Bean 
    public HealthcareTemplateResolver healthcareTemplateResolver(YamlTemplateRegistry templateRegistry) {
        return new HealthcareTemplateResolver(templateRegistry);
    }
    
    @Bean
    public EnrollmentDataMapper enrollmentDataMapper(HealthcareTemplateResolver templateResolver) {
        return new EnrollmentDataMapper(templateResolver, new ValueExtractor(), new TransformationEngine());
    }
}
```

7. application.yaml - Spring Boot Configuration

```yaml
# application.yaml
app:
  template:
    directory: "templates"
    cache:
      enabled: true
      ttl-minutes: 30
    
logging:
  level:
    com.yourapp.template: DEBUG

spring:
  profiles:
    active: "dev"
  jackson:
    property-naming-strategy: SNAKE_CASE
```

8. Usage Example

```java
@Service
public class EnrollmentService {
    private final HealthcareTemplateResolver templateResolver;
    private final EnrollmentDataMapper dataMapper;
    
    public EnrollmentService(HealthcareTemplateResolver templateResolver,
                           EnrollmentDataMapper dataMapper) {
        this.templateResolver = templateResolver;
        this.dataMapper = dataMapper;
    }
    
    public EnrollmentResponse submitEnrollment(EnrollmentRequest request) {
        EnrollmentContext context = createContext(request);
        Map<String, Object> mappedData = dataMapper.mapEnrollmentData(context, request.getApplicantData());
        
        // Submit to target system
        return submitToTargetSystem(mappedData);
    }
    
    private EnrollmentContext createContext(EnrollmentRequest request) {
        return new EnrollmentContext(
            EnrollmentContext.ProductType.valueOf(request.getProductType()),
            EnrollmentContext.MarketSegment.valueOf(request.getMarketSegment()),
            request.getStateCode(),
            EnrollmentContext.PlanType.valueOf(request.getPlanType()),
            Year.now().getValue()
        );
    }
}
```

9. Maven Dependencies

```xml
<!-- pom.xml -->
<dependencies>
    <!-- YAML Processing -->
    <dependency>
        <groupId>com.fasterxml.jackson.dataformat</groupId>
        <artifactId>jackson-dataformat-yaml</artifactId>
        <version>2.15.2</version>
    </dependency>
    
    <!-- Spring Boot -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter</artifactId>
        <version>3.1.0</version>
    </dependency>
    
    <!-- Testing -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-test</artifactId>
        <version>3.1.0</version>
        <scope>test</scope>
    </dependency>
</dependencies>
```

Benefits of YAML Integration:

1. Human Readable: Easy to read and modify template definitions
2. Version Control Friendly: YAML files work well with Git
3. Hot Reloading: Can reload templates without restarting application
4. Separation of Concerns: Business logic in Java, configuration in YAML
5. Tooling Support: Good IDE support for YAML with syntax highlighting
6. Composition Support: Natural fit for template inheritance and includes

This approach gives you the best of both worlds: type-safe Java code with flexible, maintainable YAML configuration for your 100+ healthcare templates.