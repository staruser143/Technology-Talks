Here are comprehensive Java implementations for your healthcare enrollment template system:

1. Core Domain Classes

```java
// EnrollmentContext.java - Represents the multi-dimensional context
public class EnrollmentContext {
    private final ProductType productType;
    private final MarketSegment marketSegment;
    private final String stateCode;
    private final PlanType planType;
    private final int planYear;
    
    public EnrollmentContext(ProductType productType, MarketSegment marketSegment, 
                           String stateCode, PlanType planType, int planYear) {
        this.productType = productType;
        this.marketSegment = marketSegment;
        this.stateCode = stateCode;
        this.planType = planType;
        this.planYear = planYear;
    }
    
    // Getters
    public ProductType getProductType() { return productType; }
    public MarketSegment getMarketSegment() { return marketSegment; }
    public String getStateCode() { return stateCode; }
    public PlanType getPlanType() { return planType; }
    public int getPlanYear() { return planYear; }
    
    // Enum definitions
    public enum ProductType {
        MEDICAL, DENTAL, VISION
    }
    
    public enum MarketSegment {
        INDIVIDUAL, SMALL_GROUP, LARGE_GROUP, MEDICARE
    }
    
    public enum PlanType {
        HMO, PPO, EPO, HDHP, STANDARD
    }
}
```

2. Template Model Classes

```java
// FieldMapping.java - Represents a single field mapping
public class FieldMapping {
    private final String targetField;
    private final String sourcePath;
    private final String transformFunction;
    private final boolean required;
    
    public FieldMapping(String targetField, String sourcePath, String transformFunction, boolean required) {
        this.targetField = targetField;
        this.sourcePath = sourcePath;
        this.transformFunction = transformFunction;
        this.required = required;
    }
    
    // Getters and fluent builder
    public static class Builder {
        private String targetField;
        private String sourcePath;
        private String transformFunction;
        private boolean required = false;
        
        public Builder targetField(String targetField) {
            this.targetField = targetField;
            return this;
        }
        
        public Builder sourcePath(String sourcePath) {
            this.sourcePath = sourcePath;
            return this;
        }
        
        public Builder transformFunction(String transformFunction) {
            this.transformFunction = transformFunction;
            return this;
        }
        
        public Builder required(boolean required) {
            this.required = required;
            return this;
        }
        
        public FieldMapping build() {
            return new FieldMapping(targetField, sourcePath, transformFunction, required);
        }
    }
    
    // Getters
    public String getTargetField() { return targetField; }
    public String getSourcePath() { return sourcePath; }
    public String getTransformFunction() { return transformFunction; }
    public boolean isRequired() { return required; }
}

// TemplateDefinition.java - Represents a template with composition
public class TemplateDefinition {
    private final String templateId;
    private final List<String> includes;
    private final String extendsTemplate;
    private final Map<String, FieldMapping> baseFields;
    private final Map<String, FieldMapping> overrides;
    private final Map<String, FieldMapping> additions;
    private final Map<String, Object> metadata;
    
    private TemplateDefinition(Builder builder) {
        this.templateId = builder.templateId;
        this.includes = List.copyOf(builder.includes);
        this.extendsTemplate = builder.extendsTemplate;
        this.baseFields = Map.copyOf(builder.baseFields);
        this.overrides = Map.copyOf(builder.overrides);
        this.additions = Map.copyOf(builder.additions);
        this.metadata = Map.copyOf(builder.metadata);
    }
    
    public static class Builder {
        private String templateId;
        private List<String> includes = new ArrayList<>();
        private String extendsTemplate;
        private Map<String, FieldMapping> baseFields = new HashMap<>();
        private Map<String, FieldMapping> overrides = new HashMap<>();
        private Map<String, FieldMapping> additions = new HashMap<>();
        private Map<String, Object> metadata = new HashMap<>();
        
        public Builder templateId(String templateId) {
            this.templateId = templateId;
            return this;
        }
        
        public Builder include(String includeTemplate) {
            this.includes.add(includeTemplate);
            return this;
        }
        
        public Builder includes(List<String> includes) {
            this.includes.addAll(includes);
            return this;
        }
        
        public Builder extendsTemplate(String extendsTemplate) {
            this.extendsTemplate = extendsTemplate;
            return this;
        }
        
        public Builder baseField(String name, FieldMapping mapping) {
            this.baseFields.put(name, mapping);
            return this;
        }
        
        public Builder override(String name, FieldMapping mapping) {
            this.overrides.put(name, mapping);
            return this;
        }
        
        public Builder addition(String name, FieldMapping mapping) {
            this.additions.put(name, mapping);
            return this;
        }
        
        public Builder metadata(String key, Object value) {
            this.metadata.put(key, value);
            return this;
        }
        
        public TemplateDefinition build() {
            return new TemplateDefinition(this);
        }
    }
    
    // Getters
    public String getTemplateId() { return templateId; }
    public List<String> getIncludes() { return includes; }
    public String getExtendsTemplate() { return extendsTemplate; }
    public Map<String, FieldMapping> getBaseFields() { return baseFields; }
    public Map<String, FieldMapping> getOverrides() { return overrides; }
    public Map<String, FieldMapping> getAdditions() { return additions; }
    public Map<String, Object> getMetadata() { return metadata; }
}
```

3. Template Registry and Resolver

```java
// TemplateRegistry.java - Manages template storage and retrieval
@Component
public class TemplateRegistry {
    private final Map<String, TemplateDefinition> templates = new ConcurrentHashMap<>();
    private final Map<String, List<String>> templateIndex = new ConcurrentHashMap<>();
    
    public void registerTemplate(TemplateDefinition template) {
        templates.put(template.getTemplateId(), template);
        indexTemplateFields(template);
    }
    
    public TemplateDefinition getTemplate(String templateId) {
        TemplateDefinition template = templates.get(templateId);
        if (template == null) {
            throw new TemplateNotFoundException("Template not found: " + templateId);
        }
        return template;
    }
    
    public boolean templateExists(String templateId) {
        return templates.containsKey(templateId);
    }
    
    private void indexTemplateFields(TemplateDefinition template) {
        // Index fields for quick lookup across templates
        // Implementation for field indexing
    }
}

// HealthcareTemplateResolver.java - Core composition logic
@Component
public class HealthcareTemplateResolver {
    private final TemplateRegistry templateRegistry;
    private final Map<String, ResolvedTemplate> resolutionCache = new ConcurrentHashMap<>();
    
    public HealthcareTemplateResolver(TemplateRegistry templateRegistry) {
        this.templateRegistry = templateRegistry;
    }
    
    public ResolvedTemplate resolveTemplate(EnrollmentContext context) {
        String templateKey = generateTemplateKey(context);
        
        return resolutionCache.computeIfAbsent(templateKey, key -> {
            List<String> components = discoverTemplateComponents(context);
            return composeTemplate(components, context);
        });
    }
    
    private List<String> discoverTemplateComponents(EnrollmentContext context) {
        List<String> components = new ArrayList<>();
        
        // Base enrollment template (always included)
        components.add("base/enrollment");
        
        // Product type components
        components.add(String.format("products/%s/base", context.getProductType().name().toLowerCase()));
        if (context.getPlanType() != null) {
            String planSpecific = String.format("products/%s/%s", 
                context.getProductType().name().toLowerCase(), 
                context.getPlanType().name().toLowerCase());
            if (templateRegistry.templateExists(planSpecific)) {
                components.add(planSpecific);
            }
        }
        
        // Market segment components
        components.add(String.format("markets/%s/base", 
            context.getMarketSegment().name().toLowerCase()));
        
        // State-specific components
        String stateCode = context.getStateCode().toLowerCase();
        components.add(String.format("states/%s/required", stateCode));
        
        // State-specific product variations
        String stateProduct = String.format("states/%s/%s", stateCode, 
            context.getProductType().name().toLowerCase());
        if (templateRegistry.templateExists(stateProduct)) {
            components.add(stateProduct);
        }
        
        return components;
    }
    
    private ResolvedTemplate composeTemplate(List<String> componentIds, EnrollmentContext context) {
        Map<String, FieldMapping> resolvedFields = new HashMap<>();
        
        for (String componentId : componentIds) {
            TemplateDefinition component = templateRegistry.getTemplate(componentId);
            resolvedFields = mergeTemplateFields(resolvedFields, component, context);
        }
        
        return new ResolvedTemplate(generateTemplateKey(context), resolvedFields);
    }
    
    private Map<String, FieldMapping> mergeTemplateFields(
            Map<String, FieldMapping> currentFields, 
            TemplateDefinition template, 
            EnrollmentContext context) {
        
        Map<String, FieldMapping> merged = new HashMap<>(currentFields);
        
        // Handle inheritance
        if (template.getExtendsTemplate() != null) {
            TemplateDefinition parent = templateRegistry.getTemplate(template.getExtendsTemplate());
            merged = mergeTemplateFields(merged, parent, context);
        }
        
        // Handle includes
        for (String includeId : template.getIncludes()) {
            TemplateDefinition included = templateRegistry.getTemplate(includeId);
            merged = mergeTemplateFields(merged, included, context);
        }
        
        // Apply base fields
        merged.putAll(template.getBaseFields());
        
        // Apply overrides
        merged.putAll(template.getOverrides());
        
        // Apply additions
        merged.putAll(template.getAdditions());
        
        return merged;
    }
    
    private String generateTemplateKey(EnrollmentContext context) {
        return String.format("%s_%s_%s_%s_%d", 
            context.getStateCode().toLowerCase(),
            context.getMarketSegment().name().toLowerCase(),
            context.getProductType().name().toLowerCase(),
            context.getPlanType().name().toLowerCase(),
            context.getPlanYear());
    }
}

// ResolvedTemplate.java - Final composed template
public class ResolvedTemplate {
    private final String templateId;
    private final Map<String, FieldMapping> fieldMappings;
    private final Instant resolvedAt;
    
    public ResolvedTemplate(String templateId, Map<String, FieldMapping> fieldMappings) {
        this.templateId = templateId;
        this.fieldMappings = Map.copyOf(fieldMappings);
        this.resolvedAt = Instant.now();
    }
    
    // Getters
    public String getTemplateId() { return templateId; }
    public Map<String, FieldMapping> getFieldMappings() { return fieldMappings; }
    public Instant getResolvedAt() { return resolvedAt; }
}
```

4. Template Factory for Dynamic Generation

```java
// HealthcareTemplateFactory.java - Creates templates dynamically
@Component
public class HealthcareTemplateFactory {
    private final TemplateRegistry templateRegistry;
    private final HealthcareTemplateResolver templateResolver;
    
    public HealthcareTemplateFactory(TemplateRegistry templateRegistry, 
                                   HealthcareTemplateResolver templateResolver) {
        this.templateRegistry = templateRegistry;
        this.templateResolver = templateResolver;
    }
    
    public String getOrCreateTemplate(EnrollmentContext context) {
        String templateId = generateTemplateId(context);
        
        if (!templateRegistry.templateExists(templateId)) {
            TemplateDefinition dynamicTemplate = createDynamicTemplate(context);
            templateRegistry.registerTemplate(dynamicTemplate);
        }
        
        return templateId;
    }
    
    private TemplateDefinition createDynamicTemplate(EnrollmentContext context) {
        TemplateDefinition.Builder builder = new TemplateDefinition.Builder()
            .templateId(generateTemplateId(context))
            .metadata("product", context.getProductType())
            .metadata("market", context.getMarketSegment())
            .metadata("state", context.getStateCode())
            .metadata("planType", context.getPlanType())
            .metadata("year", context.getPlanYear())
            .metadata("autoGenerated", true);
        
        // Add discovered components
        List<String> components = templateResolver.discoverTemplateComponents(context);
        components.forEach(builder::include);
        
        return builder.build();
    }
    
    private String generateTemplateId(EnrollmentContext context) {
        return String.format("dynamic_%s_%s_%s_%s_%d", 
            context.getStateCode().toLowerCase(),
            context.getMarketSegment().name().toLowerCase(),
            context.getProductType().name().toLowerCase(),
            context.getPlanType().name().toLowerCase(),
            context.getPlanYear());
    }
}
```

5. Data Mapping Engine

```java
// EnrollmentDataMapper.java - Applies templates to source data
@Component
public class EnrollmentDataMapper {
    private final HealthcareTemplateResolver templateResolver;
    private final ValueExtractor valueExtractor;
    private final TransformationEngine transformationEngine;
    
    public EnrollmentDataMapper(HealthcareTemplateResolver templateResolver,
                              ValueExtractor valueExtractor,
                              TransformationEngine transformationEngine) {
        this.templateResolver = templateResolver;
        this.valueExtractor = valueExtractor;
        this.transformationEngine = transformationEngine;
    }
    
    public Map<String, Object> mapEnrollmentData(EnrollmentContext context, Map<String, Object> sourceData) {
        ResolvedTemplate template = templateResolver.resolveTemplate(context);
        return applyFieldMappings(template, sourceData);
    }
    
    private Map<String, Object> applyFieldMappings(ResolvedTemplate template, Map<String, Object> sourceData) {
        Map<String, Object> result = new HashMap<>();
        
        for (Map.Entry<String, FieldMapping> entry : template.getFieldMappings().entrySet()) {
            String targetField = entry.getKey();
            FieldMapping mapping = entry.getValue();
            
            try {
                Object value = extractAndTransformValue(mapping, sourceData);
                result.put(targetField, value);
            } catch (Exception e) {
                if (mapping.isRequired()) {
                    throw new RequiredFieldMappingException(
                        "Failed to map required field: " + targetField, e);
                }
                // Log warning for optional field failures
            }
        }
        
        return result;
    }
    
    private Object extractAndTransformValue(FieldMapping mapping, Map<String, Object> sourceData) {
        // Extract value from source data
        Object rawValue = valueExtractor.extractValue(mapping.getSourcePath(), sourceData);
        
        // Apply transformation if specified
        if (mapping.getTransformFunction() != null) {
            return transformationEngine.transform(
                rawValue, mapping.getTransformFunction());
        }
        
        return rawValue;
    }
}

// Custom Exceptions
public class TemplateNotFoundException extends RuntimeException {
    public TemplateNotFoundException(String message) {
        super(message);
    }
}

public class RequiredFieldMappingException extends RuntimeException {
    public RequiredFieldMappingException(String message, Throwable cause) {
        super(message, cause);
    }
}
```

6. Configuration and Usage Example

```java
// Configuration class to set up the system
@Configuration
public class TemplateConfig {
    
    @Bean
    public TemplateRegistry templateRegistry() {
        TemplateRegistry registry = new TemplateRegistry();
        
        // Register base templates
        registry.registerTemplate(createBaseEnrollmentTemplate());
        registry.registerTemplate(createCaliforniaRequiredTemplate());
        registry.registerTemplate(createMedicalBaseTemplate());
        // Register all other templates...
        
        return registry;
    }
    
    private TemplateDefinition createBaseEnrollmentTemplate() {
        return new TemplateDefinition.Builder()
            .templateId("base/enrollment")
            .baseField("member_name", new FieldMapping.Builder()
                .targetField("member_name")
                .sourcePath("member.demographics.fullName")
                .required(true)
                .build())
            .baseField("date_of_birth", new FieldMapping.Builder()
                .targetField("date_of_birth")
                .sourcePath("member.demographics.dateOfBirth")
                .transformFunction("formatDate('MM/dd/yyyy')")
                .required(true)
                .build())
            .build();
    }
    
    private TemplateDefinition createCaliforniaRequiredTemplate() {
        return new TemplateDefinition.Builder()
            .templateId("states/ca/required")
            .addition("translation_services", new FieldMapping.Builder()
                .targetField("translation_services")
                .sourcePath("plan.features.translationServices")
                .required(true)
                .build())
            .addition("dmhc_licensing", new FieldMapping.Builder()
                .targetField("dmhc_licensing")
                .sourcePath("carrier.licensing.dmhc")
                .required(true)
                .build())
            .build();
    }
}

// Usage Example
@Service
public class EnrollmentSubmissionService {
    private final EnrollmentDataMapper dataMapper;
    private final HealthcareTemplateFactory templateFactory;
    
    public EnrollmentSubmissionService(EnrollmentDataMapper dataMapper,
                                     HealthcareTemplateFactory templateFactory) {
        this.dataMapper = dataMapper;
        this.templateFactory = templateFactory;
    }
    
    public Map<String, Object> generateEnrollmentSubmission(
            EnrollmentContext context, 
            Map<String, Object> applicantData) {
        
        // Ensure template exists
        templateFactory.getOrCreateTemplate(context);
        
        // Map data using resolved template
        return dataMapper.mapEnrollmentData(context, applicantData);
    }
}
```

This Java implementation provides:

· Type-safe domain modeling with enums and immutable objects
· Composition-based template resolution
· Caching for performance with 100+ templates
· Healthcare-specific context handling
· Exception handling for robust error management
· Spring integration ready for dependency injection
· Thread-safe implementations using concurrent collections

The design maximizes reuse through composition while handling the complex multi-dimensional nature of healthcare enrollment across products, markets, and geographic regions.