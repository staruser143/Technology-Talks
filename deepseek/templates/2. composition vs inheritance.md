This design uses COMPOSITION as the primary pattern, with inheritance as a secondary supporting pattern.

Let me break down why:

Primary Pattern: Composition

1. Explicit Composition via Includes

```yaml
# This is COMPOSITION - building templates from parts
template_001.yaml:
includes:  # ← Explicit composition
  - "categories/customer_fields"
  - "categories/financial_fields"
  - "categories/shipping_fields"
```

2. Field Categories as Components

```yaml
# These are reusable COMPONENTS
categories/customer_fields.yaml:
customer:
  name: "customer.full_name"
  address: "customer.address.full"

categories/financial_fields.yaml:
financial:
  total: "document.totals.grand_total"
```

3. Template Built from Parts

The template is composed of these independent, reusable components rather than extending a parent class.

Secondary Pattern: Inheritance

1. Inheritance for Specialization

```yaml
# This is INHERITANCE - "is-a" relationship
commercial_invoice.yaml:
_extends: "base_invoice"  # ← Inheritance
overrides:
  customer_name: "client.business_name"
```

2. But Even Inheritance is Implemented via Composition

```python
def merge_inheritance(self, template):
    base_fields = {}
    
    # Inheritance is achieved by COMPOSING base template + overrides
    if '_extends' in template:
        base_template = self.resolve_template(template['_extends'])
        base_fields = self.deep_merge(base_fields, base_template)  # ← Composition
    
    result = self.deep_merge(base_fields, template.get('additions', {}))
    return result
```

Why Composition Over Inheritance?

1. Flexibility

```yaml
# With composition - mix and match
template_A:
  includes: ["customer_fields", "financial_fields"]

template_B:
  includes: ["customer_fields", "shipping_fields"]  # Different combination

template_C:
  includes: ["customer_fields", "financial_fields", "legal_fields"]
```

2. Avoids Deep Inheritance Chains

```
# Composition avoids this inheritance mess:
BaseDocument → BaseInvoice → CommercialInvoice → SpecialCommercialInvoice
```

3. Explicit Dependencies

```yaml
# Clear what you're composed of
includes:
  - "categories/customer_fields"      # ← Explicit dependency
  - "categories/financial_fields"     # ← Explicit dependency
  - "categories/shipping_fields"      # ← Explicit dependency
```

The Hybrid Approach

The design actually uses a hybrid approach:

```python
class TemplateResolver:
    def resolve_template(self, template):
        # STEP 1: Composition via includes
        base_fields = self.resolve_includes(template.get('includes', []))
        
        # STEP 2: Inheritance chain resolution  
        if '_extends' in template:
            parent_fields = self.resolve_template(template['_extends'])
            base_fields = self.deep_merge(base_fields, parent_fields)
        
        # STEP 3: Apply template-specific fields (more composition)
        return self.deep_merge(base_fields, template.get('additions', {}))
```

Composition Benefits in Your Context

1. Better for 100+ Templates

```yaml
# Reuse small, focused components
template_053.yaml:
includes:
  - "categories/customer_contact"     # Used in 80 templates
  - "categories/invoice_header"       # Used in 45 templates  
  - "categories/tax_section"          # Used in 30 templates
  - "special_fields/industry_specific" # Used in 5 templates
```

2. Easier Maintenance

```yaml
# Change in one place affects all composed templates
categories/customer_fields.yaml:
customer:
  name: "customer.legal_name"  # ← Change here affects all templates that include this
```

3. Avoids Fragile Base Class Problem

With inheritance, changes to base templates can break many derived templates. With composition, changes are isolated to specific components.

Recommendation

Emphasize composition even more by making includes the primary mechanism and using inheritance (_extends) only for true "is-a" relationships:

```yaml
# Preferred: Composition-based
good_template.yaml:
includes:
  - "base_document"
  - "invoice_specific"
  - "commercial_additions"

# Use sparingly: Inheritance-based  
specialized_template.yaml:
_extends: "commercial_invoice"  # Only if it truly IS a commercial invoice
overrides:
  # minimal overrides
```

This gives you the flexibility needed for 100+ templates while maintaining clarity and reducing duplication.