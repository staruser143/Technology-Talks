Yes, absolutely! Let me enhance the filter condition system to support numerical comparisons and logical operators. This will make the configuration much more powerful.

Enhanced Filter Condition System

1. Enhanced Filter Condition Parser

```java
// FilterCondition.java
public class FilterCondition {
    public enum Operator {
        EQUALS("=="),
        NOT_EQUALS("!="),
        GREATER_THAN(">"),
        GREATER_THAN_EQUALS(">="),
        LESS_THAN("<"),
        LESS_THAN_EQUALS("<="),
        AND("&&"),
        OR("||");
        
        private final String symbol;
        
        Operator(String symbol) {
            this.symbol = symbol;
        }
        
        public String getSymbol() {
            return symbol;
        }
        
        public static Operator fromSymbol(String symbol) {
            for (Operator op : values()) {
                if (op.symbol.equals(symbol)) {
                    return op;
                }
            }
            throw new IllegalArgumentException("Unknown operator: " + symbol);
        }
    }
    
    public static class Condition {
        private String field;
        private Operator operator;
        private String value;
        private Condition left;
        private Condition right;
        private Operator logicalOperator;
        
        // Constructors for simple conditions
        public Condition(String field, Operator operator, String value) {
            this.field = field;
            this.operator = operator;
            this.value = value;
        }
        
        // Constructors for logical conditions
        public Condition(Condition left, Operator logicalOperator, Condition right) {
            this.left = left;
            this.logicalOperator = logicalOperator;
            this.right = right;
        }
        
        // getters and setters
        public String getField() { return field; }
        public Operator getOperator() { return operator; }
        public String getValue() { return value; }
        public Condition getLeft() { return left; }
        public Condition getRight() { return right; }
        public Operator getLogicalOperator() { return logicalOperator; }
        public boolean isLogical() { return logicalOperator != null; }
    }
}

// FilterConditionParser.java
public class FilterConditionParser {
    
    public static FilterCondition.Condition parse(String conditionString) {
        if (conditionString == null || conditionString.trim().isEmpty()) {
            return null;
        }
        
        // Remove outer parentheses if present
        conditionString = conditionString.trim();
        if (conditionString.startsWith("(") && conditionString.endsWith(")")) {
            conditionString = conditionString.substring(1, conditionString.length() - 1);
        }
        
        // Check for logical operators (&&, ||) - lowest precedence
        int logicalOpIndex = findLogicalOperator(conditionString);
        if (logicalOpIndex != -1) {
            String leftPart = conditionString.substring(0, logicalOpIndex).trim();
            String rightPart = conditionString.substring(logicalOpIndex + 2).trim();
            String opSymbol = conditionString.substring(logicalOpIndex, logicalOpIndex + 2);
            
            FilterCondition.Operator logicalOp = FilterCondition.Operator.fromSymbol(opSymbol);
            return new FilterCondition.Condition(
                parse(leftPart),
                logicalOp,
                parse(rightPart)
            );
        }
        
        // Parse simple condition
        return parseSimpleCondition(conditionString);
    }
    
    private static int findLogicalOperator(String condition) {
        int depth = 0;
        for (int i = 0; i < condition.length() - 1; i++) {
            char c = condition.charAt(i);
            if (c == '(') depth++;
            else if (c == ')') depth--;
            
            if (depth == 0) {
                String twoChar = condition.substring(i, i + 2);
                if ("&&".equals(twoChar) || "||".equals(twoChar)) {
                    return i;
                }
            }
        }
        return -1;
    }
    
    private static FilterCondition.Condition parseSimpleCondition(String condition) {
        // Supported operators in order of precedence
        String[] operators = {"!=", ">=", "<=", "==", ">", "<", "="};
        
        for (String opStr : operators) {
            int opIndex = condition.indexOf(opStr);
            if (opIndex != -1) {
                String field = condition.substring(0, opIndex).trim();
                String value = condition.substring(opIndex + opStr.length()).trim();
                
                // Remove quotes if present
                if ((value.startsWith("'") && value.endsWith("'")) || 
                    (value.startsWith("\"") && value.endsWith("\""))) {
                    value = value.substring(1, value.length() - 1);
                }
                
                FilterCondition.Operator operator = FilterCondition.Operator.fromSymbol(
                    opStr.equals("=") ? "==" : opStr
                );
                
                return new FilterCondition.Condition(field, operator, value);
            }
        }
        
        throw new IllegalArgumentException("Invalid condition format: " + condition);
    }
}
```

2. Enhanced Condition Evaluator

```java
// ConditionEvaluator.java
public class ConditionEvaluator {
    
    public static boolean evaluate(JsonNode data, FilterCondition.Condition condition) {
        if (condition == null) {
            return true;
        }
        
        if (condition.isLogical()) {
            boolean leftResult = evaluate(data, condition.getLeft());
            boolean rightResult = evaluate(data, condition.getRight());
            
            switch (condition.getLogicalOperator()) {
                case AND:
                    return leftResult && rightResult;
                case OR:
                    return leftResult || rightResult;
                default:
                    throw new IllegalArgumentException("Unknown logical operator: " + condition.getLogicalOperator());
            }
        } else {
            return evaluateSimpleCondition(data, condition);
        }
    }
    
    private static boolean evaluateSimpleCondition(JsonNode data, FilterCondition.Condition condition) {
        String actualValue = extractFieldValue(data, condition.getField());
        String expectedValue = condition.getValue();
        
        if (actualValue == null) {
            return false;
        }
        
        // Try numerical comparison first
        if (isNumeric(actualValue) && isNumeric(expectedValue)) {
            return evaluateNumericComparison(
                Double.parseDouble(actualValue),
                condition.getOperator(),
                Double.parseDouble(expectedValue)
            );
        }
        
        // Fall back to string comparison
        return evaluateStringComparison(actualValue, condition.getOperator(), expectedValue);
    }
    
    private static boolean evaluateNumericComparison(double actual, FilterCondition.Operator operator, double expected) {
        switch (operator) {
            case EQUALS:
                return actual == expected;
            case NOT_EQUALS:
                return actual != expected;
            case GREATER_THAN:
                return actual > expected;
            case GREATER_THAN_EQUALS:
                return actual >= expected;
            case LESS_THAN:
                return actual < expected;
            case LESS_THAN_EQUALS:
                return actual <= expected;
            default:
                throw new IllegalArgumentException("Numeric operator not supported: " + operator);
        }
    }
    
    private static boolean evaluateStringComparison(String actual, FilterCondition.Operator operator, String expected) {
        switch (operator) {
            case EQUALS:
                return actual.equals(expected);
            case NOT_EQUALS:
                return !actual.equals(expected);
            case GREATER_THAN:
                return actual.compareTo(expected) > 0;
            case GREATER_THAN_EQUALS:
                return actual.compareTo(expected) >= 0;
            case LESS_THAN:
                return actual.compareTo(expected) < 0;
            case LESS_THAN_EQUALS:
                return actual.compareTo(expected) <= 0;
            default:
                throw new IllegalArgumentException("String operator not supported: " + operator);
        }
    }
    
    private static String extractFieldValue(JsonNode data, String fieldPath) {
        if (data == null) {
            return null;
        }
        
        String[] path = fieldPath.split("\\.");
        JsonNode currentNode = data;
        
        for (String segment : path) {
            if (currentNode == null || !currentNode.has(segment)) {
                return null;
            }
            currentNode = currentNode.get(segment);
        }
        
        return currentNode != null && !currentNode.isNull() ? currentNode.asText() : null;
    }
    
    private static boolean isNumeric(String str) {
        if (str == null) {
            return false;
        }
        try {
            Double.parseDouble(str);
            return true;
        } catch (NumberFormatException e) {
            return false;
        }
    }
}
```

3. Enhanced YAML Configuration Examples

```yaml
singleFieldsFromArrays:
  # Primary Applicant with age check
  - pdfField: "primaryapplicant.FName"
    arraySourceField: "applicants"
    filterCondition: "relationship=='primaryapplicant' && personalInfo.age>=18"
    sourceField: "personalInfo.firstName"

  # High income applicant
  - pdfField: "high.income.applicant"
    arraySourceField: "applicants"
    filterCondition: "financialInfo.annualIncome>100000"
    sourceField: "personalInfo.fullName"

  # Recent application with complex condition
  - pdfField: "recent.application.flag"
    arraySourceField: "applications"
    filterCondition: "(status=='approved' && amount>=50000) || (status=='pending' && daysSinceSubmission<=7)"
    sourceField: "applicationId"

repeatingSections:
  # Adult dependents only
  - baseFieldName: "AdultDependent"
    arraySourceField: "dependents"
    filterCondition: "age>=18 && relationship!='spouse'"
    maxOccurrences: 5
    fieldMappings:
      - sourceField: "firstName"
        pdfField: "FName"
      - sourceField: "age"
        pdfField: "Age"

  # High-value transactions
  - baseFieldName: "LargeTransaction"
    arraySourceField: "transactions"
    filterCondition: "amount>1000 && (type=='purchase' || type=='withdrawal')"
    maxOccurrences: 10
    fieldMappings:
      - sourceField: "description"
        pdfField: "Desc"
      - sourceField: "amount"
        pdfField: "Amount"

  # Urgent pending items
  - baseFieldName: "UrgentItem"
    arraySourceField: "tasks"
    filterCondition: "priority=='high' && status!='completed' && daysOpen>3"
    maxOccurrences: 8
    fieldMappings:
      - sourceField: "taskName"
        pdfField: "Name"
      - sourceField: "daysOpen"
        pdfField: "DaysOpen"
```

4. Enhanced PDF Form Filler Integration

```java
// Enhanced filtering in PdfFormFiller
private List<JsonNode> getFilteredArrayData(ObjectNode jsonData, String arraySourceField, String filterCondition) {
    List<JsonNode> allData = getArrayData(jsonData, arraySourceField);
    if (filterCondition == null) {
        return allData;
    }
    
    FilterCondition.Condition condition = FilterConditionParser.parse(filterCondition);
    
    return allData.stream()
            .filter(item -> ConditionEvaluator.evaluate(item, condition))
            .collect(Collectors.toList());
}

private String extractSingleValueFromArray(ObjectNode jsonData, SingleFieldFromArrayConfig config) {
    List<JsonNode> arrayData = getArrayData(jsonData, config.getArraySourceField());
    
    FilterCondition.Condition condition = config.getFilterCondition() != null ? 
            FilterConditionParser.parse(config.getFilterCondition()) : null;
    
    for (JsonNode item : arrayData) {
        if (condition == null || ConditionEvaluator.evaluate(item, condition)) {
            return extractValueFromItem(item, config.getSourceField(), config.getDefaultValue());
        }
    }
    
    return config.getDefaultValue();
}
```

5. Sample JSON Data for Complex Filtering

```json
{
  "applicants": [
    {
      "relationship": "primaryapplicant",
      "personalInfo": {
        "firstName": "John",
        "lastName": "Doe",
        "age": "35"
      },
      "financialInfo": {
        "annualIncome": "85000"
      }
    },
    {
      "relationship": "spouse",
      "personalInfo": {
        "firstName": "Jane", 
        "lastName": "Doe",
        "age": "32"
      },
      "financialInfo": {
        "annualIncome": "65000"
      }
    },
    {
      "relationship": "Dependentchild",
      "personalInfo": {
        "firstName": "Alice",
        "lastName": "Doe",
        "age": "15"
      }
    }
  ],
  "transactions": [
    {
      "type": "purchase",
      "amount": "1500",
      "description": "Laptop"
    },
    {
      "type": "deposit", 
      "amount": "500",
      "description": "Salary"
    },
    {
      "type": "withdrawal",
      "amount": "2000", 
      "description": "Rent"
    }
  ]
}
```

Supported Features:

1. Numerical Comparisons: >, >=, <, <= with automatic type detection
2. Equality Operators: ==, !=, = (alias for ==)
3. Logical Operators: && (AND), || (OR)
4. Parentheses: For grouping complex conditions
5. Nested Field Access: personalInfo.age, financialInfo.income, etc.
6. Type Coercion: Automatic string/number detection and comparison
7. Complex Expressions: Multiple conditions with mixed operators

This enhanced filter system now supports sophisticated data selection logic while maintaining the clean YAML configuration approach.