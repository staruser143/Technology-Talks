Great question â€” and **yes**, if you use **array indexing** (e.g., `dependents[0]`, `dependents[1]`), you **must** decide how the engine should behave when the source JSON has *fewer* dependents or **none at all**.

There are **three clean strategies** â€” and Iâ€™ll show you which one is best.

---

# âœ… **Recommended Strategy (Best Practice):**

## **1. Allow index access even if missing â€” engine returns `null` â†’ transforms â†’ empty string**

This is exactly how our mapping engine is designed:

### âœ” If the path does not exist

â†’ JSONPath returns `null`
â†’ Transform chain receives `null`
â†’ Final output becomes **blank** (or whatever default you configure)

### This means you do *NOT* need to do checks in YAML.

### Example

Given this field:

```yaml
dep1FirstName:
  expr: "$.dependents[0].name.first"
```

If there are **0 dependents**, `$.dependents[0]` simply returns:

```
null
```

And your engine sets the field value to:

```
""
```

This is the cleanest approach â€” your YAML stays simple.

---

# ğŸ§  Why This Works Well

* PDF fields for non-existing dependents should simply remain blank
* Keeps YAML declarative
* No conditional logic required for missing dependents
* No crashes, no out-of-bound exceptions
* Mapping engine handles all the safety checks

Most forms allow up to N dependents but not exactly N â€” so blank fields are normal and expected.

---

# âœ… **2. If You Want Optional Dependent Sections (Advanced)**

You may want to render only sections that exist.
For example:

| Dependents | Rendered sections |
| ---------- | ----------------- |
| 0          | none              |
| 1          | only Dependent 1  |
| 2          | Dependent 1 & 2   |
| 3          | Dependent 1, 2, 3 |

In that case, we can add a *transform-based* guard:

```yaml
dep1FirstName:
  expr: "$.dependents"
  transform: ["ifArrayHasIndex:0", "extract:$.dependents[0].name.first"]
```

This requires implementing two transforms:

* `ifArrayHasIndex:index` â†’ returns null if index missing
* `extract:path` â†’ evaluates a nested JSONPath on the whole source node

But **only use this if your form dynamically hides fields**, which most PDF AcroForms do not.

---

# âŒ **3. Do NOT write conditional JSONPath/XPath-like checks**

Thisâ€¦

```yaml
dep1Name:
  expr: "$..dependents[?(@.size() > 0)][0].name.first"
```

â€¦is syntactically ugly, brittle, and hard to maintain.
Avoid this completely.

---

# â­ Optimal Answer for PDF Mapping

### **â¡ For PDF fields: ALWAYS allow missing dependents. Let the engine return blank values.**

Why?

* PDFs donâ€™t hide form fields unless specifically built for dynamic rendering
* Blank dependent fields are perfectly acceptable
* Mapping is predictable
* Mapping spec stays simple and readable

---

# ğŸ“Œ Final Recommendation

Your YAML should **not** check dependents count.

Use simple fields:

```yaml
dep1FirstName:
  expr: "$.dependents[0].name.first"

dep2FirstName:
  expr: "$.dependents[1].name.first"

dep3FirstName:
  expr: "$.dependents[2].name.first"
```

And let the engine decide:

* If index exists â†’ fill value
* If not â†’ blank field

This is the **cleanest**, **most scalable**, and **most common** pattern in enrollment/PDF mapping engines.

---

# ğŸ‘‰ If you'd like:

I can provide:

âœ” A **medical enrollment YAML** that supports dynamic number of dependents
âœ” A **transform** called `safeIndex` to automatically protect array indexing
âœ” A **sample JSON** with 0, 1, 2, 3 dependents to show what the engine outputs
âœ” A version of the YAML using JSONata instead of JSONPath

Just tell me what you want next.
