Below is a **deep explanation** of the engine‚Äôs `execute()` method ‚Äî *why it takes multiple parameters*, *what responsibilities each one has*, and *what variations or advanced use cases this design supports*.

This will clarify:

* Why the engine is not simply `execute(sourceData)`
* Why it receives flags like productType, marketCategory, state, templateId
* How this architecture future-proofs your system
* How other vendors or services can plug in different configurations
* Advanced variations supported (bundled templates, multimodal merging, adaptive rules, etc.)

---

# ‚úÖ **1. What the Engine Looks Like (Reference)**

A typical signature we designed:

```java
public PdfDocument execute(
    Map<String, Object> sourceData,
    String marketCategory,
    String productType,
    String state,
    String templateId,
    Map<String, Object> runtimeParams   // optional
)
```

Let‚Äôs break this down.

---

# üéØ **2. Why Not Just `execute(sourceData)`?**

Because the mapping engine supports **multiple template families**, **multiple PDF layouts**, and **multiple business rules** based on:

* Market segmentation
* Product segmentation
* State-specific mandates
* Template versioning
* Client-specific overrides
* Runtime decisioning

You will almost never know the template *only* from sourceData.

Therefore the engine needs classification metadata.

---

# üß© **3. Why Each Parameter Exists**

## **(1) `sourceData` ‚Äî the payload**

Mandatory.
This is the applicant + plan data you are mapping to PDF fields.

---

## **(2) `marketCategory` ‚Äî INDIVIDUAL / GROUP / MEDICARE**

Markets change:

| Market     | Examples of differences                        |
| ---------- | ---------------------------------------------- |
| Individual | Household income, APTC, dependents rules       |
| Group      | Employee + employer sections, employer tax IDs |
| Medicare   | Benefit year rules, CMS-specific fields        |

If the engine didn't have this parameter, you'd need **hundreds of templates** duplicated.

By passing `marketCategory`, the engine loads:

```
market/<marketCategory>.yaml
```

This allows:

* Different dependent rules
* Different eligibility logic
* Different section behavior
* Different legal text

---

## **(3) `productType` ‚Äî MEDICAL / DENTAL / VISION / AD&D**

Product drives:

* Fields shown on form
* Benefit-level rules
* Carrier-specific logic
* Premium calculations

E.g., dental forms have completely different sections than medical.

This parameter enables:

```
product/<productType>.yaml
```

Without it, you‚Äôd have separate templates like:

```
medical_CA_template1.yaml
dental_CA_template1.yaml
vision_CA_template1.yaml
```

‚Üí Massive bloat.

---

## **(4) `state` ‚Äî CA / TX / NY / FL ...**

States have:

* Different Medicare or ACA rules
* Different required disclosures
* Different dependent rules (e.g., CA adds domestic partners)

This enables:

```
state/<state>.yaml
```

Without this, you would end up with **duplicate templates for each state**.

---

## **(5) `templateId` ‚Äî actual PDF layout**

Same market + same product + same state **can still have multiple PDF files**.

Examples:

* Template v1 vs v2
* Carrier-specific PDFs
* Employer-specific custom PDFs
* Plan-year specific PDFs
* Multi-page vs single-page layouts

This parameter controls:

```
templates/<templateId>.yaml
```

---

## **(6) `runtimeParams` ‚Äî optional dynamic overrides**

This is the most powerful parameter.

Supports:

### **a) Conditional template variant selection**

Example:

```json
runtimeParams: { "isPediatric": true }
```

YAML rules can read this and choose:

* Pediatric dental template
* Adult dental template

### **b) Feature toggles**

Examples:

```
use2025Rules=true
skipGuardianSection=true
enablePremiumRecalculation=false
```

### **c) Custom client overrides**

Enterprise clients may want:

* Custom disclaimers
* Custom field mappings
* Additional validations

You can inject these via:

```
runtimeParams.customMapping
```

---

# üß† **4. Putting It Together ‚Äî What the Engine Does with These Parameters**

### Step 1 ‚Üí Load base.yaml

### Step 2 ‚Üí Load product/<productType>.yaml

### Step 3 ‚Üí Load market/<marketCategory>.yaml

### Step 4 ‚Üí Load state/<state>.yaml

### Step 5 ‚Üí Load templates/<templateId>.yaml

### Step 6 ‚Üí Apply runtimeParams overrides

### Step 7 ‚Üí Evaluate logical expressions

### Step 8 ‚Üí Transform values

### Step 9 ‚Üí Bind to PDF fields

### Step 10 ‚Üí Generate PDF

All parameters contribute to at least one stage in this pipeline.

---

# üöÄ **5. Variations Supported by This Design**

This parameter-driven engine supports the following capabilities:

---

## **Variation A ‚Äî Multi-template bundles**

One request can produce multiple PDFs (e.g., summary + enrollment + disclosures).

Engine can loop:

```java
execute(..., templateId="ENROLLMENT")
execute(..., templateId="DISCLOSURE")
execute(..., templateId="SUMMARY")
```

---

## **Variation B ‚Äî Multi-market PDF kits**

A large employer sponsoring both Medical + Dental + Vision:

```
execute(source, GROUP, MEDICAL, CA, templateIdA)
execute(source, GROUP, DENTAL, CA, templateIdB)
execute(source, GROUP, VISION, CA, templateIdC)
```

No duplication of YAML logic across products.

---

## **Variation C ‚Äî Dynamic dependent rules**

Based on state or market:

* CA: domestic partners allowed
* TX: age limit 26
* IND category: household income section mandatory

Each parameter controls which YAML rules activate.

---

## **Variation D ‚Äî Versioned templates**

Same template, different year:

```
templateId = "med_enroll_CA_v2024"
templateId = "med_enroll_CA_v2025"
```

No need to rewrite base.yaml or market.yaml.

---

## **Variation E ‚Äî Carrier-Specific PDF Differences**

```
templateId = "anthem_medical_CA"
templateId = "kaiser_medical_CA"
templateId = "aetna_medical_CA"
```

All sharing the same product/market/state logic.

---

## **Variation F ‚Äî Partner/Client-specific branding**

```
runtimeParams.brand = "ACME"
runtimeParams.logo = "acme-logo.png"
```

Your engine can drop the logo into a PDF placeholder.

---

## **Variation G ‚Äî API Request Equivalence**

The parameters directly align to real-world API inputs:

```json
{
  "data": {...},
  "productType": "MEDICAL",
  "marketCategory": "INDIVIDUAL",
  "state": "CA",
  "templateId": "med_enroll_2025"
}
```

This makes your engine API-friendly.

---

# üèÜ **6. Summary ‚Äî Why All Parameters Matter**

| Parameter      | Why It Exists                               |
| -------------- | ------------------------------------------- |
| productType    | Different product sections & fields         |
| marketCategory | Market-specific business rules              |
| state          | State-specific legal and eligibility rules  |
| templateId     | The actual PDF file and field mappings      |
| runtimeParams  | Highly flexible overrides & feature toggles |
| sourceData     | Values to populate                          |

We keep all parameters because each one influences:

* Which YAML files load
* How merging happens
* Which rules evaluate
* Which values populate
* Which transformations apply
* Which PDF fields get set
* Which template version is output

This allows **one engine** to support infinite configuration variations without modifying Java code.

---

# üìå If you want‚Ä¶

I can now provide:

### ‚úî The complete `execute()` implementation

### ‚úî The full engine class (TemplateResolver + Merger + Evaluator + PdfFiller)

### ‚úî Unit tests

### ‚úî Benchmarking recommendations

### ‚úî Error handling & diagnostics design

Tell me what you want next.
