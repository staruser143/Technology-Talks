Below is a **complete, realistic set of YAML examples** for your multi-layer mapping engine:

‚úî **base.yaml**
‚úî **product/medical.yaml**
‚úî **market/individual.yaml**
‚úî **state/CA.yaml**
‚úî **template/medical_enrollment_v1.yaml**

These follow the architecture we previously designed:

> **base ‚Üí product ‚Üí market ‚Üí state ‚Üí template**
> (Each layer overrides the previous one)

Each YAML includes:

* `logicalFields`: JSONPath/JSONata expressions
* `transforms`: named reusable transformations
* `pdfFields`: logical ‚Üí PDF binding
* Dynamic dependent handling
* Conditional logic

You can use exactly these in your engine.

---

# üß© **1. base.yaml**

*Generic rules that apply to all templates*

```yaml
# base.yaml

logicalFields:
  applicant.firstName: "$.applicant.name.first"
  applicant.lastName: "$.applicant.name.last"
  applicant.fullName: "$string($.applicant.name.first) & ' ' & string($.applicant.name.last)"
  applicant.ssn: "$.applicant.ssn"
  applicant.dob: "$.applicant.dateOfBirth"

  # Address (available everywhere)
  address.line1: "$.applicant.address.line1"
  address.city: "$.applicant.address.city"
  address.state: "$.applicant.address.state"
  address.zip: "$.applicant.address.zip"

# Shared transformation library
transforms:
  maskSsn:
    type: mask
    pattern: "(\\d{3})-(\\d{2})-(\\d{4})"
    replacement: "***-**-$3"

  extractYear:
    type: datePart
    part: year

  extractMonth:
    type: datePart
    part: month

  extractDay:
    type: datePart
    part: day
```

---

# üß© **2. product/medical.yaml**

*Product-specific fields (medical only)*

```yaml
# product/medical.yaml

logicalFields:
  plan.type: "$.plan.type"
  plan.carrierName: "$.plan.carrier"
  plan.metalLevel: "$.plan.metalLevel"

  # Dependents array (generic)
  dependentList: "$.dependents"

transforms:
  ageFromDob:
    type: dateToAge
```

---

# üß© **3. market/individual.yaml**

*Individual market configuration*

```yaml
# market/individual.yaml

logicalFields:
  market.category: "'INDIVIDUAL'"
  household.income: "$.income.annual"

  # Filter dependents: only spouse & children
  eligibleDependents: "$.dependents[applicantType in ['SPOUSE','CHILD']]"

transforms:
  markIndividual:
    type: const
    value: "IND"
```

---

# üß© **4. state/CA.yaml**

*State-specific overrides and fields (California)***

```yaml
# state/CA.yaml

logicalFields:
  address.stateFull: "'California'"
  applicant.isCAResident: "$.applicant.address.state = 'CA'"

  # State-specific dependent filtering rule:
  # In CA, domestic partners also count as dependents
  eligibleDependents: "$.dependents[applicantType in ['SPOUSE','CHILD','DOMESTIC_PARTNER']]"

transforms:
  maskZipCA:
    type: mask
    pattern: "(\\d{3})(\\d{2})"
    replacement: "$1**"
```

---

# üß© **5. template/medical_enrollment_v1.yaml**

_Final layer: contains **only** PDF fields and overrides**
(This is the template that is selected by the engine.)

```yaml
# template/medical_enrollment_v1.yaml

# Optional template metadata
template:
  pdf: "medical_enrollment_v1.pdf"
  version: "1.0"

logicalFields:
  # Overrides allowed (if needed)
  applicant.ssnMasked:
    value: "$.applicant.ssn"
    transforms: ["maskSsn"]

  applicant.age:
    value: "$.applicant.dateOfBirth"
    transforms: ["ageFromDob"]

  # Dynamic dependent mapping
  dependents:
    iterateOver: "eligibleDependents"
    itemName: "dep"
    fields:
      "{index}.name": "$dep.name.first & ' ' & $dep.name.last"
      "{index}.dob": "$dep.dateOfBirth"
      "{index}.relationship": "$dep.applicantType"

pdfFields:
  # Applicant Section
  APPLICANT_FIRST_NAME: "applicant.firstName"
  APPLICANT_LAST_NAME: "applicant.lastName"
  APPLICANT_FULL_NAME: "applicant.fullName"
  APPLICANT_SSN: "applicant.ssnMasked"
  APPLICANT_DOB: "applicant.dob"
  APPLICANT_AGE: "applicant.age"

  # Address
  ADDRESS_LINE1: "address.line1"
  ADDRESS_CITY: "address.city"
  ADDRESS_STATE: "address.state"
  ADDRESS_ZIP: "address.zip"

  # Plan Details
  PLAN_TYPE: "plan.type"
  PLAN_CARRIER: "plan.carrierName"
  METAL_LEVEL: "plan.metalLevel"

  # Dependents (dynamic)
  DEP_{0}_NAME: "dependents.0.name"
  DEP_{0}_DOB: "dependents.0.dob"
  DEP_{0}_REL: "dependents.0.relationship"

  DEP_{1}_NAME: "dependents.1.name"
  DEP_{1}_DOB: "dependents.1.dob"
  DEP_{1}_REL: "dependents.1.relationship"

  DEP_{2}_NAME: "dependents.2.name"
  DEP_{2}_DOB: "dependents.2.dob"
  DEP_{2}_REL: "dependents.2.relationship"

  # (engine will ignore missing dynamic indexes)
```

---

# üìå **How these YAMLs merge**

### Merge Order

1. **base.yaml**
2. **product/medical.yaml**
3. **market/individual.yaml**
4. **state/CA.yaml**
5. **template/medical_enrollment_v1.yaml**

### Example: `eligibleDependents`

| Layer               | Value                                |
| ------------------- | ------------------------------------ |
| market/individual ‚Üí | dependents filtered by spouse/child  |
| state/CA ‚Üí          | overrides and adds domestic partners |
| template ‚Üí          | uses the resolved layer (CA rules)   |

### Example: PDF Fields

Only template YAML contains fields like:

```
APPLICANT_FIRST_NAME: applicant.firstName
```

(base, product, market, state *never* contain PDF fields)

---

# üéÅ Want even more?

I can also generate:

‚úî Example source JSON for this mapping
‚úî The **flattened merged YAML** after applying overlay
‚úî A full **Java implementation** that loads these YAMLs, merges them, evaluates them using JSONPath/JSONata, and fills PDF with PDFBox
‚úî JUnit tests for entire pipeline

Just tell me which one you want next.
