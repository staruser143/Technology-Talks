Great question ‚Äî and this is **exactly** the point where most PDF-mapping engines become unmanageable unless you adopt a good architecture.

If you try to handle multiple **market categories** (Individual, Group, Medicare), **product types** (Medical, Dental, Vision), and **state variations**, you will end up with:

* multiple templates, sometimes dozens
* many fields that are common across templates
* some fields that differ based on market/product/state
* some fields that exist in one PDF but not another
* fields that follow the same *semantic meaning* but have different *AcroForm field names*

If you duplicate mapping YAML for every PDF template ‚Üí **you have created a maintenance nightmare**.

There is a much better, enterprise-scale approach.

---

# ü•á **Best-Practice Architecture for Multi-Template Mapping**

This pattern is used in:

* HL7 FHIR mapping engines
* MuleSoft DataWeave
* Salesforce DocGen
* Claims EDI (HIPAA 834/837)
* Enterprise document generation frameworks

### ‚úî Split mappings into **layers**

### ‚úî Support **inheritance + overrides**

### ‚úî No duplication

### ‚úî Common fields defined once

### ‚úî Template-specific fields defined only where needed

---

# ‚≠ê Recommended Pattern: **Hierarchical Mapping Configuration**

Your YAML should look like this:

```
base.yaml
  ‚ü∂ contains common subscriber/demographics/address/plan fields

base-medical.yaml
  ‚ü∂ adds medical-specific fields for all markets/states

base-dental.yaml
base-vision.yaml
  ‚ü∂ similar for other lines of business

market-individual.yaml
market-group.yaml
market-medicare.yaml
  ‚ü∂ overrides specific to market

state-CA.yaml
state-NY.yaml
state-TX.yaml
  ‚ü∂ any state-specific overrides

template-specific.yaml
  ‚ü∂ only the fields unique to that PDF
```

Then your mapping engine performs:

```
final mapping = merge(
      base,
      product base,
      market overrides,
      state overrides,
      template-specific overrides
)
```

This yields a **single final mapping** for the selected template **with zero duplication**.

---

# üß© **Why This Is the Best Approach**

## ‚úî 1. All common fields defined only once

Example: subscriberName, DOB, address, phone ‚Äî shared across 20 PDFs.

Defined once in **base.yaml**.

## ‚úî 2. Product-specific shared fields defined once

Example: PCP ID (medical only), Dental office number (dental only)

Defined once in **base-medical.yaml**, **base-dental.yaml**, etc.

## ‚úî 3. Market-level variations only override differences

Group enrollment may have:

* Employer group number
* Coverage effective rules
* Contribution fields

Only these go into **market-group.yaml**.

## ‚úî 4. State differences are isolated

Example:

* CA has specific waivers
* NY has specific dependent rules
* MA needs tobacco attestation

Only those differences appear in **state-CA.yaml**, etc.

## ‚úî 5. Template-specific YAML is very small

Only the AcroForm field names:

* subscriberFirstName ‚Üí PDF field "SUB_FNAME_01"
* subscriberDOB ‚Üí "DOB_#MAIN"
* dependent1LastName ‚Üí "CHILD1_LNAME"

Template-specific YAML contains just field name mappings or overrides.

---

# üì¶ **Folder Structure Recommended**

```
mappings/
   common/
      base.yaml
   product/
      medical.yaml
      dental.yaml
      vision.yaml
   market/
      individual.yaml
      group.yaml
      medicare.yaml
   state/
      CA.yaml
      NY.yaml
      TX.yaml
   templates/
      medical_individual_CA_template1.yaml
      medical_group_TX_template2.yaml
      dental_individual_template3.yaml
```

---

# üß† **How Final Mapping is Resolved**

Imagine generating:

* Market: **INDIVIDUAL**
* Product: **MEDICAL**
* State: **CA**
* Template: ‚ÄúBlueShield-Indiv-Medical-CA-v3.pdf‚Äù

Your engine merges:

```
base.yaml
+ medical.yaml
+ individual.yaml
+ CA.yaml
+ templates/BlueShield...yaml
------------------------------------------------
= final merged mapping
```

---

# üí° Why This Works Perfectly with JSONata or JSONPath

Because:

* Common fields use identical JSONata expressions (`subscriber.name.first`)
* Overrides only change expressions where needed
* Template-specific YAML only changes the PDF **field name**, not the extract logic

This gives you:

### ‚úî Reusable JSONata for common fields

### ‚úî Layered override for state/market rules

### ‚úî Minimal template YAML

### ‚úî No duplication

### ‚úî Highly maintainable

---

# üí¨ Want me to demonstrate this?

I can show:

### üîπ Full example:

* `base.yaml`
* `product-medical.yaml`
* `market-individual.yaml`
* `state-CA.yaml`
* `template-mapping.yaml`
* **Final merged YAML output**

### üîπ Or show the Java merging engine

### üîπ Or show how JSONata is referenced in each layer

### üîπ Or show how dynamic dependent logic fits into this system

Just tell me which one.
