Nice — below is a **complete, focused implementation** of the mapping engine extended to support **nested repeaters** (the `each` / `repeat` concept) end-to-end.

What you’ll get:

* a small DSL for repeaters in YAML (`repeat` blocks)
* recursive evaluator that expands nested repeats and produces flattened logical keys (e.g. `app1_cov2_type`)
* JSONPath compilation & caching (startup/precompile friendly)
* simple transform support and PdfBinder to map logical keys → PDF fields
* example YAML showing nested applicant → coverages repeater
* a usage snippet showing how to call the engine

This implementation is purposely compact and practical — you can drop it into a Spring project and extend it (transform registry, JSONata, caching policy) as needed.

---

## Design summary (quick)

* YAML defines `fields` (single mappings) and `repeaters` (list of repeat blocks).
* A `Repeater` has `path` (clean DSL, no leading `$`), `as` (loop variable), `indexBase` (1 or 0), `fields` (map of key templates → path or expr), and optional nested `repeaters`.
* At startup you should pre-load/merge/compile YAMLs; `ExpressionCompiler` compiles JSONPath expressions and caches them.
* At runtime the `NestedRepeaterEngine` evaluates single fields and repeaters recursively, producing a flat map of `logicalKey -> value` which `PdfBinder` then maps to `pdfField -> value`.

---

## Code — single-file friendly layout (split into classes)

/* For brevity I omit package declarations; adapt as needed. */

### 1) Models

```java
import java.util.*;

public class MappingSpec {
    public Map<String, FieldDef> fields = new LinkedHashMap<>();    // simple fields
    public List<RepeaterDef> repeaters = new ArrayList<>();        // top-level repeaters
    public Map<String,String> pdfFields = new LinkedHashMap<>();   // pdf field -> logical key
}

public class FieldDef {
    public String path;            // JSONPath-like DSL (no leading $ required)
    public String expr;            // optional JSONata – not used in this sample
    public List<String> transforms; // optional
}

public class RepeaterDef {
    public String name;            // optional name for readability
    public String path;            // path to array in source (e.g., applicants or applicants[type=PRIMARY])
    public String as = "item";     // loop var name (used in templates if needed)
    public int indexBase = 1;      // 1 or 0; PDF often 1-based
    public Map<String, String> fields = new LinkedHashMap<>(); // pdfKeyTemplate -> fieldPath (relative to repeater item)
    public List<RepeaterDef> repeaters = new ArrayList<>(); // nested repeaters
}
```

---

### 2) ExpressionCompiler (normalize DSL -> JSONPath and compile & cache)

```java
import com.jayway.jsonpath.JsonPath;
import com.jayway.jsonpath.ReadContext;
import java.util.concurrent.ConcurrentHashMap;
import java.util.Map;
import java.util.regex.*;

public class ExpressionCompiler {
    private final Map<String, com.jayway.jsonpath.JsonPath> cache = new ConcurrentHashMap<>();

    /** Normalize user-friendly path into JSONPath and compile it */
    public com.jayway.jsonpath.JsonPath compile(String raw) {
        if (raw == null) return null;
        String norm = normalize(raw);
        return cache.computeIfAbsent(norm, k -> JsonPath.compile(k));
    }

    private String normalize(String raw) {
        String s = raw.trim();

        // handle "in" lists e.g., dependents[type in [CHILD, SPOUSE]]
        Pattern inPattern = Pattern.compile("([\\w.]+)\\s+in\\s+\\[([^\\]]+)\\]");
        Matcher m = inPattern.matcher(s);
        StringBuffer sb = new StringBuffer();
        while (m.find()) {
            String field = m.group(1);
            String vals = m.group(2);
            String[] parts = vals.split("\\s*,\\s*");
            StringBuilder arr = new StringBuilder("[");
            for (int i=0;i<parts.length;i++) {
                String p = parts[i].trim();
                if (!(p.startsWith("'")||p.startsWith("\""))) p = "'" + p + "'";
                if (i>0) arr.append(",");
                arr.append(p);
            }
            arr.append("]");
            String repl = "@." + field + " in " + arr.toString();
            m.appendReplacement(sb, Matcher.quoteReplacement(repl));
        }
        m.appendTail(sb);
        s = sb.toString();

        // handle bracket/brace filter shorthand: [field = value] or {field = value}
        Pattern filterPattern = Pattern.compile("(\\[|\\{)\\s*([^\\]\\}]+?)\\s*(\\]|\\})");
        m = filterPattern.matcher(s);
        sb = new StringBuffer();
        while (m.find()) {
            String cond = m.group(2).trim();
            cond = cond.replaceAll("(?i)\\band\\b", "&&");
            cond = cond.replaceAll("(?i)\\bor\\b", "||");
            cond = cond.replaceAll("(?<![=!<>])=(?!=)", "=="); // = -> ==
            // prefix field tokens with @.
            Pattern token = Pattern.compile("\\b([a-zA-Z_][\\w.]*)\\b");
            Matcher t = token.matcher(cond);
            StringBuffer condBuf = new StringBuffer();
            while (t.find()) {
                String tok = t.group(1);
                if (tok.equals("and")||tok.equals("or")||tok.equals("in")||tok.equals("true")||tok.equals("false")||tok.matches("\\d+")) {
                    t.appendReplacement(condBuf, tok);
                } else {
                    t.appendReplacement(condBuf, "@." + tok);
                }
            }
            t.appendTail(condBuf);
            String finalCond = condBuf.toString();
            String replacement = "[?(" + finalCond + ")]";
            m.appendReplacement(sb, Matcher.quoteReplacement(replacement));
        }
        m.appendTail(sb);
        s = sb.toString();

        // ensure leading $
        if (!s.startsWith("$")) {
            if (s.startsWith("[") || s.startsWith("..")) s = "$" + s;
            else s = "$." + s;
        }
        return s;
    }
}
```

---

### 3) TransformRegistry (simple)

```java
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.function.BiFunction;

public class TransformRegistry {
    private final Map<String, BiFunction<Object, Map<String,Object>, Object>> regs = new HashMap<>();

    public TransformRegistry() {
        regs.put("maskSsn", (v, ctx) -> {
            if (v==null) return "";
            String s = v.toString().replaceAll("\\D","");
            if (s.length() < 4) return "***";
            return "***-**-" + s.substring(s.length()-4);
        });
        regs.put("upper", (v, ctx) -> v==null ? "" : v.toString().toUpperCase());
        regs.put("datePart:year", (v, ctx) -> {
            if (v==null) return "";
            LocalDate d = LocalDate.parse(v.toString());
            return d.getYear();
        });
    }

    public Object apply(String descriptor, Object value, Map<String,Object> ctx) {
        if (descriptor == null) return value;
        BiFunction<Object, Map<String,Object>, Object> fn = regs.get(descriptor);
        if (fn == null) return value;
        return fn.apply(value, ctx);
    }
}
```

---

### 4) NestedRepeaterEngine — core evaluator with nested repeat support

```java
import com.jayway.jsonpath.JsonPath;
import com.jayway.jsonpath.ReadContext;
import java.util.*;

/**
 * Evaluates MappingSpec and repeaters producing flat map of logicalKey->value.
 */
public class NestedRepeaterEngine {

    private final ExpressionCompiler compiler;
    private final TransformRegistry transforms;

    public NestedRepeaterEngine(ExpressionCompiler compiler, TransformRegistry transforms) {
        this.compiler = compiler;
        this.transforms = transforms;
    }

    /**
     * Entry point.
     * source is the parsed JSON object (Map<String,Object>), e.g., from Jackson readValue into Map.
     */
    public Map<String,Object> evaluate(MappingSpec spec, Map<String,Object> source, Map<String,Object> runtime) {
        Map<String,Object> out = new LinkedHashMap<>();

        ReadContext ctx = JsonPath.parse(source);

        // simple fields
        for (Map.Entry<String, FieldDef> e : spec.fields.entrySet()) {
            String logicalKey = e.getKey();
            FieldDef fd = e.getValue();
            Object val = evalSingle(fd, ctx, source, runtime);
            if (fd.transforms != null) {
                for (String t : fd.transforms) val = transforms.apply(t, val, runtime);
            }
            out.put(logicalKey, val);
        }

        // repeaters (top-level) - recurse
        for (RepeaterDef r : spec.repeaters) {
            evaluateRepeater(r, ctx, source, runtime, out, new ArrayList<>());
        }

        return out;
    }

    /** Recurse into repeater. parentIndices holds indices of ancestor levels for key templating. */
    private void evaluateRepeater(RepeaterDef rep,
                                  ReadContext ctx,
                                  Map<String,Object> root,
                                  Map<String,Object> runtime,
                                  Map<String,Object> out,
                                  List<Integer> parentIndices) {

        // compile repeater path to JsonPath
        com.jayway.jsonpath.JsonPath compiled = compiler.compile(rep.path);

        List<Object> items;
        try {
            Object raw = ctx.read(compiled);
            if (raw instanceof List<?> l) items = (List<Object>) l;
            else if (raw == null) items = Collections.emptyList();
            else items = List.of(raw);
        } catch (Exception ex) {
            items = Collections.emptyList();
        }

        for (int i = 0; i < items.size(); i++) {
            Object item = items.get(i);
            int idxForTemplate = i + rep.indexBase; // 1-based often
            // build new parent indices list for nested templates
            List<Integer> currentIndices = new ArrayList<>(parentIndices);
            currentIndices.add(idxForTemplate);

            // create a ReadContext for the item for relative field evaluation
            ReadContext itemCtx = JsonPath.parse(item);

            // Evaluate fields for this repeater level
            for (Map.Entry<String, String> fld : rep.fields.entrySet()) {
                String pdfKeyTemplate = fld.getKey(); // e.g., "APPLICANT_{a}_NAME" or "app{0}_cov{1}_type"
                String relativePath = fld.getValue();  // e.g., "name.first" OR "coverages[?(@.type=='MED')][0].premium"
                // normalize if relativePath starts with $ -> compile directly, else compile relative by prefixing $
                com.jayway.jsonpath.JsonPath compiledPath = compiler.compile(relativePath);
                Object val;
                try {
                    // read against item if relative, else read against root
                    if (relativePath.trim().startsWith("$")) {
                        val = JsonPath.parse(root).read(compiledPath);
                    } else {
                        val = itemCtx.read(compiledPath);
                    }
                } catch (Exception ex) {
                    val = null;
                }
                // replace placeholders in key template: support {0},{1} etc or {a},{b}
                String resolvedKey = resolveKeyTemplate(pdfKeyTemplate, currentIndices);
                out.put(resolvedKey, val);
            }

            // handle nested repeaters
            if (rep.repeaters != null && !rep.repeaters.isEmpty()) {
                for (RepeaterDef child : rep.repeaters) {
                    // child paths are evaluated relative to current item; create a ctx that treats item as root
                    // create a wrapper ReadContext for child that reads from item
                    // We'll use JsonPath.parse(item) as ctx for nested levels
                    // For nested evaluation we pass a ReadContext that has item as root by temporarily swapping ctx
                    // Simpler approach: create a JsonPath.parse(item) and call evaluateRepeater with that context by constructing a small helper
                    evaluateNestedRepeater(child, item, runtime, out, currentIndices);
                }
            }
        }
    }

    /** Helper to evaluate nested repeater where rep.path is relative to given item object */
    private void evaluateNestedRepeater(RepeaterDef rep, Object itemRoot, Map<String,Object> runtime,
                                        Map<String,Object> out, List<Integer> parentIndices) {

        ReadContext itemCtx = JsonPath.parse(itemRoot);
        com.jayway.jsonpath.JsonPath compiled = compiler.compile(rep.path);
        List<Object> items;
        try {
            Object raw = itemCtx.read(compiled);
            if (raw instanceof List<?> l) items = (List<Object>) l;
            else if (raw == null) items = Collections.emptyList();
            else items = List.of(raw);
        } catch (Exception ex) {
            items = Collections.emptyList();
        }

        for (int i = 0; i < items.size(); i++) {
            Object childItem = items.get(i);
            int idx = i + rep.indexBase;
            List<Integer> curr = new ArrayList<>(parentIndices);
            curr.add(idx);

            ReadContext childCtx = JsonPath.parse(childItem);

            for (Map.Entry<String, String> fld : rep.fields.entrySet()) {
                String pdfKeyTemplate = fld.getKey();
                String relativePath = fld.getValue();
                com.jayway.jsonpath.JsonPath compiledPath = compiler.compile(relativePath);
                Object val;
                try {
                    if (relativePath.trim().startsWith("$")) {
                        val = JsonPath.parse(itemRoot).read(compiledPath); // absolute on item root
                    } else {
                        val = childCtx.read(compiledPath);
                    }
                } catch (Exception ex) {
                    val = null;
                }
                String resolvedKey = resolveKeyTemplate(pdfKeyTemplate, curr);
                out.put(resolvedKey, val);
            }

            // deeper nesting:
            if (rep.repeaters != null && !rep.repeaters.isEmpty()) {
                for (RepeaterDef deeper : rep.repeaters) {
                    evaluateNestedRepeater(deeper, childItem, runtime, out, curr);
                }
            }
        }
    }

    /** Replace {0}, {1} or {n} or %n% placeholders by values from indices list.
     *  indices: [appIdx, covIdx, feeIdx] etc
     */
    private String resolveKeyTemplate(String template, List<Integer> indices) {
        String out = template;
        // replace {0}, {1} style
        for (int i = 0; i < indices.size(); i++) {
            out = out.replace("{" + i + "}", String.valueOf(indices.get(i)));
            out = out.replace("%" + (i+1) + "%", String.valueOf(indices.get(i))); // %1% style
            out = out.replace("{n" + (i+1) + "}", String.valueOf(indices.get(i)));
        }
        // also replace generic {n} with last index
        if (template.contains("{n}")) {
            int last = indices.get(indices.size()-1);
            out = out.replace("{n}", String.valueOf(last));
        }
        return out;
    }

    private Object evalSingle(FieldDef fd, ReadContext ctx, Map<String,Object> root, Map<String,Object> runtime) {
        if (fd==null) return null;
        if (fd.path != null) {
            com.jayway.jsonpath.JsonPath compiled = compiler.compile(fd.path);
            try {
                // read from root context
                return ctx.read(compiled);
            } catch (Exception ex) {
                return null;
            }
        }
        // expr not implemented here
        return null;
    }
}
```

Notes:

* The engine compiles repeater `path`s and field relative paths with the same `ExpressionCompiler`. If a field path begins with `$` it is evaluated against the original root; otherwise against the current item.
* For nested repeaters we evaluate them relative to the current item object (`JsonPath.parse(item)`).
* The `resolveKeyTemplate` supports placeholders like `{0}`, `{1}`, `{n}`, and `%1%`. Use whichever you prefer in your YAML.

---

### 5) PdfBinder (same as before but uses logical map)

```java
public class PdfBinder {
    public Map<String,String> bind(Map<String,Object> logicalValues, MappingSpec spec) {
        Map<String,String> out = new LinkedHashMap<>();
        for (Map.Entry<String,String> e : spec.pdfFields.entrySet()) {
            String pdfFieldName = e.getKey();
            String logicalKey = e.getValue();
            Object v = logicalValues.get(logicalKey);
            out.put(pdfFieldName, v == null ? "" : v.toString());
        }
        return out;
    }
}
```

---

### 6) Example YAML (nested repeater)

Save as `mappings/template/enroll_nested.yaml`:

```yaml
template:
  id: enrol_nested
  pdf: templates/enrol_nested.pdf

fields:
  companyName:
    path: company.name

repeaters:
  - name: applicants
    path: applicants
    as: app
    indexBase: 1
    fields:
      "APPLICANT_{0}_NAME": name.full
      "APPLICANT_{0}_DOB": dob
    repeaters:
      - name: coverages
        path: coverages
        as: cov
        indexBase: 1
        fields:
          "APPLICANT_{0}_COV_{1}_TYPE": type
          "APPLICANT_{0}_COV_{1}_PREMIUM": premium
        repeaters:
          - name: dependentsWithinCoverage
            path: dependents
            as: dep
            indexBase: 1
            fields:
              "APPLICANT_{0}_COV_{1}_DEP_{2}_NAME": name.full
```

Explanation:

* Top-level `repeaters` iterates `applicants` array.
* Within each applicant, it evaluates `fields` `APPLICANT_{0}_NAME` and `APPLICANT_{0}_DOB` where `{0}` becomes the applicant index.
* Then nested `coverages` repeats within each applicant; `{1}` = coverage index.
* A deeper nested `dependents` inside coverage shows 3-level nesting. `{2}` is the dependent index inside that coverage.

---

### 7) Usage example (startup + call)

```java
// Startup: load mapping spec (from YAML into MappingSpec object)
// compile done by ExpressionCompiler when needed (you should precompile all paths during startup)

ExpressionCompiler compiler = new ExpressionCompiler();
TransformRegistry transforms = new TransformRegistry();
NestedRepeaterEngine engine = new NestedRepeaterEngine(compiler, transforms);

// parse your JSON into Map<String,Object> (e.g., with Jackson)
ObjectMapper om = new ObjectMapper();
Map<String,Object> source = om.readValue(jsonString, Map.class);

// load MappingSpec 'spec' from YAML (not shown here — use Jackson YAMLFactory or your loader)
MappingSpec spec = /* load mapping spec from file */;

// evaluate
Map<String,Object> logical = engine.evaluate(spec, source, Collections.emptyMap());

// bind to pdf map and fill pdf
PdfBinder binder = new PdfBinder();
Map<String,String> pdfMap = binder.bind(logical, spec);

// then pass pdfMap to PdfFiller that uses PDFBox to set fields
```

---

## Final notes, limitations & enhancements

1. **Performance**: You should precompile all JSONPath expressions at startup (walk `MappingSpec` & nested `RepeaterDef` fields and call `compiler.compile(...)`) so evaluation is just `compiled.read(...)`. The code above compiles on demand via `compiler.compile()` and caches compiled objects.

2. **Transforms & JSONata**: The example uses JSONPath for extraction. If you need JSONata expressions for computed fields inside repeaters, add `expr` in `FieldDef`, compile JSONata at startup, evaluate per item, and apply transforms.

3. **Key templating**: `resolveKeyTemplate()` supports a few placeholder styles. You may want to use a more robust templating engine (Mustache style) if templates get complex.

4. **Repeat selector expressions**: The `ExpressionCompiler` supports filter shorthand (e.g., `dependents[type = CHILD]`). It rewrites to JSONPath `$.dependents[?(@.type == 'CHILD')]`.

5. **Null handling**: Current implementation quietly puts `null` for missing values. You can add default transforms, `fallbackIfEmpty`, or skip keys.

6. **Maximum repeat counts**: For PDF forms with finite slots, you may want to limit expansion (e.g., only first 5 coverages). Implement `max` on repeater or stop after N iterations.

7. **Thread-safety**: `ExpressionCompiler` caches compiled paths in a `ConcurrentHashMap` — safe. `NestedRepeaterEngine` is stateless and thread-safe if `ExpressionCompiler` and `TransformRegistry` are.

8. **Unit tests**: Add tests for nested cases, filter expressions, and edge cases (empty arrays, nulls).

---

If you want I can:

* provide a **full Git repo ZIP** with these classes + sample YAML + unit tests + sample JSON, or
* implement **max limits**, **skip/limit/offset** controls in repeater defs, or
* add **JSONata** support inside repeaters (compile & evaluate) — including sample expressions.

Which would you prefer next?
