Great question â€” and this is one of the **most important architectural decisions** in a multi-template mapping system.

Below is the **clear reasoning** behind the rule:

> **Only the final template YAML contains PDF field names, while base/product/market/state YAMLs contain only logical-data fields (JSONata/lookup/transform expressions).**

---

# âœ… **THE CORE PRINCIPLE**

## **PDF form fields belong to *templates*, not to business logic.**

Because:

* Logical (semantic) fields = business meaning (first name, plan name, SSN)
* PDF fields = UI/structural details (SUB_FNAME, DEP_2_DOB)

These two SHOULD NOT be mixed because they change independently.

---

# ğŸ”¥ **TOP REASONS â€” WHY PDF FIELDS SHOULD BE ONLY IN THE FINAL TEMPLATE FILE**

---

# 1ï¸âƒ£ **PDF fields change per template â€” business logic does not**

Example:

Template A (CA):

```
SUB_FNAME
SUB_LNAME
```

Template B (NY):

```
SUBSCRIBER_FIRST
SUBSCRIBER_LAST
```

Template C (old version):

```
FIRST_NAME
LAST_NAME
```

BUT the semantic field **subscriberFirstName** has the same meaning everywhere.

ğŸ‘‰ Therefore, **business logic â€œfollows the domainâ€**
ğŸ‘‰ While **PDF field names follow each templateâ€™s layout**

Mixing them forces duplication.

---

# 2ï¸âƒ£ **Avoid duplication across 20, 50, or 100 templates**

If you put PDF field names in:

* base.yaml
* medical.yaml
* market.yaml
* state.yaml

You would end up with **dozens of copies** of the same PDF fields because each template has a completely different PDF layout.

Instead:

### âœ” Business logic (JSONata) lives once

### âœ” PDF mapping lives once per template

### âœ” Both merge cleanly at runtime

---

# 3ï¸âƒ£ **Keeps business rules independent of presentation**

Business logic:

```
subscriberFirstName = subscriber.name.first
```

PDF form:

```
voice-only physical location field is "BX1023"
```

These have zero conceptual intersection.

Separation of concerns results in:

* simpler maintenance
* easier unit testing
* reusable rules across templates
* easier review/approval by non-technical domain SMEs
* safer evolution when templates change

---

# 4ï¸âƒ£ **State- and market-specific rules should NOT depend on PDF layout**

Example California rule:

```
tobaccoAttestation = ca.tobaccoAttestation
```

This rule is true for all CA medical templates regardless of which version of the PDF the state releases.

If the PDF changes:

* Only the template YAML changes
* The state/business logic YAML remains untouched

---

# 5ï¸âƒ£ **Supports dynamic template selection**

Your engine might choose template based on:

* state = CA
* market = INDIVIDUAL
* product = MEDICAL
* templateVersion = 2025 (new layout)

If PDF fields were mixed into business logic:

âŒ Every time the template changes, you would need to modify business logic files
âŒ You might break mappings for other templates
âŒ It becomes impossible to keep versions clean

Instead:

### All variation is contained inside ONE template file:

```
templates/medical_individual_CA_template_v2025.yaml
```

---

# 6ï¸âƒ£ **Makes unit testing vastly simpler**

You want to unit test:

### **Business rule:**

```
subscriberFirstName = subscriber.name.first
```

Unit test:

* Provide a JSON input
* Evaluate JSONata
* Assert string value

Zero PDF knowledge needed.

### **Template mapping test:**

Provide resolved values -> test it fills the PDF correctly.

---

# 7ï¸âƒ£ **Supports template evolution without breaking business logic**

PDF layouts change every year:

* Field names change
* Form structure changes
* New checkboxes appear
* Sections move
* Groups or states release new versions

But your base/market/state rules rarely change.

So:

### Template YAML is versioned per PDF

### Business logic YAML remains stable

---

# 8ï¸âƒ£ **Clean layering enables automation**

If the layers are clean:

* You can auto-generate a PDF mapping skeleton by scanning the template
* You can automatically validate that all logical fields are mapped
* You can detect unused/unmapped PDF fields
* You can programmatically build max dependents = N lists

Separation simplifies automation tremendously.

---

# 9ï¸âƒ£ **PDF field names are not reusable; business logic is**

### Business logic IS reusable:

* subscriberâ€™s DOB: always `subscriber.dob`
* masked SSN: always `maskSSN(subscriber.ssn)`
* dependent DOBs: always `dependents[].dob`

### PDF field names are NOT reusable:

Every PDF uses different naming patterns.

So PDF mapping must be template-local.

---

# ğŸ”š **Conclusion â€” Why Only Template YAML Keeps PDF field names**

### âœ” Because PDF is a presentation layer

### âœ” Business logic is domain logic

### âœ” Templates vary wildly while business rules do not

### âœ” Reduces duplication to near zero

### âœ” Keeps merging clean

### âœ” Allows dynamic template selection

### âœ” Enables versioning per template

### âœ” State/market/product rules donâ€™t change when PDF changes

This is the most maintainable and scalable architecture for large enterprises with dozens of PDF templates.

---

# Want a diagram of the merging engine?

I can generate a full visual flow of:

```
base â†’ product â†’ market â†’ state â†’ template
```

Or I can show the **full Java implementation** of the merge + evaluator + PDF filler.

Just tell me.
