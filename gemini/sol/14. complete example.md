Great ‚Äî here is a **complete, production-quality example** of a **full hierarchical mapping system** for medical enrollment PDFs across:

* ‚úî multiple product types
* ‚úî multiple market categories
* ‚úî multiple states
* ‚úî multiple templates

This shows the **full ‚Äúbase ‚Üí product ‚Üí market ‚Üí state ‚Üí template-specific‚Äù** design.

Each layer is small, clean, reusable, and zero-duplication.

---

# üß± **Folder Structure**

```
mappings/
   common/
      base.yaml
   product/
      medical.yaml
   market/
      individual.yaml
      group.yaml
   state/
      CA.yaml
      NY.yaml
   templates/
      medical_individual_CA_template1.yaml
```

Now let's walk through each file.

---

# 1Ô∏è‚É£ **common/base.yaml**

‚û° Defines fields common to *all* enrollment templates
‚û° No PDF fields yet ‚Äî only logical field definitions

```yaml
fields:

  # Subscriber (common to all markets/products/states)
  subscriberFirstName:
    jsonata: "subscriber.name.first"

  subscriberLastName:
    jsonata: "subscriber.name.last"

  subscriberDOB:
    jsonata: "subscriber.dob"

  subscriberSSN:
    jsonata: "maskSSN(subscriber.ssn)"

  subscriberGender:
    jsonata: "subscriber.gender"

  subscriberPhone:
    jsonata: "contacts.phone"

  subscriberEmail:
    jsonata: "contacts.email"

  addressLine1:
    jsonata: "address.line1"

  addressLine2:
    jsonata: "address.line2"

  city:
    jsonata: "address.city"

  state:
    jsonata: "address.state"

  zip:
    jsonata: "address.zip"

  # Dependents ‚Äî dynamic list but not tied to PDF fields yet
  eligibleDependents:
    jsonata: "$filter(dependents, function($d){$d.type in ['CHILD','SPOUSE','DOMESTIC_PARTNER']})"
    dynamic: true
```

---

# 2Ô∏è‚É£ **product/medical.yaml**

‚û° Adds fields unique to medical product
‚û° These merge on top of base.yaml

```yaml
fields:

  planName:
    jsonata: "coverage.planName"

  planType:
    jsonata: "coverage.planType"

  primaryCarePhysician:
    jsonata: "coverage.pcpName"

  planStartDate:
    jsonata: "formatDate(coverage.startDate)"
```

---

# 3Ô∏è‚É£ **market/individual.yaml**

‚û° Overrides or adds fields for individual market

```yaml
fields:

  marketCategory:
    jsonata: "'INDIVIDUAL'"

  subsidyAmount:
    jsonata: "financials.subsidyAmount"

  marketplaceIdentifier:
    jsonata: "marketplace.id"
```

---

# 4Ô∏è‚É£ **state/CA.yaml**

‚û° Overrides or adds California-specific rules

```yaml
fields:

  # CA has special tobacco fields
  tobaccoAttestation:
    jsonata: "ca.tobaccoAttestation"

  # Special CA pediatric vision inclusion
  pediatricVisionIncluded:
    jsonata: "benefits.pediatricVisionIncluded"
```

---

# 5Ô∏è‚É£ **templates/medical_individual_CA_template1.yaml**

‚û° ONLY AcroForm field names
‚û° No JSONata logic
‚û° Only overrides where needed
‚û° Also binds dynamic dependents

```yaml
template:
  file: "medical-individual-ca-v1.pdf"
  location: "classpath:templates/"

# Map logical field ‚Üí PDF form field name
fieldMapping:

  subscriberFirstName: "SUB_FNAME"
  subscriberLastName: "SUB_LNAME"
  subscriberDOB: "SUB_DOB"
  subscriberSSN: "SUB_SSN"
  subscriberGender: "SUB_GENDER"
  subscriberPhone: "SUB_PHONE"
  subscriberEmail: "SUB_EMAIL"

  addressLine1: "ADDR_LINE1"
  addressLine2: "ADDR_LINE2"
  city: "CITY"
  state: "STATE"
  zip: "ZIP"

  planName: "PLAN_NAME"
  planType: "PLAN_TYPE"
  planStartDate: "PLAN_START"

  marketCategory: "MARKET_CATEGORY"
  subsidyAmount: "SUBSIDY"
  marketplaceIdentifier: "MARKETPLACE_ID"

  tobaccoAttestation: "TOB_ATTEST"
  pediatricVisionIncluded: "PEDIATRIC_VISION"

# Dynamic dependent binding
dependents:
  source: "eligibleDependents"

  repeat:
    max: 5      # PDF supports up to five dependents
    fields:
      firstName: "DEP_%n%_FNAME"
      lastName:  "DEP_%n%_LNAME"
      dob:       "DEP_%n%_DOB"
      gender:    "DEP_%n%_GENDER"
      relationship: "DEP_%n%_REL"
```

Notice:

* `%n%` is replaced by (1,2,3,‚Ä¶) by Java engine
* You only define it once
* You do **not** duplicate fields for dependent1, dependent2, dependent3, etc.

---

# üß† **What Does the Mapping Engine Now Do?**

When a request arrives:

Market = INDIVIDUAL
Product = MEDICAL
State = CA
Template = template1

The engine merges:

```
base.yaml
+ medical.yaml
+ individual.yaml
+ CA.yaml
+ template1.yaml
= finalMergedMapping
```

Final output is a single, flattened mapping:

* All JSONata expressions
* All PDF field names
* All dynamic dependent rules

Zero duplication.

---

# üìù **High-Level View of Final Merged Mapping**

The merged output (generated dynamically in Java) looks like:

```yaml
subscriberFirstName:
  expr: subscriber.name.first
  pdf: SUB_FNAME

subscriberLastName:
  expr: subscriber.name.last
  pdf: SUB_LNAME

planName:
  expr: coverage.planName
  pdf: PLAN_NAME

marketCategory:
  expr: "'INDIVIDUAL'"
  pdf: MARKET_CATEGORY

tobaccoAttestation:
  expr: ca.tobaccoAttestation
  pdf: TOB_ATTEST

# and dependents become:

dependent1FirstName ‚Üí DEP_1_FNAME
dependent1LastName  ‚Üí DEP_1_LNAME
dependent2FirstName ‚Üí DEP_2_FNAME
dependent2LastName  ‚Üí DEP_2_LNAME
...
up to max: 5
```

---

# üöÄ **Why This Works Exceptionally Well**

### ‚úî Zero duplication across templates

### ‚úî Clean separation of concerns

### ‚úî Easy onboarding for new templates

### ‚úî Only local overrides change

### ‚úî JSONata/JSONPath expressions 100% reusable

### ‚úî Templates only specify PDF field names

### ‚úî Dependents remain dynamic and elegant

### ‚úî Scaling to 50+ templates is easy

---

# üéÅ I can also provide:

### üîπ the **Java merging engine**

### üîπ the **full JSONata evaluator integration**

### üîπ dependency injection pattern for transforms (`maskSSN`, `formatDate`)

### üîπ a **validation engine** for YAML

### üîπ an example **unit test suite**

### üîπ runtime **template-selection logic (market/product/state)**

Just tell me what you'd like next.
