Perfect ‚Äî this is a key architectural piece of your PDF generation service.
Let‚Äôs design a reusable, pluggable ‚ÄúMapping Engine‚Äù that reads mapping configurations (YAML or JSON), evaluates JSONata expressions on the source JSON, and produces a ready-to-use map of {pdfFieldName ‚Üí value}.


---

üß© Overall Architecture

+--------------------+
| MappingConfig.yaml |
+---------+----------+
          |
          v
+-------------------------+
| MappingEngine           |
|  - loads config (YAML)  |
|  - evaluates JSONata    |
|  - returns Map<String,String> |
+-------------------------+
          |
          v
+-------------------------+
| PDFMergeService         |
|  - receives field map   |
|  - fills PDF template   |
+-------------------------+


---

‚öôÔ∏è Example Mapping Configuration (YAML)

template: invoice_form.pdf
fields:
  customer_name: "$customer.firstName & ' ' & $customer.lastName"
  city: "$customer.address.city"
  order_id: "$order.id"
  total_amount: "$string($order.total) & ' INR'"
  category: "($order.total > 1000) ? 'Premium' : 'Standard'"

This can also be stored in JSON format if you prefer, but YAML is cleaner for configuration files.


---

üß† Core Concepts

The Mapping Engine should:

1. Parse YAML ‚Üí Java object (MappingConfig)


2. Parse source JSON ‚Üí JsonNode


3. For each fields entry:

Evaluate JSONata expression against JSON

Store result in map



4. Return final map of {pdfField ‚Üí value}




---

üß± Implementation

1Ô∏è‚É£ The MappingConfig Model

package com.example.pdfmapper.model;

import java.util.Map;

public class MappingConfig {
    private String template;
    private Map<String, String> fields;

    public String getTemplate() {
        return template;
    }

    public void setTemplate(String template) {
        this.template = template;
    }

    public Map<String, String> getFields() {
        return fields;
    }

    public void setFields(Map<String, String> fields) {
        this.fields = fields;
    }
}


---

2Ô∏è‚É£ YAML Loader Utility

Use SnakeYAML to load YAML mapping configuration.

package com.example.pdfmapper.util;

import com.example.pdfmapper.model.MappingConfig;
import org.yaml.snakeyaml.Yaml;

import java.io.InputStream;

public class YamlConfigLoader {

    public static MappingConfig loadConfig(InputStream yamlStream) {
        Yaml yaml = new Yaml();
        return yaml.loadAs(yamlStream, MappingConfig.class);
    }
}


---

3Ô∏è‚É£ JSONata Evaluation Helper

package com.example.pdfmapper.engine;

import com.api.jsonata4java.expressions.Expressions;
import com.api.jsonata4java.expressions.utils.JsonUtils;
import com.fasterxml.jackson.databind.JsonNode;

public class JsonataEvaluator {

    public static String evaluate(JsonNode jsonNode, String expression) {
        try {
            Expressions expr = Expressions.parse(expression);
            var result = expr.evaluate(jsonNode);
            return result != null ? result.toString() : "";
        } catch (Exception e) {
            // Optional: log or rethrow with context
            return "";
        }
    }
}


---

4Ô∏è‚É£ The Core MappingEngine

package com.example.pdfmapper.engine;

import com.example.pdfmapper.model.MappingConfig;
import com.fasterxml.jackson.databind.JsonNode;
import com.api.jsonata4java.expressions.utils.JsonUtils;

import java.util.HashMap;
import java.util.Map;

public class MappingEngine {

    public Map<String, String> transform(String sourceJson, MappingConfig config) {
        Map<String, String> result = new HashMap<>();

        try {
            JsonNode jsonNode = JsonUtils.jsonToNode(sourceJson);

            for (Map.Entry<String, String> entry : config.getFields().entrySet()) {
                String fieldName = entry.getKey();
                String expression = entry.getValue();
                String value = JsonataEvaluator.evaluate(jsonNode, expression);
                result.put(fieldName, value);
            }

        } catch (Exception e) {
            throw new RuntimeException("Error during mapping transformation", e);
        }

        return result;
    }
}


---

5Ô∏è‚É£ Putting It Together (Usage Example)

package com.example.pdfmapper;

import com.example.pdfmapper.engine.MappingEngine;
import com.example.pdfmapper.model.MappingConfig;
import com.example.pdfmapper.util.YamlConfigLoader;

import java.io.FileInputStream;
import java.util.Map;

public class MappingEngineDemo {
    public static void main(String[] args) throws Exception {

        // 1. Load mapping spec (YAML)
        try (FileInputStream fis = new FileInputStream("config/mapping.yaml")) {
            MappingConfig config = YamlConfigLoader.loadConfig(fis);

            // 2. Source JSON
            String json = """
            {
              "customer": {"firstName": "Sridhar", "lastName": "Balasubramanian", "address": {"city": "Chennai"}},
              "order": {"id": "ORD-9876", "total": 2500}
            }
            """;

            // 3. Transform using mapping engine
            MappingEngine engine = new MappingEngine();
            Map<String, String> fieldMap = engine.transform(json, config);

            // 4. Print field map (ready for PDF filling)
            fieldMap.forEach((k, v) -> System.out.println(k + " = " + v));
        }
    }
}

Output:

customer_name = Sridhar Balasubramanian
city = Chennai
order_id = ORD-9876
total_amount = 2500 INR
category = Premium


---

üß∞ Optional Enhancements

You can make the MappingEngine more powerful:

Feature	Implementation

Expression Caching	Cache parsed Expressions objects to avoid reparsing the same JSONata string repeatedly.
Custom Functions	Extend JSONata with your own $functions (jsonata4java supports this).
Validation	Validate YAML structure and field expressions during service startup.
Nested Mapping	Allow nested YAML structures and flatten them dynamically.
Error Reporting	Collect evaluation errors with field context.



---

‚úÖ Summary

This reusable MappingEngine gives you:

Decoupled configuration: mapping specs are outside code (YAML)

Flexible transformations via JSONata

Simple integration into your PDF filling logic:

Map<String, String> pdfFields = mappingEngine.transform(json, config);
pdfService.fillTemplate(config.getTemplate(), pdfFields);



---

Would you like me to extend this with support for registering custom JSONata functions (e.g., $toUpper(), $formatDate(), $currency()) so that your mapping specs can use more domain-friendly expressions?