Absolutely! Letâ€™s **enhance your field mapping implementation** with full **conditional mapping support**, plus related features like **default values**, **skip-null behavior**, and **graceful error handling**.

Weâ€™ll evolve the solution in a clean, maintainable way.

---

## âœ… Step 1: Update YAML Schema (Now with Conditions & Defaults)

### `mapping-config.yaml`
```yaml
mappings:
  - source: "user.phone"
    target: "phoneField"
    condition:
      type: "notNull"
    default: "Not provided"

  - source: "order.total"
    target: "premiumBadge"
    condition:
      type: "greaterThan"
      value: 1000
    transform: "showPremium"

  - source: "internal.notes"
    target: "adminNotes"
    condition:
      type: "envVar"
      name: "SHOW_INTERNAL"
      expected: "true"

  - source: "user.country"
    target: "regionLabel"
    condition:
      type: "equals"
      field: "user.region"     # compare against another field
      value: "EU"
    transform: "toUpperCase"

  - source: "user.name"
    target: "fullName"
    # No condition â†’ always mapped
    # No default â†’ uses raw value (or empty if null)
```

> âœ¨ **New features**:
> - `condition` block (optional)
> - `default` fallback (optional)
> - `expected` in envVar (cleaner than `value`)

---

## ğŸ”§ Step 2: Update Java Model Classes

### `FieldMapping.java` (enhanced)
```java
public class FieldMapping {
    private String source;
    private String target;
    private Object transform;
    private Condition condition;   // â† new
    private String defaultValue;   // â† new: fallback if value is null/empty

    // Getters
    public String getSource() { return source; }
    public String getTarget() { return target; }
    public Object getTransform() { return transform; }
    public Condition getCondition() { return condition; }
    public String getDefaultValue() { return defaultValue; }
}
```

### `Condition.java`
```java
import java.util.List;

public class Condition {
    private String type;           // e.g., "notNull", "equals", "greaterThan", "envVar"
    private String field;          // optional: another JSON path to compare
    private Object value;          // expected value (for equals, greaterThan, etc.)
    private String name;           // for envVar/flag
    private String expected;       // alias for 'value' in env context (more readable)
    private List<Condition> and;   // for compound: and: [cond1, cond2]
    private List<Condition> or;    // for compound: or: [cond1, cond2]

    // Helpers
    public Object getEffectiveValue() {
        return expected != null ? expected : value;
    }

    // Getters
    public String getType() { return type; }
    public String getField() { return field; }
    public Object getValue() { return value; }
    public String getName() { return name; }
    public String getExpected() { return expected; }
    public List<Condition> getAnd() { return and; }
    public List<Condition> getOr() { return or; }
}
```

---

## âš™ï¸ Step 3: Enhanced Condition Evaluator

### `ConditionEvaluator.java`
```java
import com.jayway.jsonpath.DocumentContext;
import java.util.*;

public class ConditionEvaluator {

    public static boolean evaluate(Condition cond, DocumentContext json, Object sourceValue) {
        if (cond == null) return true;

        // Handle compound conditions first
        if (cond.getAnd() != null && !cond.getAnd().isEmpty()) {
            return cond.getAnd().stream()
                .allMatch(c -> evaluate(c, json, resolveValueForCondition(c, json, sourceValue)));
        }
        if (cond.getOr() != null && !cond.getOr().isEmpty()) {
            return cond.getOr().stream()
                .anyMatch(c -> evaluate(c, json, resolveValueForCondition(c, json, sourceValue)));
        }

        // Simple conditions
        switch (cond.getType()) {
            case "notNull":
                return sourceValue != null && !"".equals(sourceValue.toString().trim());

            case "equals":
                Object compareValue = cond.getField() != null 
                    ? json.read("$." + cond.getField()) 
                    : sourceValue;
                return Objects.equals(compareValue, cond.getEffectiveValue());

            case "notEquals":
                Object neValue = cond.getField() != null 
                    ? json.read("$." + cond.getField()) 
                    : sourceValue;
                return !Objects.equals(neValue, cond.getEffectiveValue());

            case "greaterThan":
                return compareNumeric(sourceValue, cond.getEffectiveValue(), (a, b) -> a > b);

            case "lessThan":
                return compareNumeric(sourceValue, cond.getEffectiveValue(), (a, b) -> a < b);

            case "envVar":
                String actual = System.getenv(cond.getName());
                return Objects.equals(actual, cond.getEffectiveValue());

            case "property": // system property
                String prop = System.getProperty(cond.getName());
                return Objects.equals(prop, cond.getEffectiveValue());

            default:
                throw new IllegalArgumentException("Unsupported condition type: " + cond.getType());
        }
    }

    private static Object resolveValueForCondition(Condition c, DocumentContext json, Object fallback) {
        if (c.getField() != null) {
            return json.read("$." + c.getField());
        }
        return fallback;
    }

    private static boolean compareNumeric(Object actual, Object expected, java.util.function.BiFunction<Double, Double, Boolean> op) {
        try {
            double a = toDouble(actual);
            double b = toDouble(expected);
            return op.apply(a, b);
        } catch (Exception e) {
            return false;
        }
    }

    private static double toDouble(Object obj) {
        if (obj instanceof Number) return ((Number) obj).doubleValue();
        if (obj instanceof String) return Double.parseDouble((String) obj);
        throw new NumberFormatException("Cannot convert " + obj + " to number");
    }
}
```

---

## ğŸ”„ Step 4: Update the Mapping Engine

### Enhanced `PdfFieldMapper.java`
```java
public class PdfFieldMapper {

    public void mapJsonToPdf(String yamlConfigPath, String jsonInput, String pdfTemplatePath, String outputPath) 
            throws Exception {
        
        // Load config
        Yaml yaml = new Yaml(new Constructor(MappingConfig.class));
        try (InputStream in = new FileInputStream(yamlConfigPath)) {
            MappingConfig config = yaml.load(in);
            DocumentContext jsonContext = JsonPath.parse(jsonInput);

            try (PDDocument document = PDDocument.load(new FileInputStream(pdfTemplatePath))) {
                PDAcroForm form = document.getDocumentCatalog().getAcroForm();
                if (form == null) {
                    throw new IllegalStateException("PDF has no fillable form");
                }

                for (FieldMapping mapping : config.getMappings()) {
                    // 1. Read source value
                    Object rawValue = null;
                    try {
                        rawValue = jsonContext.read("$." + mapping.getSource());
                    } catch (Exception e) {
                        // Field not found â†’ treat as null
                        rawValue = null;
                    }

                    // 2. Evaluate condition
                    if (!ConditionEvaluator.evaluate(mapping.getCondition(), jsonContext, rawValue)) {
                        System.out.println("â­ï¸ Skipped: " + mapping.getTarget() + " (condition failed)");
                        continue;
                    }

                    // 3. Apply transform
                    Object transformed = DataTransformer.applyTransform(rawValue, mapping.getTransform());

                    // 4. Handle null/empty with default
                    String finalValue = "";
                    if (transformed != null) {
                        finalValue = transformed.toString();
                    }
                    if (finalValue == null || finalValue.trim().isEmpty()) {
                        finalValue = mapping.getDefaultValue() != null ? mapping.getDefaultValue() : "";
                    }

                    // 5. Set in PDF
                    PDField field = form.getField(mapping.getTarget());
                    if (field != null) {
                        field.setValue(finalValue);
                        System.out.println("âœ… Set: " + mapping.getTarget() + " = '" + finalValue + "'");
                    } else {
                        System.err.println("âš ï¸ Warning: PDF field not found: " + mapping.getTarget());
                    }
                }

                document.save(outputPath);
            }
        }
    }
}
```

---

## ğŸŒŸ Related Features You Now Have

| Feature | Description | YAML Example |
|-------|------------|-------------|
| âœ… **Conditional Mapping** | Skip mapping unless condition met | `condition: { type: "notNull" }` |
| âœ… **Default Values** | Fallback if result is null/empty | `default: "N/A"` |
| âœ… **Field-to-Field Compare** | Compare `source` vs another field | `field: "user.region"` |
| âœ… **Env/System Toggles** | Enable fields via env var or sys prop | `type: "envVar", name: "DEBUG"` |
| âœ… **Numeric Conditions** | `greaterThan`, `lessThan` | `value: 1000` |
| âœ… **Null Safety** | Gracefully handles missing JSON paths |
| âœ… **Logging** | See whatâ€™s mapped/skipped |

---

## ğŸ§ª Test It: Example Condition + Default

### JSON Input
```json
{
  "user": {
    "name": "Sam",
    "phone": null,
    "region": "EU",
    "country": "France"
  },
  "order": {
    "total": 1500
  }
}
```

### Expected PDF Behavior
- `phoneField` â†’ `"Not provided"` (because `phone` is null, but `notNull` fails â†’ wait! âŒ)

> âš ï¸ **Wait!** There's a nuance.

If you use:
```yaml
condition:
  type: "notNull"
default: "Not provided"
```

Then:
- When `phone` is **null** â†’ condition **fails** â†’ mapping **skipped** â†’ default **never used**.

### ğŸ” Fix: Change Your Intent

#### Option A: **Always map, but use default if null**
â†’ **Remove condition**, just use `default`.

```yaml
- source: "user.phone"
  target: "phoneField"
  default: "Not provided"
```

#### Option B: **Only show field if value exists**
â†’ Keep condition, **no default**.

```yaml
- source: "user.phone"
  target: "phoneField"
  condition:
    type: "notNull"
```

> âœ… **Best Practice**: Use `default` for fallbacks, `condition` for inclusion logic â€” not both for the same null-handling.

---

## ğŸš€ Bonus: Compound Conditions (AND / OR)

### Example: Only show badge if **VIP AND** order > $500
```yaml
- source: "order.id"
  target: "vipBadge"
  condition:
    and:
      - type: "equals"
        field: "user.tier"
        value: "VIP"
      - type: "greaterThan"
        field: "order.total"
        value: 500
  transform: "showVip"
```

Our `ConditionEvaluator` already supports this!

---

## ğŸ“¦ Final Project Structure

```
src/
â”œâ”€â”€ model/
â”‚   â”œâ”€â”€ MappingConfig.java
â”‚   â”œâ”€â”€ FieldMapping.java
â”‚   â””â”€â”€ Condition.java
â”œâ”€â”€ engine/
â”‚   â”œâ”€â”€ DataTransformer.java
â”‚   â”œâ”€â”€ ConditionEvaluator.java
â”‚   â””â”€â”€ PdfFieldMapper.java
â””â”€â”€ Main.java
```

---

## âœ… Summary

You now have a **production-ready, flexible mapping engine** with:

- âœ… **Conditional field mapping**
- âœ… **Default value fallbacks**
- âœ… **Environment-aware toggles**
- âœ… **Numeric & string comparisons**
- âœ… **Compound conditions (AND/OR)**
- âœ… **Safe JSON path access**
- âœ… **PDF form filling**

---

Would you like:
- A **complete GitHub-ready zip** of this code?
- Support for **custom condition types** (via SPI)?
- **Validation mode** (check config without filling PDF)?
- **Dry-run logging** (preview what would be set)?

Just ask â€” Iâ€™m happy to help you take it further! ğŸ› ï¸