Excellent observation! You're absolutely right to question this â€” **consistency in syntax** is crucial for maintainability and usability.

The **best approach** is to **keep the same `source`/`target` syntax** for **both scalar and collection mappings**, just like your original design. The `fields` map I showed earlier was just one option â€” but **not the most consistent**.

Letâ€™s fix this and show you the **clean, unified syntax** that works for **all cases**.

---

## âœ… Recommended Unified Syntax

### Keep your original `source`/`target` structure â€” even for collections

```yaml
contexts:
  primary:
    from: applicants
    filter: { type: PRIMARY }
    first: true
  dependents:
    from: applicants
    filter: { type: DEPENDENT }

mappings:
  # Scalar (single applicant)
  - source: primary.demographics.firstName
    target: "primary_firstName"

  # Collection (multiple dependents)
  - collection:
      source: dependents                  # â† reference context name
      maxItems: 5
      itemMappings:
        - source: demographics.firstName  # â† relative to each item
          target: "dep_{index}_firstName" # â† target with placeholder
        - source: demographics.dob
          target: "dep_{index}_dob"
```

> âœ… **Same `source`/`target` pattern** â€” just wrapped in `itemMappings` for collections.

This is **100% consistent** with your original design and the generic engine we built.

---

## ğŸ”§ Why This Is Better

| Aspect | Unified Syntax | `fields` Map Alternative |
|-------|----------------|--------------------------|
| **Consistency** | âœ… Same `source`/`target` everywhere | âŒ Different structure for collections |
| **Features** | âœ… Supports `transform`, `condition`, `default` per field | âŒ Hard to add per-field logic |
| **Readability** | âœ… Clear, explicit mapping per field | âŒ Concise but limited |
| **Extensibility** | âœ… Easy to add new features (e.g., `required`) | âŒ Requires schema changes |
| **Learning curve** | âœ… One pattern to learn | âŒ Two patterns to remember |

---

## ğŸ§ª Real-World Example (Full Consistency)

```yaml
contexts:
  primary:
    from: applicants
    filter: { type: PRIMARY }
    first: true
  spouse:
    from: applicants
    filter: { type: SPOUSE }
    first: true
  dependents:
    from: applicants
    filter: { type: DEPENDENT }

mappings:
  # === PRIMARY (scalar) ===
  - source: primary.demographics.firstName
    target: primary_firstName
    transform: toUpperCase

  - source: primary.demographics.dob
    target: primary_dob
    transform:
      name: formatDate
      args: { pattern: "MM/dd/yyyy" }

  # === SPOUSE (scalar) ===
  - source: spouse.demographics.lastName
    target: spouse_lastName

  # === DEPENDENTS (collection) ===
  - collection:
      source: dependents
      maxItems: 5
      itemMappings:
        - source: demographics.firstName
          target: "dep_{index}_firstName"
          condition:
            type: notNull

        - source: demographics.dob
          target: "dep_{index}_dob"
          transform:
            name: formatDate
            args: { pattern: "yyyy-MM-dd" }

        - source: currentCoverages[?(@.isActive == true)][0].medical.planName
          target: "dep_{index}_medical_plan"
          default: "Not covered"
```

> ğŸ”‘ **Key insight**:  
> - **Scalar**: `source` is **absolute path** (`primary.demographics.firstName`)  
> - **Collection item**: `source` is **relative path** (`demographics.firstName`) â€” evaluated against each item in the list

---

## âš™ï¸ How the Engine Handles This

Your existing `processCollection` method **already supports this**:

```java
// In processCollection()
for (ItemFieldMapping itemMap : coll.getItemMappings()) {
    // itemMap.getSource() is RELATIVE to the current item
    Object rawValue = JsonPath.parse(currentItem).read(itemMap.getSource());
    // ... rest unchanged
}
```

And for scalar mappings:
```java
// In processScalar()
Object rawValue = resolveValue(mapping.getSource(), rootJson, contextCache);
// resolveValue handles "primary.demographics.firstName" â†’ looks up "primary" context
```

> âœ… **No changes needed** to your Java engine â€” it already works this way!

---

## ğŸ“Œ Best Practices for Unified Syntax

1. **Always use `itemMappings` for collections**  
   Never mix `fields` map and `itemMappings`

2. **Use consistent placeholder syntax**  
   `_{index}_` is clear (you could also use `${index}`)

3. **Keep source paths simple in collections**  
   Since theyâ€™re relative to the item, no need to repeat `dependents[0].`

4. **Leverage all scalar features in collections**  
   `transform`, `condition`, `default` work identically

---

## ğŸš« What to Avoid

### âŒ Inconsistent syntax
```yaml
# BAD: Mixing styles
mappings:
  - source: primary.name
    target: primary_name

  - collection:
      source: dependents
      fields:                     # â† Don't do this
        name: "dep_{index}_name"
```

### âœ… Consistent syntax
```yaml
# GOOD: Same pattern everywhere
mappings:
  - source: primary.name
    target: primary_name

  - collection:
      source: dependents
      itemMappings:               # â† Always use this
        - source: name
          target: "dep_{index}_name"
```

---

## âœ… Summary

| Your Question | Answer |
|--------------|--------|
| **Should collection syntax differ?** | âŒ **No** â€” keep it **consistent** |
| **Can we use same `source`/`target`?** | âœ… **Yes** â€” and you **already do** |
| **Is `itemMappings` better than `fields`?** | âœ… **Yes** â€” more powerful and consistent |
| **Does engine support this?** | âœ… **Yes** â€” no changes needed |

Stick with your original, clean design â€” itâ€™s **the right approach**.

Would you like:
- A **style guide** for your YAML configs?
- **Validation rules** to enforce consistent syntax?
- A **config linter** to catch inconsistencies?

Iâ€™d be happy to help you lock this in! ğŸ› ï¸âœ¨