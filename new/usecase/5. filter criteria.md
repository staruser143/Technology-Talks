**Yes ‚Äî absolutely!** Your clean `filter` syntax can support **multiple conditions** with **any data type** (string, number, boolean), and even **complex operators** like `>`, `<`, `!=`, etc.

Let‚Äôs enhance the `filter` design to be **powerful yet intuitive**.

---

## ‚úÖ 1. Basic Multi-Condition Filters (AND logic)

### YAML Syntax
```yaml
contexts:
  primaryAdult:
    from: applicants
    filter:
      type: PRIMARY          # string equality
      isActive: true         # boolean
      age: 18                # number equality
    first: true
```

> ‚úÖ **All conditions are ANDed** (like JsonPath: `[?(@.type=='PRIMARY' && @.isActive==true && @.age==18)]`)

### Generated JsonPath:
```jsonpath
$.applicants[?(@.type == "PRIMARY" && @.isActive == true && @.age == 18)][0]
```

---

## ‚úÖ 2. Support for Comparison Operators

For **non-equality** conditions (e.g., `age > 18`), use **operator syntax**:

### YAML Syntax
```yaml
contexts:
  primaryOver18:
    from: applicants
    filter:
      type: PRIMARY
      age: 
        gt: 18               # greater than
    first: true

  highValueApplicants:
    from: applicants
    filter:
      totalClaims:
        gte: 1000            # greater than or equal
      riskScore:
        lt: 5.0              # less than
```

### Supported Operators:
| Operator | YAML Key | Example |
|---------|---------|--------|
| `>` | `gt` | `age: { gt: 18 }` |
| `>=` | `gte` | `score: { gte: 90 }` |
| `<` | `lt` | `priority: { lt: 5 }` |
| `<=` | `lte` | `discount: { lte: 0.5 }` |
| `!=` | `ne` | `status: { ne: "INACTIVE" }` |
| `in` | `in` | `tier: { in: ["GOLD", "PLATINUM"] }` |

### Generated JsonPath:
```jsonpath
$.applicants[?(@.type == "PRIMARY" && @.age > 18)][0]
$.applicants[?(@.totalClaims >= 1000 && @.riskScore < 5.0)]
```

---

## ‚úÖ 3. OR Conditions (Advanced)

For **OR logic**, use `or` block:

```yaml
contexts:
  vipOrStaff:
    from: applicants
    filter:
      or:
        - tier: VIP
        - role: STAFF
```

### Generated JsonPath:
```jsonpath
$.applicants[?(@.tier == "VIP" || @.role == "STAFF")]
```

> üîÅ **Recursive**: `or` blocks can contain complex conditions too.

---

## ‚öôÔ∏è Step 1: Update Model to Support Rich Filters

### `FilterCondition.java` (new)
```java
public class FilterCondition {
    // For simple equality
    private Object value;

    // For comparisons
    private Double gt, gte, lt, lte;
    private Object ne;
    private List<Object> in;

    // For OR logic
    private List<Map<String, Object>> or;

    // Getters
}
```

But to keep YAML clean, we‚Äôll **infer the type** from the structure.

### Keep `ContextDef.java` simple:
```java
public class ContextDef {
    private String from;
    private Object filter; // Can be Map<String, Object> or complex structure
    private Boolean first;
}
```

---

## ‚öôÔ∏è Step 2: Enhanced JsonPath Builder

### New method: `buildPredicate(Object filter)`
```java
private String buildPredicate(Object filter) {
    if (filter instanceof Map) {
        @SuppressWarnings("unchecked")
        Map<String, Object> filterMap = (Map<String, Object>) filter;
        
        List<String> predicates = new ArrayList<>();
        
        // Handle OR block
        if (filterMap.containsKey("or")) {
            @SuppressWarnings("unchecked")
            List<Map<String, Object>> orConditions = (List<Map<String, Object>>) filterMap.get("or");
            List<String> orPreds = new ArrayList<>();
            for (Map<String, Object> orCond : orConditions) {
                orPreds.add(buildPredicate(orCond));
            }
            return "(" + String.join(" || ", orPreds) + ")";
        }

        // Handle regular conditions
        for (Map.Entry<String, Object> entry : filterMap.entrySet()) {
            String field = entry.getKey();
            Object value = entry.getValue();
            predicates.add(buildFieldPredicate(field, value));
        }
        return String.join(" && ", predicates);
    }
    return "";
}

private String buildFieldPredicate(String field, Object value) {
    if (value instanceof Map) {
        @SuppressWarnings("unchecked")
        Map<String, Object> opMap = (Map<String, Object>) value;
        List<String> ops = new ArrayList<>();

        if (opMap.containsKey("gt")) {
            ops.add("@." + field + " > " + formatValue(opMap.get("gt")));
        }
        if (opMap.containsKey("gte")) {
            ops.add("@." + field + " >= " + formatValue(opMap.get("gte")));
        }
        if (opMap.containsKey("lt")) {
            ops.add("@." + field + " < " + formatValue(opMap.get("lt")));
        }
        if (opMap.containsKey("lte")) {
            ops.add("@." + field + " <= " + formatValue(opMap.get("lte")));
        }
        if (opMap.containsKey("ne")) {
            ops.add("@." + field + " != " + formatValue(opMap.get("ne")));
        }
        if (opMap.containsKey("in")) {
            @SuppressWarnings("unchecked")
            List<Object> inValues = (List<Object>) opMap.get("in");
            String inList = inValues.stream()
                .map(this::formatValue)
                .collect(Collectors.joining(", "));
            ops.add("@." + field + " in [" + inList + "]");
        }

        if (ops.isEmpty()) {
            // Default to equality
            return "@." + field + " == " + formatValue(value);
        }
        return String.join(" && ", ops);
    } else {
        // Simple equality
        return "@." + field + " == " + formatValue(value);
    }
}

private String formatValue(Object value) {
    if (value instanceof String) {
        return "\"" + value + "\"";
    } else if (value instanceof Boolean || value instanceof Number) {
        return value.toString();
    } else {
        return "\"" + value + "\"";
    }
}
```

---

## üß™ Real-World Examples

### Example 1: Multiple Data Types
```yaml
contexts:
  eligiblePrimary:
    from: applicants
    filter:
      type: PRIMARY
      isActive: true
      age: { gte: 18 }
      riskScore: { lt: 7.5 }
    first: true
```

### Generated JsonPath:
```jsonpath
$.applicants[?(@.type == "PRIMARY" && @.isActive == true && @.age >= 18 && @.riskScore < 7.5)][0]
```

### Example 2: OR + IN
```yaml
contexts:
  priorityApplicants:
    from: applicants
    filter:
      or:
        - tier: { in: ["GOLD", "PLATINUM"] }
        - isStaff: true
```

### Generated JsonPath:
```jsonpath
$.applicants[?((@.tier in ["GOLD", "PLATINUM"]) || @.isStaff == true)]
```

### Example 3: Nested Context Filter
```yaml
contexts:
  primaryHomeAddress:
    from: primary.addresses
    filter:
      type: HOME
      isVerified: true
    first: true
```

> ‚úÖ Works because `primary` resolves to a full JsonPath first.

---

## üß™ Unit Test Coverage

Your tests should verify:

```java
@Test
void shouldBuildPredicateForMixedTypes() {
    Map<String, Object> filter = new HashMap<>();
    filter.put("type", "PRIMARY");
    filter.put("isActive", true);
    Map<String, Object> ageCond = new HashMap<>();
    ageCond.put("gte", 18);
    filter.put("age", ageCond);

    String predicate = buildPredicate(filter);
    assertThat(predicate).contains("@.type == \"PRIMARY\"");
    assertThat(predicate).contains("@.isActive == true");
    assertThat(predicate).contains("@.age >= 18");
}

@Test
void shouldBuildOrPredicate() {
    Map<String, Object> or1 = Map.of("tier", "GOLD");
    Map<String, Object> or2 = Map.of("isStaff", true);
    Map<String, Object> filter = Map.of("or", Arrays.asList(or1, or2));

    String predicate = buildPredicate(filter);
    assertThat(predicate).isEqualTo("(@.tier == \"GOLD\" || @.isStaff == true)");
}
```

---

## ‚úÖ Summary

| Requirement | Supported? | Syntax |
|------------|-----------|--------|
| **Multiple conditions** | ‚úÖ | `filter: { a: X, b: Y }` |
| **String equality** | ‚úÖ | `status: "ACTIVE"` |
| **Boolean equality** | ‚úÖ | `isActive: true` |
| **Numeric equality** | ‚úÖ | `age: 25` |
| **Numeric comparisons** | ‚úÖ | `age: { gt: 18 }` |
| **IN clause** | ‚úÖ | `tier: { in: ["A", "B"] }` |
| **OR logic** | ‚úÖ | `or: [ {a: X}, {b: Y} ]` |
| **Works in nested contexts** | ‚úÖ | `from: primary.addresses` |

This gives you **enterprise-grade filtering** with a **clean, readable YAML syntax**.

Would you like:
- **Full code** for the enhanced JsonPath builder?
- Support for **regex** (`matches`)?
- **Custom functions** (e.g., `age: { between: [18, 65] }`)?

I‚Äôm happy to extend this further! üîç‚ú®