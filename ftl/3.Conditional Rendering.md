Great ask! Here are **practical patterns** to implement **conditional rendering** in Freemarker for your dynamic, data-driven layout approach—without proliferating templates.

We’ll cover:

1.  **Guard flags & simple conditions**
2.  **Role/segment-based rendering**
3.  **Variant selection (A/B or feature flags)**
4.  **Rule-level conditions (data-driven)**
5.  **Safe dynamic includes with fallback**
6.  **Backend-preprocessed predicates** (recommended)
7.  **Composability with macros and `<#switch>`**

All examples integrate with the structure we discussed (base/layouts/components/helpers).

***

## 1) Guard Flags & Simple Conditions

Use booleans or presence checks in `config`/`model` to decide whether to render a component or block.

```ftl
<#-- In pages/dynamic-page.ftl -->
<#import "../base/helpers.ftl" as H />

<#-- Render a banner only if promo exists and feature flag is on -->
<#if (config.features.showPromoBanner?boolean) && (model.promo?has_content)>
  <@H.renderComponent name="banner" props=model.promo />
</#if>
```

**Tip:** Prefer `?boolean` for flags to avoid truthiness surprises.

***

## 2) Role / Segment-Based Rendering

Conditionally include different components/layouts based on the user role, market segment, or device type passed in the model.

```ftl
<#-- Example: role-driven header -->
<#switch model.user.role!'guest'>
  <#case 'admin'>
    <@H.renderComponent name="admin-toolbar" props=model.user />
    <#break>
  <#case 'member'>
    <@H.renderComponent name="member-welcome" props=model.user />
    <#break>
  <#default>
    <@H.renderComponent name="guest-signup" props={} />
</#switch>
```

***

## 3) Variant Selection (Experiment / Feature Flags)

Pick a variant dynamically based on config, experiment IDs, or feature rollout.

```ftl
<#-- config: { variant: "B" } -->
<#assign variant = config.variant!'A' />

<#if variant == 'A'>
  <@H.renderComponent name="product-card" props=model.featured />
<#elseif variant == 'B'>
  <@H.renderComponent name="product-card-compact" props=model.featured />
<#else>
  <@H.renderComponent name="product-card-minimal" props=model.featured />
</#if>
```

***

## 4) Rule-Level Conditions (Data-Driven)

Add `when` conditions to each rule. Since Freemarker **can’t evaluate arbitrary strings** as code, you have two robust options:

### Option A: **Backend-evaluated** `enabled` flag (recommended)

Evaluate the condition in Java (or your backend) and pass an `enabled` boolean.

```json
{
  "rules": [
    { "component": "banner", "dataPath": "promo", "enabled": true },
    { "component": "product-card", "dataPath": "products", "enabled": false }
  ]
}
```

```ftl
<#-- layouts/list.ftl -->
<#import "../base/helpers.ftl" as H />

<#macro layout config model>
  <ul class="list">
    <#list config.rules?filter(r -> r.enabled?boolean) as rule>
      <#assign items = H.get(model, rule.dataPath, []) />
      <#list items as item>
        <li><@H.renderComponent name=rule.component props=item /></li>
      </#list>
    </#list>
  </ul>
</#macro>
```

### Option B: Pass “condition inputs” and evaluate with Freemarker

Define simple condition parameters like `minItems`, `requiredField`, etc., then check them in the template.

```json
{
  "rules": [
    {
      "component": "banner",
      "dataPath": "promo",
      "conditions": { "requiredField": "title" }
    },
    {
      "component": "product-card",
      "dataPath": "products",
      "conditions": { "minItems": 1 }
    }
  ]
}
```

```ftl
<#-- layouts/grid.ftl -->
<#import "../base/helpers.ftl" as H />

<#macro layout config model>
  <div class="grid grid-cols-${config.columns!3}">
    <#list config.rules as rule>
      <#assign items = H.get(model, rule.dataPath, []) />
      <#assign cond = rule.conditions!{} />

      <#-- Evaluate conditions -->
      <#assign hasMin = (cond.minItems!0) <= (items?size) />
      <#assign hasField = cond.requiredField?has_content
                          && H.get(model, rule.dataPath, {})[cond.requiredField]?has_content />

      <#if (cond?size == 0) || hasMin || hasField>
        <#-- Render: list vs single objects -->
        <#if items?is_sequence>
          <#list items as item>
            <div class="grid-item">
              <@H.renderComponent name=rule.component props=item />
            </div>
          </#list>
        <#else>
          <div class="grid-item">
            <@H.renderComponent name=rule.component props=items />
          </div>
        </#if>
      </#if>
    </#list>
  </div>
</#macro>
```

***

## 5) Safe Dynamic Includes with Fallback

Freemarker’s `<#attempt>/<#recover>` lets you conditionally render components that may not exist, without breaking the page.

```ftl
<#-- helpers.ftl -->
<#macro renderComponent name props>
  <#assign path = "templates/components/" + name + ".ftl" />
  <#attempt>
    <#include path>
    <@component props=props />
  <#recover>
    <div class="component-missing">Missing component: ${name}</div>
  </#recover>
</#macro>
```

Use it within conditional blocks to handle **both** missing data and missing component gracefully.

***

## 6) Backend-Preprocessed Predicates (Best for Complex Logic)

When conditions depend on **business rules** (e.g., entitlement, regional compliance, time windows), compute a `visibility` map in your backend and pass it in.

```json
{
  "visibility": {
    "showPromoBanner": true,
    "showRating": false,
    "showVipPricing": true
  }
}
```

```ftl
<#-- pages/dynamic-page.ftl -->
<#assign V = config.visibility!{} />

<#if V.showPromoBanner?boolean>
  <@H.renderComponent name="banner" props=model.promo />
</#if>

<@H.renderComponent name="product-card" props={
  "id": model.products[0].id,
  "name": model.products[0].name,
  "price": model.products[0].price,
  "showRating": V.showRating
} />
```

And inside the component:

```ftl
<#-- components/product-card.ftl -->
<#macro component props>
  <article>
    <h3>${props.name!'Unnamed'}</h3>
    <span class="price">${props.price!?string.currency}</span>
    <#if props.showRating?boolean && props.rating?has_content>
      <span class="rating">${props.rating}/5</span>
    </#if>
  </article>
</#macro>
```

***

## 7) Composable Macros for Conditional Regions

Encapsulate conditional rendering in macros to keep page templates clean.

```ftl
<#-- helpers.ftl -->
<#macro when test>
  <#if test?boolean>
    <#nested/>
  </#if>
</#macro>

<#macro whenHas obj key>
  <#if obj?has_content && obj[key]?has_content>
    <#nested obj[key]/>
  </#if>
</#macro>
```

Usage:

```ftl
<@H.when test=config.features.showFooter>
  <@H.renderComponent name="banner" props=model.footer />
</@H.when>

<@H.whenHas obj=model key="promo">
  <@H.renderComponent name="banner" props=.nested_params />
</@H.whenHas>
```

***

## Putting It Together (Mini Example)

```ftl
<#-- pages/dynamic-page.ftl -->
<#import "../base/helpers.ftl" as H />
<#import "../layouts/layout-resolver.ftl" as L />
<#include "../base/base.ftl">

<#block title>${config.pageTitle!'Dynamic Page'}</#block>

<#block content>
  <@H.when test=config.features.showHeader?boolean>
    <@H.renderComponent name=config.headerComponent!'banner' props=H.get(model, 'header', {}) />
  </@H.when>

  <@L.resolveLayout config=config model=model />

  <@H.when test=config.features.showFooter?boolean>
    <@H.renderComponent name=config.footerComponent!'banner' props=H.get(model, 'footer', {}) />
  </@H.when>
</#block>
```

***

## Recommendations for a Clean Architecture

*   **Keep Freemarker logic shallow**: push complex predicates to backend, expose them as booleans or simple thresholds.
*   **Normalize data paths** in backend (resolve arrays/singletons, apply filters) so templates don’t need to.
*   **Use a rule DSL** with limited, well-understood keys (`enabled`, `minItems`, `requiredField`, `variant`, `zone`).
*   **Test with sample configs** to ensure the template remains generic.

***

If you share a **sample scenario** (e.g., “render different checkout sections based on payment method and country”), I’ll tailor the conditions and provide a ready-to-drop `rules` schema + templates for that case.
