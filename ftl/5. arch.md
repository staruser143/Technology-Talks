Below is a **complete, working sample architecture** for building **complex, dynamic layouts** with FreeMarker. It uses:

*   a **base layout** with named **regions/slots**
*   reusable **macros** for UI components
*   **dynamic content placeholders** driven by your data model
*   clean **folder structure**
*   **auto-escaping**, **i18n**, and **error boundaries**
*   optional **DB/CMS-backed template loading** (so business users can manage fragments without redeploys)

> The structure is framework-agnostic; I’ve added Spring Boot examples where helpful since it’s common in Java stacks.

***

## 1) Folder Structure

    src/main/resources/templates/
      layouts/
        base.ftl                 <-- site-wide layout
        regions.ftl              <-- region/slot macro
      components/
        header.ftl               <-- header macro
        footer.ftl               <-- footer macro
        card.ftl                 <-- component macro (example)
        table.ftl                <-- component macro (example)
      pages/
        home.ftl                 <-- page using base layout
        product-list.ftl         <-- another page
      i18n/
        i18n.ftl                 <-- translation helpers (macro facade)

***

## 2) Base Layout with Regions & Assets

`templates/layouts/base.ftl`

```ftl
<#-- Base layout with named regions, asset handling, and nested content -->
<#import "/layouts/regions.ftl" as slots>
<#import "/components/header.ftl" as ui>
<#import "/components/footer.ftl" as ui>

<#macro layout title css=[] js=[] bodyClass="">

<!DOCTYPE html>
<html lang="${lang?default('en')}">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>${title?html}</title>

  <#-- CSS assets -->
  <#list css as href>
    ${href?html}
  </#list>
</head>

<body class="${bodyClass?html}">
  <header>
    <@ui.header />
  </header>

  <#-- Optional global flash region -->
  <@slots.region id="flash">
    <#-- Default empty; controller can inject regions.flash -->
  </@slots.region>

  <main id="content">
    <#-- Page content block -->
    <#nested>
  </main>

  <aside id="sidebar">
    <@slots.region id="sidebar">
      <div class="sidebar-default">Default sidebar</div>
    </@slots.region>
  </aside>

  <footer>
    <@ui.footer />
  </footer>

  <#-- JS assets at the end for performance -->
  <#list js as src>
    ${src?html}</script>
  </#list>
</body>
</html>

</#macro>
```

### How regions work

*   The layout declares named **regions** (`flash`, `sidebar`) via a macro.
*   Each region renders **controller-provided dynamic content** (from `regions` map) or **falls back** to the default content supplied inside the macro body.

***

## 3) Region/Slot Macro (Dynamic Content Placeholders)

`templates/layouts/regions.ftl`

```ftl
<#-- A region macro that renders controller-provided HTML (if present), else fallback -->
<#macro region id>
  <#-- Expect a data-model map: regions[id] with pre-rendered HTML (sanitized if needed) -->
  <#local content = (regions[id])!"" />
  <#if content?has_content>
    <#-- If content is trusted/sanitized HTML, render without escaping -->
    ${content?no_esc}
  <#else>
    <#-- Default/fallback content from the macro body -->
    <#nested>
  </#if>
</#macro>
```

> **Security note:** Prefer structured data and component macros over raw HTML. If you must inject HTML from a CMS, sanitize server-side and only then use `?no_esc`.

***

## 4) Component Macros

`templates/components/header.ftl`

```ftl
<#macro header>
  <nav class="top-nav">
    /Home</a>
    /productsProducts</a>
  </nav>
</#macro>
```

`templates/components/footer.ftl`

```ftl
<#macro footer>
  <div class="footer">
    &copy; ${currentYear?default(.now?string('yyyy'))} MyCompany
  </div>
</#macro>
```

`templates/components/card.ftl`

```ftl
<#macro card title body price?string="">
  <div class="card">
    <h3>${title?html}</h3>
    <p>${body?html}</p>
    <#if price?has_content>
      <div class="price">${price?html}</div>
    </#if>
  </div>
</#macro>
```

`templates/components/table.ftl`

```ftl
<#macro table columns rows>
  <table class="data-table">
    <thead>
      <tr>
        <#list columns as col>
          <th>${col.label?html}</th>
        </#list>
      </tr>
    </thead>
    <tbody>
      <#list rows as r>
        <tr>
          <#list columns as col>
            <td>${(r[col.key])?string?html}</td>
          </#list>
        </tr>
      </#list>
    </tbody>
  </table>
</#macro>
```

***

## 5) Page Template Using the Base Layout

`templates/pages/home.ftl`

```ftl
<#import "/layouts/base.ftl" as layout>
<#import "/components/card.ftl" as c>
<#import "/i18n/i18n.ftl" as t>

<@layout.layout
    title=t.t("home.title")
    css=["/assets/app.css"]
    js=["/assets/app.js"]
    bodyClass="home">

  <h1>${t.t("home.heading")}</h1>

  <div class="grid">
    <#list featuredProducts?default([]) as p>
      <@c.card title=p.name body=p.description price=p.price />
    </#list>
  </div>

  <@layout.region id="sidebar">
    <@c.card title=t.t("home.sidebar.title") body=t.t("home.sidebar.body") />
  </@layout.region>

</@layout.layout>
```

***

## 6) i18n Macro Facade

`templates/i18n/i18n.ftl`

```ftl
<#-- Simple i18n facade over a messages map (backed by ResourceBundle in Java) -->
<#macro t key params...>
  <#assign raw = (messages[key])!key />
  <#if params?size gt 0>
    <#-- naive positional substitution: {0}, {1}, ... -->
    <#list params as p>
      <#assign raw = raw?replace("{"+p_index+"}", p?string) />
    </#list>
  </#if>
  ${raw?html}
</#macro>
```

> In production, load `messages` from Java `ResourceBundle` based on `Locale` and expose it as a map in the data model.

***

## 7) Controller / Service: Data Model & Template Configuration (Spring Boot)

### Java config for FreeMarker (auto-escaping + multiple template loaders)

```java
import freemarker.cache.ClassTemplateLoader;
import freemarker.cache.MultiTemplateLoader;
import freemarker.cache.StringTemplateLoader;
import freemarker.core.HTMLOutputFormat;
import freemarker.template.Configuration;
import freemarker.template.TemplateExceptionHandler;
import freemarker.template.Version;

@Configuration
public class FreemarkerConfig {

  @Bean
  public Configuration freemarkerConfiguration(StringTemplateLoader dbTemplateLoader) {
    Configuration cfg = new Configuration(Configuration.VERSION_2_3_32);
    cfg.setClassForTemplateLoading(getClass(), "/templates");
    cfg.setDefaultEncoding("UTF-8");

    // Enable modern features & auto-escaping for HTML
    cfg.setIncompatibleImprovements(new Version(2, 3, 24));
    cfg.setOutputFormat(HTMLOutputFormat.INSTANCE);
    cfg.setAutoEscapingPolicy(Configuration.ENABLE_IF_SUPPORTED_AUTO_ESCAPING_POLICY);
    cfg.setTemplateExceptionHandler(TemplateExceptionHandler.RETHROW_HANDLER);

    // Combine classpath templates with DB/CMS-managed ones
    ClassTemplateLoader classLoader = new ClassTemplateLoader(getClass(), "/templates");
    MultiTemplateLoader mtl = new MultiTemplateLoader(new freemarker.cache.TemplateLoader[]{
        classLoader, dbTemplateLoader
    });
    cfg.setTemplateLoader(mtl);

    return cfg;
  }

  @Bean
  public StringTemplateLoader dbTemplateLoader() {
    return new StringTemplateLoader(); // Populate at runtime from CMS/DB
  }
}
```

### Example controller building a rich data model

```java
@GetMapping("/home")
public ModelAndView home(Locale locale) {
  Map<String, Object> model = new HashMap<>();

  // i18n (ResourceBundle → Map)
  ResourceBundle rb = ResourceBundle.getBundle("messages", locale);
  Map<String, String> messages = rb.keySet().stream()
    .collect(Collectors.toMap(k -> k, rb::getString));
  model.put("messages", messages);
  model.put("lang", locale.getLanguage());

  // Page content data (structured)
  List<Map<String, Object>> featured = List.of(
      Map.of("name", "Pro Plan", "description", "Best for teams", "price", "₹799/mo"),
      Map.of("name", "Starter", "description", "Beginner friendly", "price", "₹0")
  );
  model.put("featuredProducts", featured);

  // Dynamic regions (from CMS or business rules)
  Map<String, String> regions = new HashMap<>();
  regions.put("flash", "<div class='alert success'>Welcome back!</div>"); // sanitized HTML
  // If absent, base.ftl fallback kicks in
  model.put("regions", regions);

  return new ModelAndView("pages/home", model);
}
```

### Runtime updates (CMS-managed templates)

```java
// Example: write/update a CMS-managed partial at runtime
@Autowired StringTemplateLoader dbTemplateLoader;

public void upsertCmsFragment(String key, String ftlSource) {
  synchronized (dbTemplateLoader) {
    if (dbTemplateLoader.findTemplateSource(key) != null) {
      dbTemplateLoader.putTemplate(key, ftlSource); // replaces existing
    } else {
      dbTemplateLoader.putTemplate(key, ftlSource);
    }
  }
}
// Then refer to it by <#include "/cms/fragments/announcement.ftl"> or call imported macros.
```

> This pattern lets **business users manage fragments** (e.g., announcement bars, email partials) in a CMS/DB, without redeploying. It aligns with your preference for a CMS-based approach.

***

## 8) Advanced Composition: Component Registry & Variants

Sometimes pages are described by a list of “blocks” (from CMS):

```json
{
  "blocks": [
    {"type": "card", "props": {"title": "News", "body": "Latest updates"}},
    {"type": "table", "props": {
      "columns":[{"key":"name","label":"Name"},{"key":"status","label":"Status"}],
      "rows":[{"name":"Job A","status":"Running"},{"name":"Job B","status":"Pending"}]
    }}
  ]
}
```

`templates/pages/dynamic.ftl`

```ftl
<#import "/layouts/base.ftl" as layout>
<#import "/components/card.ftl" as c>
<#import "/components/table.ftl" as t>

<@layout.layout title="Dynamic Page">
  <#list blocks?default([]) as b>
    <#switch b.type>
      <#case "card">
        <@c.card title=b.props.title body=b.props.body />
      </#case>
      <#case "table">
        <@t.table columns=b.props.columns rows=b.props.rows />
      </#case>
      <#default>
        <div class="unknown">Unknown block: ${b.type?html}</div>
    </#switch>
  </#list>
</@layout.layout>
```

This approach keeps templates declarative while allowing **rich, data-driven composition**.

***

## 9) Error Boundaries & Diagnostics

Use `#attempt` / `#recover` in risky zones:

```ftl
#attempt
  <@t.table columns=columns rows=rows />
#recover
  <div class="error">Table unavailable</div>
/#attempt
```

In development, use `TemplateExceptionHandler.RETHROW_HANDLER` so errors surface clearly.

***

## 10) Performance & Safety Tips

*   **Auto-escape HTML** globally (shown above).
*   Prefer **structured data** into macros over raw HTML; if you must inject HTML, **sanitize server-side** and render via `?no_esc` only for trusted content.
*   Keep complex branching **out of templates**; precompute flags/values in controllers/services.
*   Cache **data** and **rendered results** at the application layer (e.g., Spring Cache) if needed.
*   Use a **component library** (macros) to standardize markup and reduce duplication.
*   Organize templates under `/layouts`, `/components`, `/pages`, `/i18n` for clarity.

***

## 11) Optional: Email Templates (Azure Communication Services)

For email, keep a **separate template set** (to avoid web markup bleed):

    templates-email/
      layouts/email-base.ftl
      components/email-header.ftl
      components/email-footer.ftl
      emails/
        order-confirmation.ftl
        password-reset.ftl

Load them via a **`StringTemplateLoader`** from your CMS so business users can edit subject lines, headers, and bodies safely. Pre-render to HTML and send via ACS. Always sanitize and **inline CSS** for wide client compatibility.

***

## 12) Quick Checklist

*   [ ] Base layout macro with `#nested` content
*   [ ] Region/slot macro backed by `regions` map
*   [ ] Component macros for repeated UI
*   [ ] Pages import base + components
*   [ ] i18n map + macro facade
*   [ ] Global auto-escaping enabled
*   [ ] Controller supplies clean, precomputed data
*   [ ] Optional CMS/DB-backed `StringTemplateLoader`
*   [ ] Error boundaries with `#attempt/#recover`
*   [ ] Asset lists (`css`, `js`) passed via macro parameters

***

If you want, I can **spin this into a minimal Git repo structure** or adapt it to **your stack (Spring MVC, Micronaut, Quarkus)**, and include a **sample messages bundle** plus **JUnit renderer test** to validate each page with fixture data.
