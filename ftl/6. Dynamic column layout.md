Great question, Sridhar! The architecture I shared is designed to make **both layout and content fully data-driven**. That means you can render **2-, 3-, or N-column layouts** and vary the content in each column *at runtime* based on the data you pass—without changing template code.

Below is how the pieces come together, with concrete patterns and code you can drop in.

***

## Core idea: **Layout = Data + Component Macros**

*   **Layout is a configuration object** (e.g., `{ columns: 3, regions: [...] }`) passed from your controller/service or CMS.
*   **Content is a list of blocks** (cards, tables, banners) with props and optionally a target **region** (column slot).
*   Templates remain declarative: they **iterate** over layout regions and **render blocks** using component macros.

This avoids branching template logic and keeps the system maintainable.

***

## 1) Define a **generic, N-column** layout macro

Create a macro that renders any number of columns with responsive classes:

`templates/layouts/grid.ftl`

```ftl
<#-- Generic grid layout macro supporting 1..N columns with region slots -->
<#macro gridLayout columns=1 gap="1rem" classPrefix="col" responsive=true>

  <#-- Compute CSS class for each column; you can map numbers to CSS framework classes -->
  <#function colClass idx total>
    <#-- Example: simple flex distribution or framework-specific classes -->
    <#return (responsive)
      ? then("${classPrefix}-${total} ${classPrefix}-${total}--${idx}")
      : "${classPrefix}" />
  </#function>

  <div class="grid" style="display:flex; gap:${gap?html}">
    <#list 1..columns as i>
      <div class="${colClass(i, columns)}" style="flex:1">
        <#-- Each column is a named region: column-1, column-2, ... -->
        <@slots.region id="column-${i}">
          <#-- Fallback if nothing is injected -->
          <div class="empty-column"></div>
        </@slots.region>
      </div>
    </#list>
  </div>

  <#nested> <#-- Optional nested area below the grid -->
</#macro>
```

> You can wire this to your CSS framework (Bootstrap/Tailwind) by mapping `colClass` to `col-md-6`, `col-md-4`, etc., or Tailwind grid classes.

***

## 2) Drive **column count** and **content placement** via data

From your controller, pass a layout object and blocks assigned to regions (columns):

```java
Map<String, Object> model = new HashMap<>();

// Layout config: 2, 3, or N columns
Map<String, Object> pageLayout = Map.of(
  "columns", 3,
  "gap", "16px",
  "responsive", true
);
model.put("pageLayout", pageLayout);

// Blocks with target region (column) and type
List<Map<String, Object>> blocks = List.of(
  Map.of("type","card","region","column-1",
         "props", Map.of("title","News", "body","Latest updates")),
  Map.of("type","table","region","column-2",
         "props", Map.of(
           "columns", List.of(Map.of("key","name","label","Name"),
                              Map.of("key","status","label","Status")),
           "rows", List.of(Map.of("name","Job A","status","Running"),
                           Map.of("name","Job B","status","Pending"))
         )),
  Map.of("type","card","region","column-3",
         "props", Map.of("title","Tips","body","Pro tips for teams"))
);
model.put("blocks", blocks);

// Build regions map by concatenating rendered fragments or (preferably) structured rendering in template
model.put("regions", new HashMap<String, String>()); // optional if rendering by region in FTL

return new ModelAndView("pages/dynamic-grid", model);
```

***

## 3) Render **by region** in the page template

Two ways to render:

### A) **Region-driven** (recommended): group blocks per region and render inside each column

`templates/pages/dynamic-grid.ftl`

```ftl
<#import "/layouts/base.ftl" as layout>
<#import "/layouts/grid.ftl" as grid>
<#import "/components/card.ftl" as c>
<#import "/components/table.ftl" as t>

<#-- Helper: filter blocks for a specific region -->
<#function blocksFor regionName>
  <#return (blocks?filter(b -> (b.region)!"" == regionName))![]>
</#function>

<@layout.layout title="Dynamic Grid">

  <@grid.gridLayout
      columns=pageLayout.columns
      gap=pageLayout.gap
      responsive=pageLayout.responsive>

    <#-- For each column region, render its blocks in order -->
    <#list 1..(pageLayout.columns!1) as i>
      <@layout.region id="column-${i}">
        <#assign columnBlocks = blocksFor("column-${i}") />
        <#list columnBlocks as b>
          <#switch b.type>
            <#case "card">
              <@c.card title=b.props.title body=b.props.body />
            </#case>
            <#case "table">
              <@t.table columns=b.props.columns rows=b.props.rows />
            </#case>
            <#default>
              <div class="unknown">Unknown block: ${b.type?html}</div>
          </#switch>
        </#list>
      </@layout.region>
    </#list>

  </@grid.gridLayout>

</@layout.layout>
```

### B) **CMS HTML injection** (alternative): render pre-composed HTML per region

*   If your CMS outputs HTML, populate `regions["column-2"]` with sanitized HTML and rely on `<@slots.region>` to render.
*   Prefer A for stronger structure, reusability, and safety.

***

## 4) Dynamic column **variants** (2-, 3-, N-column) at runtime

You can switch column counts purely via `pageLayout.columns`:

*   For **2 columns**: set `columns=2` and distribute blocks by `region: "column-1"` or `"column-2"`.
*   For **3 columns**: set `columns=3`, add a third region and assign blocks to `"column-3"`.
*   For **N columns**: same pattern; the grid macro loops up to `N`.

No template changes required—only **data** changes.

***

## 5) Responsive behavior and **breakpoints**

Make your grid macro emit classes that map to breakpoints:

*   Bootstrap example:
    *   2 columns: `col-12 col-md-6`
    *   3 columns: `col-12 col-md-4`
*   Tailwind example:
    *   `grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4`

You could externalize this mapping:

```ftl
<#-- grid.ftl: Tailwind sample -->
<#macro twGrid columns=3 gap="gap-4">
  <div class="grid grid-cols-1 md:grid-cols-${columns} ${gap}">
    <#list 1..columns as i>
      <div class="col">
        <@slots.region id="column-${i}">
          <div class="empty"></div>
        </@slots.region>
      </div>
    </#list>
  </div>
</#macro>
```

> Whether Bootstrap or Tailwind, the **data decides** the number of columns; CSS decides the **visual distribution** and **responsive stacking**.

***

## 6) **Ordering, pinning, visibility** rules via data

Extend block metadata:

```json
{
  "type": "card",
  "region": "column-2",
  "order": 10,
  "visible": true,
  "variant": "highlight",
  "props": { "title": "Alert", "body": "Important notice" }
}
```

In FTL, sort and filter:

```ftl
<#assign columnBlocks = (blocksFor("column-2")?filter(b -> (b.visible)!true))?sort_by("order") />
```

Variants can select different component macro versions (`card-highlight.ftl`) or pass a `variant` param handled inside the macro.

***

## 7) **Nested grids** and sub-layouts

You might need sub-sections that change column counts independently. Compose macros:

```ftl
<@grid.gridLayout columns=2>
  <@layout.region id="column-1">
    <@grid.gridLayout columns=3>
      <#-- nested blocks assigned to column-1:sub-column-1..3 -->
    </@grid.gridLayout>
  </@layout.region>
  <@layout.region id="column-2">
    <#-- another nested composition -->
  </@layout.region>
</@grid.gridLayout>
```

Name nested regions predictably (e.g., `column-1-1`) or include a `scope`/`prefix` parameter to the macro to avoid collisions.

***

## 8) **Fallbacks** and error boundaries

*   If a region has **no blocks**, the region macro’s `<#nested>` fallback renders a default.
*   Use `#attempt/#recover` around unknown components or CMS HTML to prevent rendering failures in production and show graceful placeholders.

```ftl
#attempt
  <@t.table columns=b.props.columns rows=b.props.rows />
#recover
  <div class="error">Table unavailable</div>
/#attempt
```

***

## 9) **Performance** & safety

*   **Precompute** block grouping by region in the controller for O(1) lookup if you have many blocks:
    ```java
    Map<String, List<Map<String,Object>>> byRegion = blocks.stream()
        .collect(Collectors.groupingBy(b -> (String)b.get("region"), LinkedHashMap::new, Collectors.toList()));
    model.put("blocksByRegion", byRegion);
    ```
    Then in FTL, just use `blocksByRegion["column-2"]![]`.

*   **Auto-escape** HTML globally; only render CMS HTML with `?no_esc` after **server-side sanitization**.

*   Cache **layout configs** and **i18n bundles**; consider ETag or SSR fragment caching for expensive tables.

***

## 10) Putting it together—minimal page example

`templates/pages/products.ftl`

```ftl
<#import "/layouts/base.ftl" as layout>
<#import "/layouts/grid.ftl" as grid>
<#import "/components/card.ftl" as c>
<#import "/components/table.ftl" as t>

<@layout.layout title=messages["products.title"]! "Products" css=["/assets/app.css"]>

  <@grid.gridLayout columns=pageLayout.columns gap=pageLayout.gap>

    <#list 1..(pageLayout.columns!1) as i>
      <@layout.region id="column-${i}">
        <#assign columnBlocks = (blocksByRegion["column-${i}"])![] />
        <#list columnBlocks as b>
          <#switch b.type>
            <#case "card">
              <@c.card title=b.props.title body=b.props.body price=(b.props.price)!"" />
            </#case>
            <#case "table">
              <@t.table columns=b.props.columns rows=b.props.rows />
            </#case>
            <#default>
              <div class="unknown">Unknown: ${b.type?html}</div>
          </#switch>
        </#list>
      </@layout.region>
    </#list>

  </@grid.gridLayout>

</@layout.layout>
```

Change `pageLayout.columns` to **2**, **3**, or **N** and adjust `blocks` placement—no template edits needed.

***

## 11) Governance & authoring (CMS)

To let business users control layout:

*   Store **layout presets** (2-column, 3-column, dashboard) as JSON in CMS.
*   Authors assign blocks to **regions** and set **order** and **visibility**; content types map to component macros.
*   Optionally, provide **preview rendering** using the same macros.

This aligns well with your preference for a **CMS-managed template/fragments** approach.

***

## 12) Quick checklist to support dynamic multi-column layouts

*   [ ] Grid macro that accepts `columns` and renders named regions `column-1..N`
*   [ ] Data model with `pageLayout` (+ optional responsive presets)
*   [ ] Blocks list with `type`, `props`, `region`, `order`, `visible`
*   [ ] Component registry: macros per `type` (card, table, banner, chart…)
*   [ ] Region rendering loops per column + sorting/filtering
*   [ ] Auto-escape enabled; sanitize CMS HTML before `?no_esc`
*   [ ] Error boundaries for unknown/missing components
*   [ ] Optional: group blocks by region on the server for performance

***

If you want, I can **generate a starter project** (Spring Boot + FreeMarker) with:

*   the `gridLayout` macro,
*   sample pages demonstrating **2**, **3**, and **N** columns,
*   a small **component library**,
*   and a **JSON-driven controller** that simulates CMS data.
