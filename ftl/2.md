Awesomeâ€”hereâ€™s a **practical, production-ready Freemarker template structure** for rendering dynamic layouts and content at runtime **without exploding the number of templates**. It uses:

*   A **base layout** + blocks
*   A **component registry** (modular macros/partials)
*   **Data-driven configuration** (JSON/DB) that selects components and layouts at runtime
*   Minimal, reusable helpers

You can copy this structure into your project and adapt it to your domain.

***

## ğŸ“ Suggested Directory Structure

    templates/
    â”œâ”€ base/
    â”‚  â”œâ”€ base.ftl                  # Base shell with slots/blocks
    â”‚  â””â”€ helpers.ftl               # Common macros & functions (null-safe access, formatters)
    â”œâ”€ layouts/
    â”‚  â”œâ”€ layout-resolver.ftl       # Chooses a layout based on config/model
    â”‚  â””â”€ grid.ftl                  # Grid layout block
    â”‚  â””â”€ list.ftl                  # List layout block
    â”‚  â””â”€ single.ftl                # Single-item layout block
    â”œâ”€ components/
    â”‚  â”œâ”€ product-card.ftl          # Example component
    â”‚  â”œâ”€ banner.ftl
    â”‚  â”œâ”€ rating.ftl
    â”‚  â””â”€ price.ftl
    â”œâ”€ pages/
    â”‚  â””â”€ dynamic-page.ftl          # Entry template that stitches everything

***

## ğŸ§± 1) Base Layout (`templates/base/base.ftl`)

A simple shell with overridable blocks/slots:

```ftl
<#-- templates/base/base.ftl -->
<#-- Base page skeleton -->
<!DOCTYPE html>
<html lang="${lang! 'en'}">
<head>
  <meta charset="utf-8"/>
  <title><#block name="title">Untitled</#block></title>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <#block name="head_extras"></#block>
  <style>
    /* minimal styles or include your CSS links here */
  </style>
</head>
<body>
  <header>
    <#block name="header">
      <h1>${site.title!'My Site'}</h1>
    </#block>
  </header>

  <main id="content">
    <#block name="content">
      <p>No content.</p>
    </#block>
  </main>

  <footer>
    <#block name="footer">
      <small>&copy; ${.now?string('yyyy')} ${site.org!'Org'}</small>
    </#block>
  </footer>

  <#block name="scripts"></#block>
</body>
</html>
```

> The `<#block>` directive lets child templates override sections cleanly.

***

## ğŸ› ï¸ 2) Helpers (`templates/base/helpers.ftl`)

Reusable macros & functions (nullâ€‘safety, dynamic includes, formatting):

```ftl
<#-- templates/base/helpers.ftl -->

<#-- Null-safe getter: returns default if missing -->
<#function get obj key defaultVal>
  <#if obj?has_content && obj[key]?has_content>
    <#return obj[key]>
  <#else>
    <#return defaultVal>
  </#if>
</#function>

<#-- Conditionally render a component if it exists -->
<#macro renderComponent name props>
  <#assign path = "templates/components/" + name + ".ftl">
  <#attempt>
    <#include path>
    <@component props=props />
  <#recover>
    <#-- Fallback if component file is missing -->
    <div class="component-missing">Missing component: ${name}</div>
  </#attempt>
</#macro>

<#-- Safe list iteration -->
<#macro list items>
  <#if items?has_content>
    <#list items as it>
      <#nested it/>
    </#list>
  <#else>
    <#nested null/>
  </#if>
</#macro>
```

> We define a convention: each component file exports a macro named `component`.

***

## ğŸ§© 3) Components (registry) â€” example (`templates/components/product-card.ftl`)

Each component exposes a consistent macro signature:

```ftl
<#-- templates/components/product-card.ftl -->
<#macro component props>
  <#-- Expect props: { id, name, imageUrl, price, rating } -->
  <article class="product-card" data-id="${props.id!}">
    ${props.imageUrl!
    <h3>${props.name!'Unnamed'}</h3>
    <div class="meta">
      <span class="price">${props.price!?string.currency}</span>
      <#if props.rating?has_content>
        <span class="rating">${props.rating}/5</span>
      </#if>
    </div>
  </article>
</#macro>
```

Another simple component:

```ftl
<#-- templates/components/banner.ftl -->
<#macro component props>
  <section class="banner banner-${props.style!'info'}">
    <h2>${props.title!'Notice'}</h2>
    <p>${props.message!'...'}</p>
  </section>
</#macro>
```

***

## ğŸ§± 4) Layout Blocks (`templates/layouts/grid.ftl`, `list.ftl`, `single.ftl`)

Define how multiple components are arranged. Layouts **consume a list of â€œrender instructionsâ€** from config.

**Grid layout:**

```ftl
<#-- templates/layouts/grid.ftl -->
<#import "../base/helpers.ftl" as H />

<#macro layout config model>
  <#-- config.rules: [{component: "product-card", dataPath: "products[*]"}, ...] -->
  <div class="grid grid-cols-${config.columns!3}">
    <#list config.rules as rule>
      <#-- Resolve data set from model using rule.dataPath -->
      <#assign items = H.get(model, rule.dataPath, []) />
      <#-- If dataPath uses wildcard, you can preprocess in Java to materialize items -->
      <#if items?has_content>
        <#list items as item>
          <div class="grid-item">
            <@H.renderComponent name=rule.component props=item />
          </div>
        </#list>
      <#else>
        <div class="grid-item empty">No items for ${rule.component}</div>
      </#if>
    </#list>
  </div>
</#macro>
```

**List layout:**

```ftl
<#-- templates/layouts/list.ftl -->
<#import "../base/helpers.ftl" as H />

<#macro layout config model>
  <ul class="list">
    <#list config.rules as rule>
      <#assign items = H.get(model, rule.dataPath, []) />
      <#list items as item>
        <li class="list-item">
          <@H.renderComponent name=rule.component props=item />
        </li>
      </#list>
    </#list>
  </ul>
</#macro>
```

**Single layout:**

```ftl
<#-- templates/layouts/single.ftl -->
<#import "../base/helpers.ftl" as H />

<#macro layout config model>
  <#-- Expect a single rule -->
  <#assign rule = config.rules[0]! />
  <#assign data = H.get(model, rule.dataPath, {}) />
  <@H.renderComponent name=rule.component props=data />
</#macro>
```

***

## ğŸ§  5) Layout Resolver (`templates/layouts/layout-resolver.ftl`)

Picks a layout dynamically based on `config.layoutType` (or model fields):

```ftl
<#-- templates/layouts/layout-resolver.ftl -->
<#import "../base/helpers.ftl" as H />

<#macro resolveLayout config model>
  <#switch config.layoutType!'list'>
    <#case 'grid'>
      <#include "grid.ftl">
      <@layout config=config model=model />
      <#break>
    <#case 'single'>
      <#include "single.ftl">
      <@layout config=config model=model />
      <#break>
    <#default>
      <#include "list.ftl">
      <@layout config=config model=model />
  </#switch>
</#macro>
```

***

## ğŸ§¾ 6) Entry Template (`templates/pages/dynamic-page.ftl`)

This is what you render in your code. It **pulls everything together**:

```ftl
<#-- templates/pages/dynamic-page.ftl -->
<#include "../base/base.ftl">
<#import "../base/helpers.ftl" as H />
<#import "../layouts/layout-resolver.ftl" as L />

<#-- Expect: model (domain object), config (JSON/DB rules), site/lang -->
<#-- Example config:
{
  "layoutType": "grid",
  "columns": 4,
  "rules": [
    { "component": "banner", "dataPath": "promo" },
    { "component": "product-card", "dataPath": "products" }
  ]
}
-->

<#block title>${H.get(config, 'pageTitle', 'Dynamic Page')}</#block>

<#block content>
  <#-- Optional pre-header component -->
  <#if (config.headerComponent)?has_content>
    <@H.renderComponent name=config.headerComponent props=H.get(model, 'header', {}) />
  </#if>

  <@L.resolveLayout config=config model=model />

  <#-- Optional post-footer component -->
  <#if (config.footerComponent)?has_content>
    <@H.renderComponent name=config.footerComponent props=H.get(model, 'footer', {}) />
  </#if>
</#block>
```

***

## ğŸ§ª 7) Example Data Model & Config (passed from your application)

**Model** (e.g., from your backend):

```json
{
  "promo": { "title": "Holiday Sale", "message": "Up to 50% off!", "style": "success" },
  "products": [
    { "id": "P001", "name": "Widget A", "imageUrl": "/img/a.png", "price": 1999, "rating": 4.5 },
    { "id": "P002", "name": "Widget B", "imageUrl": "/img/b.png", "price": 2999, "rating": 4.2 }
  ],
  "header": { "title": "Welcome" },
  "footer": { "note": "Terms apply." }
}
```

**Config** (JSON stored in DB or CMS; choose at runtime):

```json
{
  "pageTitle": "Featured Products",
  "layoutType": "grid",
  "columns": 3,
  "headerComponent": "banner",
  "footerComponent": "banner",
  "rules": [
    { "component": "banner", "dataPath": "promo" },
    { "component": "product-card", "dataPath": "products" }
  ]
}
```

> You can flip `layoutType` to `list` or `single` or add/remove `rules` **without changing templates**.

***

## ğŸ”Œ 8) Java Integration (example)

How to pass `model` and `config` into the template:

```java
// Assuming you use Freemarker 2.3.x
Configuration cfg = new Configuration(Configuration.VERSION_2_3_32);
cfg.setClassLoaderForTemplateLoading(Thread.currentThread().getContextClassLoader(), ""); // root of resources
cfg.setDefaultEncoding("UTF-8");
cfg.setLogTemplateExceptions(false);
cfg.setTemplateExceptionHandler(TemplateExceptionHandler.RETHROW_HANDLER);

Template tpl = cfg.getTemplate("templates/pages/dynamic-page.ftl");

// Model & config prepared in Java (config likely read from DB/CMS as Map)
Map<String, Object> dataModel = new HashMap<>();
dataModel.put("model", domainModelMap);      // your JSON -> Map
dataModel.put("config", layoutConfigMap);    // your JSON -> Map
dataModel.put("site", Map.of("title", "Store", "org", "Acme Inc."));
dataModel.put("lang", "en");

try (Writer out = new StringWriter()) {
    tpl.process(dataModel, out);
    String html = out.toString();
    // Return or write html to response
}
```

***

## ğŸ§­ Design Principles Embedded Here

*   **Single entry point** (`dynamic-page.ftl`) + **base skeleton** â€” minimizes duplication.
*   **Component registry pattern**: add new components as files; no template explosion.
*   **Data-driven rules** (`config.rules`) select components at runtime.
*   **Layout resolver** isolates layout decisions; easy to add new layouts.
*   **Helpers** avoid noisy null checks & centralize common patterns.

***

## âš™ï¸ Optional Enhancements

*   **Rule conditions**: allow conditional rendering, e.g.,
    ```json
    { "component": "banner", "dataPath": "promo", "when": "model.promo != null" }
    ```
    Evaluate `when` in backend, or pre-filter rules before passing to Freemarker.

*   **Slot system**: support named zones:
    ```json
    { "zone": "sidebar", "component": "banner", "dataPath": "promo" }
    ```
    Then in base layout: `<#block name="sidebar">...</#block>` and route by zone.

*   **Internationalization**: pass `i18n` map and wrap strings with a helper.

*   **Performance**: cache templates/config, pre-resolve `dataPath` into concrete collections in backend (Freemarker doesnâ€™t natively parse JSONPath; materialize it beforehand).

***

If you share your **specific component types** and a **sample config** you want to support (e.g., forms, tables, detail views), I can tailor the components and layouts to your domain and provide a ready-to-run set.
