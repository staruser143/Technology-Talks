To design a **generic, reusable Java library** that merges JSON data into either **AcroForm-based PDF templates** or **FreeMarker-based HTML templates**, using a **YAML configuration** to define mappings, filters, and transformations, you can follow a **modular, extensible architecture** leveraging **Spring Boot auto-configuration**, **PDFBox**, **FreeMarker**, and **Jackson**.

Below is a comprehensive design and implementation guide.

---

## 🧱 High-Level Architecture

```
+---------------------+
|     Client App      |
+----------+----------+
           |
+----------v----------+
|   TemplateMerger    | ← Interface
+----------+----------+
           |
+----------v----------+
|  PDFMerger / HTMLMerger |
+----------+----------+
           |
+----------v----------+
|   DataMapper (YAML-driven) |
+---------------------+
```

---

## 📁 Project Structure (Library)

```
src/
├── main/
│   ├── java/
│   │   └── com.example.templatemerge/
│   │       ├── config/
│   │       │   ├── TemplateMergeAutoConfiguration.java
│   │       │   └── TemplateMergeProperties.java
│   │       ├── model/
│   │       │   ├── MergeConfig.java
│   │       │   ├── FieldMapping.java
│   │       │   ├── FilterCondition.java
│   │       │   └── TransformSpec.java
│   │       ├── service/
│   │       │   ├── TemplateMerger.java
│   │       │   ├── PdfTemplateMerger.java
│   │       │   ├── HtmlTemplateMerger.java
│   │       │   └── DataMapper.java
│   │       ├── transformer/
│   │       │   ├── TransformerRegistry.java
│   │       │   ├── BasicTransformers.java
│   │       │   └── CustomTransformer.java
│   │       └── exception/
│   │           └── TemplateMergeException.java
│   └── resources/
│       └── META-INF/
│           └── additional-spring-configuration-metadata.json
└── test/
```

---

## 📄 1. YAML Configuration Schema

Example `merge-config.yaml`:

```yaml
templateType: PDF  # or HTML
templatePath: classpath:templates/form.pdf
outputPath: /tmp/output.pdf
mappings:
  - sourceField: user.name
    targetField: full_name
    filters:
      - field: user.active
        operator: EQ
        value: true
    transforms:
      - type: uppercase
      - type: custom
        name: maskName
        params:
          maskChar: "*"
          visibleChars: 2
```

---

## 🧩 2. Configuration Models (POJOs)

### `MergeConfig.java`

```java
public class MergeConfig {
    private TemplateType templateType;
    private String templatePath;
    private String outputPath;
    private List<FieldMapping> mappings;

    // getters/setters
}
```

### `FieldMapping.java`

```java
public class FieldMapping {
    private String sourceField;     // dot-notation: user.address.city
    private String targetField;
    private List<FilterCondition> filters = new ArrayList<>();
    private List<TransformSpec> transforms = new ArrayList<>();
}
```

### `FilterCondition.java`

```java
public class FilterCondition {
    private String field;      // e.g., user.role
    private String operator;   // EQ, NE, GT, etc.
    private Object value;
}
```

### `TransformSpec.java`

```java
public class TransformSpec {
    private String type;       // "uppercase", "date", "custom", etc.
    private String name;       // for custom: bean name or class
    private Map<String, Object> params = new HashMap<>();
}
```

### `TemplateType.java`

```java
public enum TemplateType {
    PDF, HTML
}
```

---

## ⚙️ 3. Data Mapper with Filtering & Transformation

### `DataMapper.java`

```java
@Component
public class DataMapper {

    private final TransformerRegistry transformerRegistry;

    public DataMapper(TransformerRegistry transformerRegistry) {
        this.transformerRegistry = transformerRegistry;
    }

    public Map<String, Object> mapData(JsonNode jsonData, MergeConfig config) {
        Map<String, Object> result = new HashMap<>();

        for (FieldMapping mapping : config.getMappings()) {
            if (!passesFilters(jsonData, mapping.getFilters())) {
                continue;
            }

            JsonNode sourceValue = getValueByPath(jsonData, mapping.getSourceField());
            if (sourceValue == null || sourceValue.isNull()) {
                continue;
            }

            Object transformed = applyTransformations(sourceValue, mapping.getTransforms());
            result.put(mapping.getTargetField(), transformed);
        }

        return result;
    }

    private boolean passesFilters(JsonNode data, List<FilterCondition> filters) {
        return filters.stream().allMatch(f -> evaluateFilter(data, f));
    }

    private Object applyTransformations(JsonNode value, List<TransformSpec> transforms) {
        Object current = value.isTextual() ? value.asText() :
                         value.isNumber() ? value.asDouble() :
                         value.toString();

        for (TransformSpec t : transforms) {
            current = transformerRegistry.apply(t, current);
        }
        return current;
    }

    // Helper: get nested value using dot notation
    private JsonNode getValueByPath(JsonNode root, String path) {
        String[] parts = path.split("\\.");
        JsonNode current = root;
        for (String part : parts) {
            if (current.isObject()) {
                current = current.get(part);
            } else {
                return null;
            }
        }
        return current;
    }

    // Simplified filter evaluator (extend as needed)
    private boolean evaluateFilter(JsonNode data, FilterCondition cond) {
        JsonNode node = getValueByPath(data, cond.getField());
        if (node == null) return false;

        switch (cond.getOperator().toUpperCase()) {
            case "EQ": return node.asText().equals(cond.getValue().toString());
            case "NE": return !node.asText().equals(cond.getValue().toString());
            default: throw new UnsupportedOperationException("Operator not supported: " + cond.getOperator());
        }
    }
}
```

---

## 🧪 4. Transformer Registry

### `TransformerRegistry.java`

```java
@Component
public class TransformerRegistry {

    private final Map<String, Function<Object, Object>> builtInTransformers = new HashMap<>();
    private final ApplicationContext applicationContext;

    public TransformerRegistry(ApplicationContext applicationContext) {
        this.applicationContext = applicationContext;
        registerBuiltIns();
    }

    private void registerBuiltIns() {
        builtInTransformers.put("uppercase", input -> input.toString().toUpperCase());
        builtInTransformers.put("lowercase", input -> input.toString().toLowerCase());
        builtInTransformers.put("trim", input -> input.toString().trim());
        // Add more as needed
    }

    public Object apply(TransformSpec spec, Object input) {
        if ("custom".equals(spec.getType())) {
            CustomTransformer transformer = applicationContext.getBean(spec.getName(), CustomTransformer.class);
            return transformer.transform(input, spec.getParams());
        } else {
            Function<Object, Object> fn = builtInTransformers.get(spec.getType());
            if (fn == null) throw new IllegalArgumentException("Unknown transformer: " + spec.getType());
            return fn.apply(input);
        }
    }
}
```

### `CustomTransformer.java`

```java
public interface CustomTransformer {
    Object transform(Object input, Map<String, Object> params);
}
```

> Clients can implement this and register as Spring beans.

---

## 🖨️ 5. Template Merging Strategies

### `TemplateMerger.java`

```java
public interface TemplateMerger {
    void merge(JsonNode data, MergeConfig config) throws IOException;
}
```

### `PdfTemplateMerger.java`

```java
@Component
@ConditionalOnClass(PDDocument.class)
public class PdfTemplateMerger implements TemplateMerger {

    @Override
    public void merge(JsonNode data, MergeConfig config) throws IOException {
        try (PDDocument doc = PDDocument.load(ResourceUtils.getFile(config.getTemplatePath()))) {
            PDAcroForm form = doc.getDocumentCatalog().getAcroForm();
            if (form == null) {
                throw new IllegalStateException("No AcroForm in PDF");
            }

            DataMapper mapper = // inject via constructor
            Map<String, Object> mapped = mapper.mapData(data, config);

            for (Map.Entry<String, Object> entry : mapped.entrySet()) {
                PDField field = form.getField(entry.getKey());
                if (field != null) {
                    field.setValue(entry.getValue().toString());
                }
            }

            doc.save(config.getOutputPath());
        }
    }
}
```

### `HtmlTemplateMerger.java`

```java
@Component
@ConditionalOnClass(freemarker.template.Configuration.class)
public class HtmlTemplateMerger implements TemplateMerger {

    private final freemarker.template.Configuration fmConfig;

    public HtmlTemplateMerger() {
        fmConfig = new freemarker.template.Configuration(freemarker.template.Configuration.VERSION_2_3_31);
        fmConfig.setClassForTemplateLoading(HtmlTemplateMerger.class, "/templates");
        fmConfig.setDefaultEncoding("UTF-8");
    }

    @Override
    public void merge(JsonNode data, MergeConfig config) throws IOException {
        DataMapper mapper = // inject
        Map<String, Object> model = mapper.mapData(data, config);

        try (Writer fileWriter = new FileWriter(config.getOutputPath())) {
            Template template = fmConfig.getTemplate(new File(config.getTemplatePath()).getName());
            template.process(model, fileWriter);
        } catch (TemplateException e) {
            throw new IOException("FreeMarker error", e);
        }
    }
}
```

---

## 🧩 6. Main Service

### `TemplateMergeService.java`

```java
@Service
public class TemplateMergeService {

    private final Map<TemplateType, TemplateMerger> mergers;
    private final ObjectMapper objectMapper;

    public TemplateMergeService(List<TemplateMerger> mergerList, ObjectMapper objectMapper) {
        this.mergers = new HashMap<>();
        // Assume mergers are annotated with @Qualifier or use strategy pattern
        // For simplicity, inject both and map manually:
        // In real code, use custom annotation or registry
        // This is simplified:
        mergers.put(TemplateType.PDF, applicationContext.getBean(PdfTemplateMerger.class));
        mergers.put(TemplateType.HTML, applicationContext.getBean(HtmlTemplateMerger.class));
        this.objectMapper = objectMapper;
    }

    public void mergeFromJson(String json, MergeConfig config) throws IOException {
        JsonNode data = objectMapper.readTree(json);
        TemplateMerger merger = mergers.get(config.getTemplateType());
        if (merger == null) {
            throw new IllegalArgumentException("Unsupported template type: " + config.getTemplateType());
        }
        merger.merge(data, config);
    }

    public void mergeFromFile(Path jsonFile, Path yamlConfig) throws IOException {
        MergeConfig config = loadYamlConfig(yamlConfig);
        String json = Files.readString(jsonFile);
        mergeFromJson(json, config);
    }

    private MergeConfig loadYamlConfig(Path yamlPath) throws IOException {
        ObjectMapper yamlMapper = new ObjectMapper(new YAMLFactory());
        return yamlMapper.readValue(yamlPath.toFile(), MergeConfig.class);
    }
}
```

---

## 🌱 7. Spring Boot Auto-Configuration

### `TemplateMergeAutoConfiguration.java`

```java
@Configuration
@EnableConfigurationProperties(TemplateMergeProperties.class)
public class TemplateMergeAutoConfiguration {

    @Bean
    @ConditionalOnMissingBean
    public TemplateMergeService templateMergeService(ObjectMapper objectMapper, 
                                                     PdfTemplateMerger pdfMerger,
                                                     HtmlTemplateMerger htmlMerger) {
        // Register mergers in a map
        Map<TemplateType, TemplateMerger> mergers = Map.of(
            TemplateType.PDF, pdfMerger,
            TemplateType.HTML, htmlMerger
        );
        return new TemplateMergeService(mergers, objectMapper);
    }

    @Bean
    @ConditionalOnMissingBean
    public DataMapper dataMapper(TransformerRegistry registry) {
        return new DataMapper(registry);
    }

    @Bean
    @ConditionalOnMissingBean
    public TransformerRegistry transformerRegistry(ApplicationContext ctx) {
        return new TransformerRegistry(ctx);
    }
}
```

### `spring.factories` (for auto-config)

`src/main/resources/META-INF/spring.factories`:

```properties
org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
com.example.templatemerge.config.TemplateMergeAutoConfiguration
```

---

## 📦 8. Usage in Client Spring Boot App

### Add dependency:

```xml
<dependency>
  <groupId>com.example</groupId>
  <artifactId>template-merge-starter</artifactId>
  <version>1.0.0</version>
</dependency>
```

### Implement custom transformer (optional):

```java
@Component("maskName")
public class MaskNameTransformer implements CustomTransformer {
    @Override
    public Object transform(Object input, Map<String, Object> params) {
        String str = input.toString();
        int visible = (int) params.getOrDefault("visibleChars", 2);
        char mask = ((String) params.getOrDefault("maskChar", "*")).charAt(0);
        if (str.length() <= visible) return str;
        return str.substring(0, visible) + mask.repeat(str.length() - visible);
    }
}
```

### Use service:

```java
@Service
public class MyService {
    private final TemplateMergeService mergeService;

    public void generateDocument() throws IOException {
        Path json = Paths.get("data.json");
        Path yaml = Paths.get("merge-config.yaml");
        mergeService.mergeFromFile(json, yaml);
    }
}
```

---

## ✅ Benefits

- **Generic**: Works with any JSON → PDF/HTML.
- **Configurable**: All logic in YAML.
- **Extensible**: Add custom filters/transformers.
- **Spring Native**: Auto-config, beans, profiles.
- **Reusable**: Publish as JAR/Maven artifact.

---

## 🔒 Notes

- Use **Apache PDFBox 2.0+** (`org.apache.pdfbox:pdfbox`)
- Use **FreeMarker** (`org.freemarker:freemarker`)
- Handle **resource loading** (classpath vs file) carefully.
- Add **validation** (e.g., target field exists in PDF).
- Consider **thread safety** (FreeMarker config is thread-safe after init).

---

Let me know if you'd like a GitHub repo skeleton or unit test examples!