Absolutely! Below is a **robust, production-ready `DataMapper` implementation** that uses **[Jayway JsonPath](https://github.com/json-path/JsonPath)** to handle:

- Nested objects (`user.address.city`)
- Arrays (`orders[0].id`)
- Wildcards (`products[*].name`)
- Conditional filters (`employees[?(@.department == 'Engineering')].name`)
- Multiple matches (returns lists)
- Integration with **filters** and **transformations**

This `DataMapper` is designed to work with your YAML-based configuration and integrates cleanly into a Spring Boot library.

---

### ‚úÖ Dependencies (Maven)

```xml
<dependency>
    <groupId>com.jayway.jsonpath</groupId>
    <artifactId>json-path</artifactId>
    <version>2.9.0</version>
</dependency>
<dependency>
    <groupId>com.fasterxml.jackson.core</groupId>
    <artifactId>jackson-databind</artifactId>
</dependency>
```

---

### üß© Core Models (Recap)

Assume you already have:
- `MergeConfig`
- `FieldMapping`
- `FilterCondition`
- `TransformSpec`
- `CustomTransformer`

(See previous answer for definitions.)

---

### üß† Enhanced `DataMapper` with Full JsonPath Support

```java
package com.example.templatemerge.service;

import com.example.templatemerge.model.FieldMapping;
import com.example.templatemerge.model.FilterCondition;
import com.example.templatemerge.model.MergeConfig;
import com.example.templatemerge.model.TransformSpec;
import com.example.templatemerge.transformer.TransformerRegistry;
import com.jayway.jsonpath.JsonPath;
import com.jayway.jsonpath.PathNotFoundException;
import org.springframework.stereotype.Component;

import java.util.*;
import java.util.stream.Collectors;

@Component
public class DataMapper {

    private final TransformerRegistry transformerRegistry;

    public DataMapper(TransformerRegistry transformerRegistry) {
        this.transformerRegistry = transformerRegistry;
    }

    /**
     * Maps source JSON data to target fields based on MergeConfig.
     *
     * @param jsonData Parsed JSON object (Map, List, or Jackson JsonNode ‚Äî JsonPath accepts any)
     * @param config   Merge configuration from YAML
     * @return Map of targetField ‚Üí final value (always String-compatible)
     */
    public Map<String, Object> mapData(Object jsonData, MergeConfig config) {
        Map<String, Object> result = new HashMap<>();

        for (FieldMapping mapping : config.getMappings()) {
            // Step 1: Apply global filters (if any)
            if (!passesGlobalFilters(jsonData, mapping.getFilters())) {
                continue;
            }

            // Step 2: Extract source value using JsonPath
            Object rawValue = readJsonPathSafe(jsonData, mapping.getSourceField());
            if (rawValue == null) {
                // Optionally log or skip
                continue;
            }

            // Step 3: Apply transformations
            Object transformed = applyTransformations(rawValue, mapping.getTransforms());

            // Step 4: Ensure result is string-friendly (PDF/HTML fields are strings)
            result.put(mapping.getTargetField(), safeToString(transformed));
        }

        return result;
    }

    // ===== FILTERING =====

    private boolean passesGlobalFilters(Object jsonData, List<FilterCondition> filters) {
        if (filters == null || filters.isEmpty()) {
            return true;
        }

        return filters.stream().allMatch(filter -> {
            Object actualValue = readJsonPathSafe(jsonData, filter.getField());
            Object expectedValue = filter.getValue();

            if (actualValue == null) return false;

            // Normalize both sides to string for basic comparison (extend as needed)
            String actualStr = safeToString(actualValue);
            String expectedStr = safeToString(expectedValue);

            switch (filter.getOperator().toUpperCase()) {
                case "EQ":
                    return Objects.equals(actualStr, expectedStr);
                case "NE":
                    return !Objects.equals(actualStr, expectedStr);
                case "CONTAINS":
                    return actualStr.contains(expectedStr);
                case "IN": // expectedValue should be a comma-separated string or list
                    if (expectedValue instanceof List) {
                        return ((List<?>) expectedValue).contains(actualStr);
                    } else {
                        List<String> allowed = Arrays.stream(expectedStr.split(","))
                                .map(String::trim)
                                .collect(Collectors.toList());
                        return allowed.contains(actualStr);
                    }
                default:
                    throw new UnsupportedOperationException("Unsupported operator: " + filter.getOperator());
            }
        });
    }

    // ===== JSON PATH =====

    private Object readJsonPathSafe(Object jsonData, String jsonPath) {
        try {
            return JsonPath.read(jsonData, jsonPath);
        } catch (PathNotFoundException | IllegalArgumentException e) {
            // Path not found or invalid ‚Äî treat as null
            return null;
        }
    }

    // ===== TRANSFORMATIONS =====

    private Object applyTransformations(Object value, List<TransformSpec> transforms) {
        Object current = value;

        for (TransformSpec spec : transforms) {
            current = transformerRegistry.apply(spec, current);
        }

        return current;
    }

    // ===== UTILITIES =====

    private String safeToString(Object obj) {
        if (obj == null) return "";
        if (obj instanceof List) {
            // Default: join with comma (can be overridden via transform)
            return ((List<?>) obj).stream()
                    .map(item -> item == null ? "" : item.toString())
                    .collect(Collectors.joining(", "));
        }
        if (obj instanceof Map) {
            return obj.toString(); // or serialize as JSON if needed
        }
        return obj.toString();
    }
}
```

---

### üîÅ Enhanced `TransformerRegistry` (Support Collections)

Update your `TransformerRegistry` to handle **lists** gracefully:

```java
@Component
public class TransformerRegistry {

    private final Map<String, Function<Object, Object>> builtIn = new HashMap<>();
    private final ApplicationContext ctx;

    public TransformerRegistry(ApplicationContext ctx) {
        this.ctx = ctx;
        registerBuiltIns();
    }

    private void registerBuiltIns() {
        builtIn.put("uppercase", input -> toStringOrEmpty(input).toUpperCase());
        builtIn.put("lowercase", input -> toStringOrEmpty(input).toLowerCase());
        builtIn.put("trim", input -> toStringOrEmpty(input).trim());
        builtIn.put("join", input -> {
            String delimiter = ", ";
            if (input instanceof Map) {
                // Assume params passed via wrapper ‚Äî but in our design, params are in TransformSpec
                // So better: handle in custom transformer or pass params separately
                // For built-in, we'll assume default
            }
            return joinList(input, delimiter);
        });
        builtIn.put("first", TransformerRegistry::firstOf);
        builtIn.put("last", TransformerRegistry::lastOf);
    }

    public Object apply(TransformSpec spec, Object input) {
        if ("custom".equals(spec.getType())) {
            CustomTransformer transformer = ctx.getBean(spec.getName(), CustomTransformer.class);
            return transformer.transform(input, spec.getParams());
        } else {
            Function<Object, Object> fn = builtIn.get(spec.getType());
            if (fn == null) {
                throw new IllegalArgumentException("Unknown built-in transformer: " + spec.getType());
            }
            return fn.apply(input);
        }
    }

    // --- Helpers ---

    private static String toStringOrEmpty(Object o) {
        return o == null ? "" : o.toString();
    }

    private static Object firstOf(Object input) {
        if (input instanceof List && !((List<?>) input).isEmpty()) {
            return ((List<?>) input).get(0);
        }
        return input; // not a list ‚Üí return as-is
    }

    private static Object lastOf(Object input) {
        if (input instanceof List && !((List<?>) input).isEmpty()) {
            List<?> list = (List<?>) input;
            return list.get(list.size() - 1);
        }
        return input;
    }

    private static String joinList(Object input, String delimiter) {
        if (input instanceof List) {
            return ((List<?>) input).stream()
                    .map(TransformerRegistry::toStringOrEmpty)
                    .collect(Collectors.joining(delimiter));
        }
        return toStringOrEmpty(input);
    }
}
```

> üí° **Note**: For advanced `join` with custom delimiter, implement a **custom transformer**:
>
> ```java
> @Component("join")
> public class JoinTransformer implements CustomTransformer {
>     @Override
>     public Object transform(Object input, Map<String, Object> params) {
>         String delimiter = (String) params.getOrDefault("delimiter", ", ");
>         if (input instanceof List) {
>             return ((List<?>) input).stream()
>                     .map(obj -> obj == null ? "" : obj.toString())
>                     .collect(Collectors.joining(delimiter));
>         }
>         return input.toString();
>     }
> }
> ```
>
> Then in YAML:
> ```yaml
> transforms:
>   - type: custom
>     name: join
>     params:
>       delimiter: "; "
> ```

---

### üìÑ Example YAML with Nested Data & Arrays

```yaml
templateType: PDF
templatePath: classpath:invoice.pdf
outputPath: /tmp/invoice_filled.pdf
mappings:
  - sourceField: "$.customer.name"
    targetField: customer_name

  - sourceField: "$.items[*].description"
    targetField: item_descriptions
    transforms:
      - type: custom
        name: join
        params:
          delimiter: " | "

  - sourceField: "$.items[?(@.price > 100)].name"
    targetField: premium_items
    transforms:
      - type: custom
        name: join
        params:
          delimiter: ", "

  - sourceField: "$.metadata.tags"
    targetField: all_tags
    transforms:
      - type: join  # uses built-in (default comma)

  # Conditional mapping: only if order is shipped
  - sourceField: "$.trackingNumber"
    targetField: tracking_id
    filters:
      - field: "$.status"
        operator: EQ
        value: "shipped"
```

---

### üß™ Input JSON Example

```json
{
  "customer": {
    "name": "John Doe"
  },
  "items": [
    { "name": "Laptop", "description": "Dell XPS", "price": 1200 },
    { "name": "Mouse", "description": "Wireless", "price": 25 },
    { "name": "Monitor", "description": "4K", "price": 300 }
  ],
  "metadata": {
    "tags": ["urgent", "electronics", "2025"]
  },
  "status": "shipped",
  "trackingNumber": "TRK123456789"
}
```

### ‚úÖ Output Field Values

| Target Field        | Value                                      |
|---------------------|--------------------------------------------|
| `customer_name`     | `John Doe`                                 |
| `item_descriptions` | `Dell XPS | Wireless | 4K`                |
| `premium_items`     | `Laptop, Monitor`                          |
| `all_tags`          | `urgent, electronics, 2025`                |
| `tracking_id`       | `TRK123456789`                             |

---

### ‚úÖ Summary

This `DataMapper`:
- Uses **JsonPath** for powerful, standard-compliant data extraction.
- Handles **objects, arrays, wildcards, and filters** natively.
- Applies **global filters** before mapping.
- Supports **collection-aware transformations**.
- Produces **string-safe output** for PDF/HTML fields.
- Is **fully extensible** via custom transformers.

You can now process **any real-world JSON structure** with confidence.

Let me know if you'd like unit tests or a sample Spring Boot app demonstrating this!