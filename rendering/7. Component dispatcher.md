To achieve a truly "plug-and-play" document service, you use a **Component Dispatcher** pattern. This allows your YAML to act as a list of instructions, and your FreeMarker template to act as a factory that produces different UI components (tables, charts, text) on the fly.

### 1. The Generic Component Dispatcher (`main_renderer.ftl`)

This single template can render almost any page layout by iterating through the `components` list defined in your YAML.

```html
<#-- Import your library of UI components -->
<#import "components/tables.ftl" as tables>
<#import "components/charts.ftl" as charts>
<#import "components/text.ftl" as text>

<div class="page-container">
    <#list components as component>
        <div class="component-wrapper" style="margin-bottom: 20px;">
            <#-- Switch logic based on the "type" defined in YAML -->
            <#switch component.type>
                <#case "TABLE">
                    <@tables.render data=component.data config=component.config />
                    <#break>
                <#case "INFO_BOX">
                    <@text.renderInfoBox data=component.data />
                    <#break>
                <#case "BAR_CHART">
                    <@charts.renderBar data=component.data />
                    <#break>
                <#default>
                    <p>Unknown component type: ${component.type}</p>
            </#switch>
        </div>
    </#list>
</div>

```

---

### 2. The Declarative YAML (The Configuration)

Notice how the YAML defines the **structure** and **style** without touching the HTML. You can have one client want a table followed by a chart, and another client want two tables.

```yaml
pages:
  - id: "executive_summary"
    template: "main_renderer.ftl"
    components:
      - type: "INFO_BOX"
        data:
          title: "Account Status"
          message: "$.account.status_message"
          
      - type: "TABLE"
        config:
          columns: ["Date", "Description", "Amount"]
          theme: "compact-blue"
        data:
          rows: "$.transactions[?(@.amount > 1000)]" # Filtered data
          
      - type: "BAR_CHART"
        data: "$.monthly_stats"

```

---

### 3. The "Specialized" Component (`components/tables.ftl`)

Each sub-template (component) is also generic. It doesn't know what "Transactions" are; it only knows how to loop through a list of rows.

```html
<#macro render data config>
    <table class="generic-table ${config.theme!'default'}">
        <thead>
            <tr>
                <#list config.columns as col>
                    <th>${col}</th>
                </#list>
            </tr>
        </thead>
        <tbody>
            <#list data.rows as row>
                <tr>
                    <#-- We use dynamic keys here to pluck values from the row -->
                    <#list config.columns as col>
                        <td>${row[col?lower_case]!""}</td>
                    </#list>
                </tr>
            </#list>
        </tbody>
    </table>
</#macro>

```

---

### 4. Why this architecture is superior

| Feature | Imperative (Hardcoded) | Declarative (This Pattern) |
| --- | --- | --- |
| **New Client Onboarding** | Write new Java/FTL code. | Create 1 new YAML file. |
| **Adding a Page** | Change Java logic and recompile. | Add a new item to the `pages` list in YAML. |
| **Table Formatting** | Specific CSS for every table. | Pass a `theme` name in YAML to a generic CSS class. |
| **Maintenance** | Hundreds of scattered `.ftl` files. | 5-10 "Master Components" used by everyone. |

### Summary of Workflow

1. **Request comes in** with a `client_id`.
2. **Java Engine** loads the `client_id_config.yaml`.
3. **JSONPath** extracts the data pieces defined in each component.
4. **FreeMarker** loops through the components, "dispatching" each one to its macro.
5. **Output** is a perfectly tailored PDF for that specific client.

**Would you like to see how the Java code handles the "Component Extraction" loop to feed this specific FreeMarker structure?**