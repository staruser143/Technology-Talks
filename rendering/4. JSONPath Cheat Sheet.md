To make your YAML configuration truly powerful, you need to use **JSONPath** expressions that go beyond simple field selection. This allows the YAML to handle the "business logic" of transforming raw request data into a format the templates can easily consume.

### 1. JSONPath Cheat Sheet for Mapping

These expressions allow you to filter, aggregate, and select data directly in your YAML `data_mapping` section.

| Scenario | JSONPath Expression | Resulting Template Data |
| --- | --- | --- |
| **Deep Nesting** | `$.order.shipping.address.city` | A single string: "New York" |
| **Filtering** | `$.items[?(@.price > 100)]` | A list of objects where price > 100 |
| **Property Projection** | `$.items[*].sku` | A flat list of strings: `["A1", "B2"]` |
| **Array Slicing** | `$.items[:2]` | Only the first two items in the list |
| **Conditionals** | `$.customer[?(@.tier == 'VIP')]` | Empty or Populated list (used for page `condition`) |

---

### 2. Handling Calculations & Aggregations

While standard JSONPath (Jayway) is great for selection, sometimes you need to perform calculations. Most PDF engines handle this in one of two ways:

#### Option A: Extended JSONPath (Functions)

If your library supports it, you can perform math directly in the YAML:

```yaml
data_mapping:
  total_count: "$.items.length()"
  order_sum: "$.items[*].price.sum()"

```

#### Option B: The "Derived Data" Layer

If your JSONPath library is strictly for selection, you can add a `computed_fields` section to your YAML. Your Java processor would then evaluate these using an expression language like **SpEL (Spring Expression Language)** or **JEXL**.

```yaml
pages:
  - id: "invoice_page"
    data_mapping:
      raw_items: "$.items"
    computed_fields:
      # Logic handled by Java engine after extraction
      tax_amount: "raw_items.sum(price) * 0.15"
      is_eligible_for_discount: "raw_items.size() > 5"

```

---

### 3. Comprehensive Configuration Example

Here is how a complex, multi-page document looks when fully declarative. It mixes a standard **FreeMarker** page with a government **AcroForm** (PDF with fillable fields).

```yaml
document_specification:
  name: "Unified Compliance Report"
  
  pages:
    # Page 1: Dynamic FreeMarker Cover
    - id: "cover"
      template_type: "FREEMARKER"
      template_source: "templates/brand/cover_v2.ftl"
      data_mapping:
        client_name: "$.account.holder_name"
        report_date: "$.metadata.generated_at"

    # Page 2: Conditional Detailed Table
    - id: "transaction_log"
      template_type: "FREEMARKER"
      template_source: "templates/shared/table_grid.ftl"
      condition: "$.transactions.length() > 0"
      data_mapping:
        rows: "$.transactions[?(@.status == 'COMPLETED')]"
        columns: ["Date", "Description", "Amount"]

    # Page 3: Government AcroForm (Mapping JSON to PDF Fields)
    - id: "tax_form"
      template_type: "ACROFORM"
      template_source: "forms/irs_w9.pdf"
      # Mapping JSONPath to the actual field names inside the PDF form
      field_mapping:
        topmostSubform[0].Page1[0].f1_1[0]: "$.account.legal_name"
        topmostSubform[0].Page1[0].f1_2[0]: "$.account.tax_id"

```

---

### 4. Implementation Tip: The "Template Registry"

To avoid hardcoding paths in your Java code, create a simple `TemplateProvider` interface.

* Your **Java Engine** calls `templateProvider.get(page.getTemplateSource())`.
* This allows you to store templates in **S3, a Database, or the Classpath** without changing the core generation logic.

**Would you like me to show you how to handle the AcroForm field-filling logic in Java to complement the FreeMarker part?**