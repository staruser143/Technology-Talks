Below is a **formal, production-grade JSON Schema** for a **mapping specification**, followed by a **step-by-step explanation of how the document service uses it to build ViewModels**.

The design is intentionally:

* **Declarative**
* **Client-extensible**
* **Renderer-agnostic (AcroForm / FreeMarker)**
* **Safe for multi-tenant use**

---

# PART 1 — Formal JSON Schema (Mapping Specification)

### 1. Top-Level Mapping Spec Schema

```json
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "$id": "https://example.com/schema/document-mapping.json",
  "title": "Document Mapping Specification",
  "type": "object",
  "required": ["specVersion", "document"],
  "properties": {
    "specVersion": {
      "type": "string",
      "description": "Mapping spec version for compatibility checks"
    },
    "document": {
      "$ref": "#/$defs/document"
    }
  },
  "$defs": {
    "document": {
      "type": "object",
      "required": ["sections"],
      "properties": {
        "sections": {
          "type": "array",
          "items": { "$ref": "#/$defs/section" }
        }
      }
    },

    "section": {
      "type": "object",
      "required": ["type"],
      "properties": {
        "id": { "type": "string" },
        "type": {
          "type": "string",
          "enum": ["table", "text", "group"]
        },
        "visibleWhen": {
          "type": "string",
          "description": "Expression evaluated against request data"
        },
        "rowSource": { "$ref": "#/$defs/rowSource" },
        "columns": {
          "type": "array",
          "items": { "$ref": "#/$defs/column" }
        },
        "value": {
          "type": "string",
          "description": "For text sections"
        },
        "sections": {
          "type": "array",
          "items": { "$ref": "#/$defs/section" }
        }
      },
      "allOf": [
        {
          "if": { "properties": { "type": { "const": "table" } } },
          "then": { "required": ["rowSource", "columns"] }
        },
        {
          "if": { "properties": { "type": { "const": "text" } } },
          "then": { "required": ["value"] }
        }
      ]
    },

    "rowSource": {
      "type": "object",
      "required": ["type"],
      "properties": {
        "type": {
          "type": "string",
          "enum": ["path"]
        },
        "path": {
          "type": "string",
          "description": "Bean/JSON path resolving to a collection"
        }
      }
    },

    "column": {
      "type": "object",
      "required": ["name", "label"],
      "properties": {
        "name": { "type": "string" },
        "label": { "type": "string" },
        "field": {
          "type": "string",
          "description": "Field path relative to row object"
        },
        "format": {
          "type": "string",
          "description": "Optional formatter key"
        },
        "nestedTable": {
          "$ref": "#/$defs/nestedTable"
        }
      },
      "oneOf": [
        { "required": ["field"] },
        { "required": ["nestedTable"] }
      ]
    },

    "nestedTable": {
      "type": "object",
      "required": ["rowSource", "columns"],
      "properties": {
        "rowSource": { "$ref": "#/$defs/rowSource" },
        "columns": {
          "type": "array",
          "items": { "$ref": "#/$defs/column" }
        }
      }
    }
  }
}
```

---

# PART 2 — Example Mapping Spec (Client-Provided)

```json
{
  "specVersion": "1.0",
  "document": {
    "sections": [
      {
        "id": "coverageTable",
        "type": "table",
        "visibleWhen": "$.hasCoverage == true",
        "rowSource": {
          "type": "path",
          "path": "coverages"
        },
        "columns": [
          {
            "name": "coverageType",
            "label": "Coverage",
            "field": "type"
          },
          {
            "name": "benefits",
            "label": "Benefits",
            "nestedTable": {
              "rowSource": {
                "type": "path",
                "path": "benefits"
              },
              "columns": [
                {
                  "name": "code",
                  "label": "Code",
                  "field": "code"
                },
                {
                  "name": "desc",
                  "label": "Description",
                  "field": "description"
                }
              ]
            }
          }
        ]
      }
    ]
  }
}
```

---

# PART 3 — How the Service Uses This to Create ViewModels

This is the **critical execution pipeline**.

---

## 1. Request Lifecycle Overview

```
HTTP Request
 ├── Request Data (JSON)
 ├── Mapping Spec (JSON)
 └── Template ID
        ↓
Spec Validation (JSON Schema)
        ↓
ViewModel Construction
        ↓
Renderer (FTL / AcroForm)
        ↓
PDF Output
```

---

## 2. Step 1 — Parse & Validate Spec

```java
MappingSpec spec = objectMapper.readValue(json, MappingSpec.class);
schemaValidator.validate(spec);
```

If invalid → **fail fast**.

---

## 3. Step 2 — Build Context (Execution Boundary)

```java
BuildContext context = new BuildContext(
    requestData,
    new BeanFieldExtractor(),
    new ExpressionEvaluator()
);
```

This isolates:

* Data access
* Expression execution
* Formatting

Clients never touch this.

---

## 4. Step 3 — Document Builder (Recursive)

```java
public DocumentViewModel buildDocument(
        MappingSpec spec,
        BuildContext context) {

    DocumentViewModel doc = new DocumentViewModel();

    for (SectionSpec section : spec.getDocument().getSections()) {
        RenderNode node = buildSection(section, context, context.getRequestData());
        if (node != null) {
            doc.getSections().add(node);
        }
    }
    return doc;
}
```

---

## 5. Step 4 — Section Builder (Dispatcher)

```java
private RenderNode buildSection(
        SectionSpec spec,
        BuildContext ctx,
        Object data) {

    if (!visible(spec, ctx, data)) {
        return null;
    }

    return switch (spec.getType()) {
        case "table" -> buildTable(spec, ctx, data);
        case "text"  -> buildText(spec, ctx, data);
        case "group" -> buildGroup(spec, ctx, data);
        default -> throw new IllegalStateException();
    };
}
```

---

## 6. Step 5 — Table ViewModel Builder

```java
private TableViewModel buildTable(
        SectionSpec spec,
        BuildContext ctx,
        Object root) {

    Collection<?> rows =
        (Collection<?>) ctx.extractor()
            .extract(root, spec.getRowSource().getPath());

    TableViewModel table = new TableViewModel();
    table.setColumns(buildColumns(spec.getColumns()));

    for (Object rowObj : rows) {
        TableViewModel.Row row = new TableViewModel.Row();

        for (ColumnSpec col : spec.getColumns()) {
            Cell cell = buildCell(col, ctx, rowObj);
            row.getCells().put(col.getName(), cell);
        }
        table.getRows().add(row);
    }
    return table;
}
```

---

## 7. Step 6 — Nested Table Handling (Recursive)

```java
private Cell buildCell(
        ColumnSpec col,
        BuildContext ctx,
        Object rowObj) {

    if (col.getNestedTable() != null) {
        TableViewModel nested =
            buildNestedTable(col.getNestedTable(), ctx, rowObj);
        return new Cell(nested);
    }

    Object value =
        ctx.extractor().extract(rowObj, col.getField());

    return new Cell(value);
}
```

---

## 8. Key Guarantees This Provides

| Concern               | How it is handled        |
| --------------------- | ------------------------ |
| Client-specific logic | Declarative spec         |
| Security              | No client code execution |
| Extensibility         | New section/column types |
| AcroForm / FTL        | Same ViewModel           |
| Nested tables         | Recursive builders       |
| Validation            | JSON Schema              |
| Versioning            | `specVersion`            |

---

## 9. Why This Works Long-Term

* The **schema is the contract**
* The **service owns execution**
* Clients only declare intent
* ViewModel stays stable for years
* Templates do not encode business rules

This is the same pattern used in:

* Insurance document platforms
* Banking statement generators
* ERP form engines
* Enterprise reporting systems

---

## 10. Recommended Next Steps

If you want, I can:

1. Provide **Java POJOs generated from this schema**
2. Add **AcroForm-specific extensions**
3. Define **expression grammar and sandboxing**
4. Show **error reporting mapped back to spec lines**
5. Provide **unit tests for the builder pipeline**

Tell me which one you want next.
