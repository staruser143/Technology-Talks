Yes — **exactly**.
What you are describing is **precisely** what is meant by *runtime ViewModel objects*.

The JSON spec is **not** rendered directly.
It is **interpreted** by the engine to produce an **in-memory object graph** that FreeMarker (or AcroForm) can render safely and generically.

Below is a **clear, concrete explanation** of what these runtime ViewModels are, why they exist, and how the engine builds and uses them.

---

## 1. Three Distinct Artifacts (Do Not Conflate Them)

| Artifact                             | Purpose                  | Lifetime          |
| ------------------------------------ | ------------------------ | ----------------- |
| **Rendering Spec (JSON)**            | Declarative instructions | Stored, versioned |
| **Runtime ViewModel (Java objects)** | Concrete renderable data | Per request       |
| **Template (FTL / PDF)**             | Presentation             | Static            |

The runtime ViewModel is **ephemeral** and **request-scoped**.

---

## 2. What “Runtime ViewModel” Actually Means

A **runtime ViewModel** is:

* A **fully resolved**
* **Renderer-friendly**
* **Template-agnostic**
* **Immutable (ideally)**

object graph.

By the time FreeMarker sees it:

* All conditions are resolved
* All preprocessing is done
* All iteration is flattened
* All nesting is explicit
* No business logic remains

---

## 3. Conceptual Transformation

```
Spec + Request Data
        ↓
Runtime ViewModel
        ↓
FreeMarker Rendering
```

FreeMarker **never sees**:

* Raw request JSON
* Expressions
* Paths
* Conditions
* Spec structure

---

## 4. Canonical Runtime ViewModel Structure

At minimum, you should have something like this:

```java
class DocumentVM {
    List<PageVM> pages;
}

class PageVM {
    String layout;
    List<RenderNodeVM> nodes;
}

interface RenderNodeVM {
    String getType();
}
```

Concrete nodes:

```java
class TableVM implements RenderNodeVM {
    List<ColumnVM> columns;
    List<RowVM> rows;
}

class TextVM implements RenderNodeVM {
    String value;
}
```

Nested content is **natural**, not inferred.

---

## 5. How This Looks in Memory (Example)

From the 5-page spec you saw:

```
DocumentVM
 ├── PageVM(layout=cover-page)
 │     ├── TextVM("Enrollment Summary")
 │     ├── TextVM("John Doe")
 │     └── TextVM("2026-01-09")
 ├── PageVM(layout=two-column)
 │     └── TableVM(applicantInfo)
 ├── PageVM(layout=full-width)
 │     └── TableVM(dependentsTable)
 ├── PageVM(layout=full-width)
 │     └── TableVM(coverageTable)
 │           └── Cell → TableVM(benefits)
 └── PageVM(layout=addendum)
 │     ├── TextVM(...)
 │     └── TextVM(...)
```

This is what FreeMarker walks.

---

## 6. Why This Is Absolutely Necessary

### Without Runtime ViewModel

* Templates need logic
* Specs leak into templates
* Hard to test
* Impossible to support AcroForm cleanly

### With Runtime ViewModel

* Templates are stable
* Specs are flexible
* Rendering is deterministic
* Multi-renderer support is trivial

---

## 7. Engine Responsibility (Clear Boundary)

The engine must:

1. Parse spec
2. Validate spec
3. Preprocess data
4. Evaluate visibility
5. Expand rows
6. Build nested structures
7. Produce runtime ViewModel

Once this is done, **the engine’s job is over**.

---

## 8. FreeMarker’s Responsibility (Very Small)

FreeMarker only:

* Iterates lists
* Prints values
* Calls recursive macros

No conditionals tied to business meaning.

---

## 9. Example: Building a Runtime Table ViewModel

```java
TableVM table = new TableVM();

for (Object rowObj : rows) {
    RowVM row = new RowVM();

    for (ColumnSpec col : spec.getColumns()) {
        Object value = extractOrBuildNested(col, rowObj);
        row.getCells().put(col.getName(), value);
    }

    table.getRows().add(row);
}
```

At this point:

* No spec knowledge remains
* Only concrete values and nested VMs exist

---

## 10. Naming Matters (Avoid Confusion)

I strongly recommend **explicit naming**:

| Thing                | Suggested Name |
| -------------------- | -------------- |
| Spec objects         | `*Spec`        |
| Runtime view objects | `*VM`          |
| Builders             | `*Builder`     |

This avoids accidental coupling.

---

## 11. Answering Your Question Directly

> **Is this what you are referring to as runtime ViewModel objects?**

**Yes. Exactly this.**

They are:

* Created at runtime
* Derived from spec + data
* Passed to FTL
* Never persisted
* Never modified by templates

---

## 12. If You Want to Go Deeper Next

I can:

1. Walk through **exact Java classes** for `DocumentVM`, `PageVM`, `TableVM`
2. Show **FTL templates consuming these VMs**
3. Explain **how AcroForm rendering consumes the same VM**
4. Discuss **immutability, caching, and performance**
5. Show **debug tooling to inspect runtime VMs**

Tell me which one you want next.
