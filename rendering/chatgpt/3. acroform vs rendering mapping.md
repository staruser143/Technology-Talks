Short answer first, then the full reasoning:

> **Yes — the AcroForm field-mapping spec should be a separate but coordinated spec from the rendering/layout spec.**
> They must be **composed**, not merged.

Merging them will create long-term rigidity and make your service very hard to evolve.

Below is the **formal architectural model**, the **why**, and **how the service composes both specs at runtime**.

---

## 1. Why This Must Be Separate

Rendering specs and AcroForm mapping specs answer **different questions**:

| Concern               | Answers                     | Example                      |
| --------------------- | --------------------------- | ---------------------------- |
| Rendering spec        | *What* to render and *when* | tables, sections, visibility |
| AcroForm mapping spec | *Where* to place values     | PDF field names              |

Trying to encode both in one spec causes:

* Template leakage into data logic
* Spec explosion for every layout change
* Tight coupling between PDF geometry and business rules

This is exactly what you want to avoid in a multi-client service.

---

## 2. Correct Mental Model

Think in **three layers**, not two:

```
Request Data
     ↓
Canonical ViewModel  ← (Rendering Spec)
     ↓
Output Mapping       ← (AcroForm Spec)
     ↓
PDF
```

The **ViewModel is the pivot point**.

---

## 3. Spec Responsibilities (Clean Separation)

### 3.1 Rendering / ViewModel Spec (Already Defined)

* Sections, tables, nesting
* Conditions (`visibleWhen`)
* Repetition (`rowSource`)
* Formatting
* Logical structure

Produces:

```
DocumentViewModel
```

---

### 3.2 AcroForm Mapping Spec (New, Separate)

* PDF template identifier
* AcroForm field names
* Row-to-field replication rules
* Overflow / addendum behavior

Consumes:

```
DocumentViewModel
```

---

## 4. Formal JSON Schema — AcroForm Mapping Spec

### 4.1 Top-Level Schema

```json
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "$id": "https://example.com/schema/acroform-mapping.json",
  "title": "AcroForm Mapping Specification",
  "type": "object",
  "required": ["templateId", "bindings"],
  "properties": {
    "templateId": {
      "type": "string",
      "description": "PDF AcroForm template identifier"
    },
    "bindings": {
      "type": "array",
      "items": { "$ref": "#/$defs/binding" }
    }
  },
  "$defs": {
    "binding": {
      "type": "object",
      "required": ["source", "target"],
      "properties": {
        "source": {
          "$ref": "#/$defs/sourceRef"
        },
        "target": {
          "$ref": "#/$defs/targetRef"
        }
      }
    },

    "sourceRef": {
      "type": "object",
      "required": ["path"],
      "properties": {
        "path": {
          "type": "string",
          "description": "Path into the ViewModel"
        }
      }
    },

    "targetRef": {
      "type": "object",
      "required": ["field"],
      "properties": {
        "field": {
          "type": "string",
          "description": "AcroForm field name"
        },
        "repeat": {
          "type": "object",
          "properties": {
            "index": { "type": "integer" },
            "overflow": {
              "type": "string",
              "enum": ["addendum", "truncate"]
            }
          }
        }
      }
    }
  }
}
```

---

## 5. Example AcroForm Mapping Spec

```json
{
  "templateId": "coverage_form_v3",
  "bindings": [
    {
      "source": {
        "path": "sections.coverageTable.rows[0].cells.coverageType"
      },
      "target": {
        "field": "coverage_type_1"
      }
    },
    {
      "source": {
        "path": "sections.coverageTable.rows[*].cells.coverageType"
      },
      "target": {
        "field": "coverage_type_${index}",
        "repeat": {
          "overflow": "addendum"
        }
      }
    }
  ]
}
```

---

## 6. How the Service Uses Both Specs Together

### Step-by-Step Execution

```
1. Validate Rendering Spec
2. Build ViewModel
3. Validate AcroForm Mapping Spec
4. Resolve ViewModel Paths
5. Bind Values to PDF Fields
6. Handle Overflow (Addendum Pages)
7. Flatten PDF
```

---

## 7. ViewModel Path Resolution

The AcroForm spec never accesses **request data directly**.

```java
Object value = viewModelNavigator.resolve(
    viewModel,
    "sections.coverageTable.rows[2].cells.coverageType"
);
```

This ensures:

* Stable mapping even if source data changes
* AcroForm tied to logical structure, not raw input

---

## 8. Handling Repeating Fields

```json
"path": "sections.coverageTable.rows[*].cells.coverageType"
```

Service logic:

```java
List<Object> values = navigator.resolveAll(path);

for (int i = 0; i < values.size(); i++) {
    pdf.setField(
        "coverage_type_" + (i + 1),
        values.get(i)
    );
}
```

Overflow behavior is spec-driven.

---

## 9. Why This Is Superior to One Unified Spec

| Concern              | Unified Spec              | Separate Specs  |
| -------------------- | ------------------------- | --------------- |
| Layout change        | Requires remapping fields | No impact       |
| New renderer         | Breaks spec               | Reuse ViewModel |
| Testing              | Hard                      | Independent     |
| Client customization | Risky                     | Safe            |
| Versioning           | Coupled                   | Independent     |

---

## 10. Versioning Strategy (Strongly Recommended)

```json
{
  "renderSpecVersion": "1.1",
  "acroformSpecVersion": "2.0"
}
```

The service validates compatibility.

---

## 11. When Would You Merge Them?

Only if:

* You will **never support FreeMarker**
* You have **exactly one PDF template per doc**
* You accept tight coupling

That is rarely true in enterprise systems.

---

## 12. Final, Direct Answer

> **Should AcroForm field mapping be separate from rendering spec?**

**Yes. Absolutely. By design.**

They:

* Serve different responsibilities
* Change at different rates
* Must be versioned independently
* Are composed at runtime via a ViewModel

---

## 13. What This Unlocks

* Same ViewModel → HTML, PDF, email
* Same AcroForm → different request schemas
* Client-specific layouts without code changes
* Safe multi-tenant document generation

---

## 14. Recommended Next Topics

If you want, I can:

1. Define a **ViewModel path grammar**
2. Show **addendum page generation in PDFBox**
3. Provide **validation rules between both specs**
4. Design **error reporting back to client**
5. Show **migration from legacy field mappings**

Tell me which one you want next.
