Your understanding is **partially correct**, but it is **not sufficient for the problem space you are solving**.

A **plain key–value map is necessary, but not sufficient**.
What I am referring to as a **runtime ViewModel (VM)** is **richer than a flat map**, even though **both FreeMarker and AcroForm ultimately consume key–value pairs**.

Let me clarify this precisely and reconcile it with your mental model.

---

## 1. What You Are Correct About

Yes:

* **AcroForm** ultimately needs:

  ```text
  fieldName → value
  ```
* **FreeMarker** can render:

  ```ftl
  ${someKey}
  ```

At the **lowest level**, everything resolves to key–value pairs.

---

## 2. Where the Map-Only Model Breaks Down

A *flat map* fails as soon as you introduce:

1. Repeating data (tables, lists)
2. Conditional sections
3. Nested tables
4. Multi-page layouts
5. Addendum / overflow pages
6. Multiple renderers using the same structure

Example problem:

```json
{
  "dependentName": "John",
  "dependentName": "Mary"   // not representable
}
```

Or:

* Which dependents belong to which page?
* Which benefits belong to which coverage?
* How do you render nested tables?

A map cannot express **structure**, **order**, or **grouping**.

---

## 3. Correct Mental Model

Think in **layers**, not binaries.

```
Request Data
   ↓
Runtime ViewModel (STRUCTURED)
   ↓
Renderer-Specific Projection
   ↓
Key–Value Map (FLAT)
```

The **VM is structured**.
The **map is a projection of the VM**.

---

## 4. What the Runtime ViewModel Actually Is

A runtime VM is a **structured object graph**:

```java
DocumentVM
 ├── PageVM
 │     ├── TextVM
 │     ├── TableVM
 │     │     ├── RowVM
 │     │     │     └── CellVM (value or nested TableVM)
```

This VM:

* Encodes **layout**
* Preserves **ordering**
* Captures **nesting**
* Represents **repetition**

---

## 5. Why FreeMarker Appears to “Just Use a Map”

FreeMarker is deceptive here.

Internally, FreeMarker happily walks:

* Java beans
* Lists
* Maps
* Nested object graphs

Example:

```ftl
<#list document.pages as page>
  <#list page.sections as section>
    ${section.value}
  </#list>
</#list>
```

This is **not a flat map** — it is an object graph.

---

## 6. Why AcroForm Also Needs More Than a Map

While AcroForm field filling is map-based, **how that map is produced** requires structure.

Example:

* Coverage table has 7 rows
* PDF has 3 slots
* Remaining rows go to addendum pages

That logic **cannot be expressed by a map alone**.

The VM drives:

* Field repetition
* Overflow rules
* Page duplication

The final output **is** a map — but it is a *derived* map.

---

## 7. Concrete Example

### Runtime ViewModel (Conceptual)

```
CoverageTableVM
 ├── Row[0] → Medical
 ├── Row[1] → Dental
 ├── Row[2] → Vision
 ├── Row[3] → Life
```

### AcroForm Projection

```json
{
  "coverage_1": "Medical",
  "coverage_2": "Dental",
  "coverage_3": "Vision"
}
```

Remaining rows → addendum.

The **VM decides**, the map **executes**.

---

## 8. When a Simple Map Is Enough

A flat map is sufficient **only if**:

* Single page
* No repetition
* No nesting
* No overflow
* No conditional structure

This is rarely true beyond trivial forms.

---

## 9. Correct Terminology (Important)

| Term              | Meaning                          |
| ----------------- | -------------------------------- |
| Runtime ViewModel | Structured object graph          |
| Render Context    | Root object passed to FTL        |
| Field Map         | Final flattened map for AcroForm |
| Spec              | Declarative instructions         |

Conflating VM and map leads to fragile designs.

---

## 10. How Both Renderers Use the Same VM

| Renderer   | Consumes           |
| ---------- | ------------------ |
| FreeMarker | VM object graph    |
| AcroForm   | VM → flattened map |

Same VM, different projections.

---

## 11. Answering Your Question Directly

> **Is the key–value map what you are referring to as VM here?**

**No.**

* The **key–value map is a derived artifact**
* The **VM is the structured source of truth**

The map exists **because** the VM exists.

---

## 12. Practical Recommendation

Implement **both**, explicitly:

```java
DocumentVM vm = buildFromSpec(spec, request);
Map<String, Object> acroMap = flatten(vm, acroSpec);
```

This gives you:

* Clarity
* Testability
* Extensibility
* Renderer independence

---

## 13. Final Mental Shortcut

> **VM = structure + data**
> **Map = data only**

You need both.

---

If you want next, I can:

* Show a **concrete flattening algorithm**
* Provide **FreeMarker examples consuming the VM**
* Show **how to debug VM vs map mismatches**
* Explain **performance tradeoffs**

Tell me which one you want next.
