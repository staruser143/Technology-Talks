To make your service truly "logic-less" in Java, your engine needs a **Transformation Layer**. This layer sits between the raw JSON data and the FreeMarker template. When the engine parses the YAML, it looks for specific "Operations" (like `GROUP_BY` or `SUM`) and executes them dynamically.

Here is how you can implement a generic **GroupBy** and **Sum** processor.

### 1. The "Smart" YAML Specification

Instead of a simple string mapping, we use a structured mapping that tells the Java engine what to do.

```yaml
pages:
  - id: "category_summary"
    template: "nested_tables.ftl"
    data_mapping:
      - name: "sales_report"
        source: "$.transactions"
        # The Java engine sees this and triggers the GroupBy logic
        operation: "GROUP_BY"
        group_by_field: "category" 
        # Optional: Sort the groups alphabetically
        sort: "ASC"
      
      - name: "grand_total"
        source: "$.transactions[*].amount"
        operation: "SUM"

```

---

### 2. The Java Implementation (The Transformer)

This code uses `Jayway JsonPath` to grab the data and then uses standard Java Streams to group it. Because it uses reflection/Map keys, it works for **any** field name provided in the YAML.

```java
public class DataTransformer {

    public Map<String, Object> transform(List<MappingInstruction> instructions, DocumentContext jsonContext) {
        Map<String, Object> model = new HashMap<>();

        for (MappingInstruction instr : instructions) {
            Object rawData = jsonContext.read(instr.getSource());

            Object processedData = switch (instr.getOperation()) {
                case "GROUP_BY" -> groupBy((List<Map<String, Object>>) rawData, instr.getGroupByField());
                case "SUM" -> sum((List<Number>) rawData);
                case "NONE" -> rawData;
                default -> rawData;
            };

            model.put(instr.getName(), processedData);
        }
        return model;
    }

    private Object groupBy(List<Map<String, Object>> data, String field) {
        // Dynamically groups the list of maps by the value of the specified field
        return data.stream()
                   .collect(Collectors.groupingBy(it -> it.get(field)));
    }

    private Double sum(List<Number> numbers) {
        return numbers.stream().mapToDouble(Number::doubleValue).sum();
    }
}

```

---

### 3. The Resulting Data Structure

If your raw JSON was a flat list of transactions, the `DataTransformer` turns it into this structured Map for FreeMarker:

```json
{
  "sales_report": {
    "Electronics": [ {"id": 1, "amt": 50}, {"id": 2, "amt": 150} ],
    "Home": [ {"id": 3, "amt": 20} ]
  },
  "grand_total": 220.0
}

```

---

### 4. The Generic FreeMarker Template

Now your template can simply loop through the keys (the categories) and the values (the list of items in that category).

```html
<#list sales_report?keys as category>
    <h2>Category: ${category}</h2>
    <table>
        <thead>
            <tr><th>ID</th><th>Amount</th></tr>
        </thead>
        <tbody>
            <#list sales_report[category] as item>
                <tr>
                    <td>${item.id}</td>
                    <td>${item.amt}</td>
                </tr>
            </#list>
        </tbody>
    </table>
</#list>

<p><strong>Total:</strong> ${grand_total}</p>

```

---

### Why this is the "Gold Standard" for Document Services:

1. **Data Isolation:** The FreeMarker template doesn't need to know how to calculate a sum or how to group items. It just renders what is given.
2. **No Java Deployments:** If a client wants to group by "Region" instead of "Category," you change one word in the YAML.
3. **Extensibility:** You can add new operations (e.g., `AVERAGE`, `COUNT`, `DATE_FORMAT`) to the Java `switch` statement once, and they become available to all clients via YAML.

### Summary of the Flow

1. **YAML** defines the "Plan" (e.g., "Group $transactions by 'category'").
2. **Java Engine** executes the "Plan" using Streams and JsonPath.
3. **FreeMarker** receives the "Perfect Model" and just handles the HTML tags.

**Would you like me to help you define the `MappingInstruction` POJO and the YAML parser configuration to get this started in your project?**