To implement this, you need a clean way to bridge your YAML configuration to your Java logic. We will use **Jackson** to map the YAML into a Java object and then use those instructions to drive the data transformation.

### 1. The Mapping Models (POJOs)

These classes represent the structure of your YAML. Using `@JsonTypeInfo` allows you to expand your list of operations (Sum, GroupBy, Filter, etc.) without changing your core parser.

```java
public class DocumentManifest {
    private List<PageSpec> pages;
    // Getters and Setters
}

public class PageSpec {
    private String id;
    private String template;
    private String condition;
    private List<MappingInstruction> dataMapping;
    // Getters and Setters
}

public class MappingInstruction {
    private String name;        // The variable name in FreeMarker
    private String source;      // The JSONPath expression
    private String operation;   // NONE, GROUP_BY, SUM, COUNT, etc.
    private String groupByField; // Only used if operation is GROUP_BY
    // Getters and Setters
}

```

---

### 2. The Generic Data Processor

This is the "brain" of your service. It takes the instructions from the YAML and applies them to the raw JSON request.

```java
public class GenericDataProcessor {
    
    public Map<String, Object> prepareTemplateData(PageSpec page, String requestJson) {
        DocumentContext ctx = JsonPath.parse(requestJson);
        Map<String, Object> templateData = new HashMap<>();

        for (MappingInstruction instr : page.getDataMapping()) {
            // 1. Fetch the raw data using JSONPath
            Object rawData = ctx.read(instr.getSource());

            // 2. Transform the data based on the operation
            Object processedData = switch (instr.getOperation().toUpperCase()) {
                case "GROUP_BY" -> performGroupBy((List<Map<String, Object>>) rawData, instr.getGroupByField());
                case "SUM"      -> performSum((List<? extends Number>) rawData);
                case "COUNT"    -> ((List<?>) rawData).size();
                default         -> rawData; // "NONE" or simple mapping
            };

            // 3. Put into the map for FreeMarker
            templateData.put(instr.getName(), processedData);
        }
        return templateData;
    }

    private Map<Object, List<Map<String, Object>>> performGroupBy(List<Map<String, Object>> data, String field) {
        return data.stream().collect(Collectors.groupingBy(m -> m.get(field)));
    }

    private Double performSum(List<? extends Number> numbers) {
        return numbers.stream().mapToDouble(Number::doubleValue).sum();
    }
}

```

---

### 3. Parsing the YAML

Using Jackson with the YAML factory makes loading the configuration trivial.

```java
ObjectMapper mapper = new ObjectMapper(new YAMLFactory());
DocumentManifest manifest = mapper.readValue(new File("client_config.yaml"), DocumentManifest.class);

```

---

### 4. Handling AcroForms Dynamically

If a client wants an AcroForm instead of FreeMarker, the same `MappingInstruction` logic applies, but instead of putting data into a Map for a template, you write it to the PDF fields.

```java
if (page.getType().equals("ACROFORM")) {
    PdfReader reader = new PdfReader(page.getTemplateSource());
    PdfDocument pdf = new PdfDocument(reader, new PdfWriter(outputStream));
    PdfAcroForm form = PdfAcroForm.getAcroForm(pdf, true);

    Map<String, Object> data = processor.prepareTemplateData(page, requestJson);
    
    data.forEach((fieldName, value) -> {
        form.getField(fieldName).setValue(value.toString());
    });
    
    pdf.close();
}

```

### Why this works for your complex requirements:

1. **Nested Tables:** By using `GROUP_BY`, you create a Map of Lists. Your FreeMarker template then uses a nested `<#list>` to render a table inside a table.
2. **Different Layouts:** The `PageSpec` can include a `layoutType` or `cssOverride` field that you pass to the template to change the look and feel.
3. **Zero Coding for Changes:** If a client wants to change a "Total Price" to a "Total Quantity," you just change the JSONPath in the YAML from `$.items[*].price` to `$.items[*].quantity`.

**Would you like me to create a sample project structure or a Maven/Gradle configuration with the necessary dependencies (Jackson, JsonPath, FreeMarker, iText/OpenPDF) to get this running?**