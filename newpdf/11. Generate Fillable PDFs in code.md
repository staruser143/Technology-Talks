Great question! Generating **fillable PDFs programmatically** is essential for reliable, repeatable testing ‚Äî especially when you need fields like `PrimaryApplicant.FName.1`, `Dependent.FName.1`, etc.

Below is a **complete, self-contained Java solution** using **Apache PDFBox** to **create a test PDF with form fields** matching your naming convention.

---

## ‚úÖ Why Generate PDFs Programmatically?

- No manual PDF creation (error-prone, not version-controllable)
- Fields match your exact naming (`{entity}.{field}.{index}`)
- Easy to generate variants (e.g., with 5 dependent slots)
- Perfect for **automated tests**

---

## üì¶ Dependencies (Already in your `pom.xml`)

You only need **PDFBox** (already included):

```xml
<dependency>
  <groupId>org.apache.pdfbox</groupId>
  <artifactId>pdfbox</artifactId>
  <version>3.0.2</version>
</dependency>
```

---

## üß™ Step 1: Create a PDF Generator Utility

### `TestPdfGenerator.java`

```java
import org.apache.pdfbox.pdmodel.PDDocument;
import org.apache.pdfbox.pdmodel.PDPage;
import org.apache.pdfbox.pdmodel.common.PDRectangle;
import org.apache.pdfbox.pdmodel.font.PDType1Font;
import org.apache.pdfbox.pdmodel.interactive.form.PDAcroForm;
import org.apache.pdfbox.pdmodel.interactive.form.PDTextField;

import java.io.IOException;
import java.nio.file.Path;

public class TestPdfGenerator {

    /**
     * Generates a test PDF with form fields for primary applicant and N dependent slots.
     *
     * @param outputPath Path to save the PDF
     * @param maxDependents Number of dependent slots (e.g., 3 ‚Üí fields .1, .2, .3)
     */
    public static void generateTestPdf(Path outputPath, int maxDependents) throws IOException {
        try (PDDocument document = new PDDocument()) {
            PDPage page = new PDPage(PDRectangle.A4);
            document.addPage(page);

            PDAcroForm acroForm = new PDAcroForm(document);
            document.getDocumentCatalog().setAcroForm(acroForm);

            // Set default font
            acroForm.setDefaultResources(acroForm.getDefaultResources());
            acroForm.setDefaultAppearance("/Helv 12 Tf 0 0 0 rg");

            float yStart = 750;
            float lineHeight = 30;
            float xLabel = 50;
            float xField = 200;

            // Primary Applicant Fields
            addLabelAndField(document, acroForm, page, xLabel, yStart, "Primary Applicant First Name:", "PrimaryApplicant.FName.1", xField);
            addLabelAndField(document, acroForm, page, xLabel, yStart - lineHeight, "Primary Applicant Last Name:", "PrimaryApplicant.LName.1", xField);

            // Dependent Fields
            float y = yStart - 3 * lineHeight;
            for (int i = 1; i <= maxDependents; i++) {
                addLabelAndField(document, acroForm, page, xLabel, y, "Dependent " + i + " First Name:", "Dependent.FName." + i, xField);
                y -= lineHeight;
                addLabelAndField(document, acroForm, page, xLabel, y, "Dependent " + i + " Last Name:", "Dependent.LName." + i, xField);
                y -= lineHeight;

                // Nested: Address fields (2 per dependent)
                addLabelAndField(document, acroForm, page, xLabel, y, "Dependent " + i + " Addr Street:", "Dependent.Addr.Street." + i + ".1", xField);
                y -= lineHeight;
                addLabelAndField(document, acroForm, page, xLabel, y, "Dependent " + i + " Addr City:", "Dependent.Addr.City." + i + ".1", xField);
                y -= lineHeight;
            }

            document.save(outputPath.toFile());
        }
    }

    private static void addLabelAndField(
        PDDocument doc,
        PDAcroForm form,
        PDPage page,
        float xLabel,
        float y,
        String labelText,
        String fieldName,
        float xField
    ) throws IOException {
        // Add label (non-interactive text)
        var content = page.getContentStream();
        if (content == null) {
            content = new org.apache.pdfbox.pdmodel.PDPageContentStream(doc, page);
        }
        content.beginText();
        content.setFont(PDType1Font.HELVETICA, 12);
        content.newLineAtOffset(xLabel, y);
        content.showText(labelText);
        content.endText();

        // Add form field
        PDTextField field = new PDTextField(form);
        field.setPartialName(fieldName);
        var widget = field.getWidgets().get(0);
        widget.setRectangle(new PDRectangle(xField, y - 12, 200, 20));
        widget.setPage(page);
        widget.setPrinted(true);
        form.getFields().add(field);
        page.getAnnotations().add(widget);
    }

    // For testing
    public static void main(String[] args) throws IOException {
        generateTestPdf(java.nio.file.Paths.get("test-template.pdf"), 3);
        System.out.println("Test PDF generated: test-template.pdf");
    }
}
```

> ‚úÖ This creates a **real fillable PDF** with:
> - `PrimaryApplicant.FName.1`, `PrimaryApplicant.LName.1`
> - `Dependent.FName.1`, `Dependent.LName.1`, ..., up to `maxDependents`
> - Nested address fields: `Dependent.Addr.Street.1.1`, `Dependent.Addr.City.1.1`, etc.

---

## üß™ Step 2: Use in Your Test Setup

### Update `PdfFormFillerIntegrationTest.java`

```java
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.io.TempDir;
import java.nio.file.Path;

class PdfFormFillerIntegrationTest {

    @TempDir
    Path tempDir; // JUnit provides clean temp dir per test

    private Path testPdf;
    private Path testData;
    private Path testMapping;
    private Path outputPdf;

    @BeforeEach
    void setUp() throws Exception {
        // Generate test PDF
        testPdf = tempDir.resolve("template.pdf");
        TestPdfGenerator.generateTestPdf(testPdf, 3); // 3 dependents

        // Write test data
        testData = tempDir.resolve("data.json");
        Files.writeString(testData, """
            {
              "primaryApplicant": { "firstName": "john" },
              "dependents": [
                {
                  "firstName": "Alice",
                  "includeInForm": true,
                  "addresses": [{ "street": "123 Main St", "city": "NYC" }]
                }
              ]
            }
            """);

        // Write test mapping
        testMapping = tempDir.resolve("mapping.yaml");
        Files.writeString(testMapping, """
            fields:
              - pdf_field: "PrimaryApplicant.FName.1"
                json_path: "$.primaryApplicant.firstName"
                transform: "uppercase"
              - repeat: true
                json_array_path: "$.dependents"
                condition: "$.includeInForm == true"
                items:
                  - pdf_field: "Dependent.FName.{index}"
                    json_path: "$.firstName"
                  - repeat: true
                    json_array_path: "$.addresses"
                    items:
                      - pdf_field: "Dependent.Addr.Street.{parent_index}.{index}"
                        json_path: "$.street"
                      - pdf_field: "Dependent.Addr.City.{parent_index}.{index}"
                        json_path: "$.city"
            """);

        outputPdf = tempDir.resolve("output.pdf");
    }

    @Test
    void fillsGeneratedPdfCorrectly() throws Exception {
        PdfFormFiller.fillForm(
            testPdf.toString(),
            testData.toString(),
            testMapping.toString(),
            outputPdf.toString()
        );

        // Validate
        try (var doc = PDDocument.load(outputPdf.toFile())) {
            var form = doc.getDocumentCatalog().getAcroForm();
            assertThat(form.getField("PrimaryApplicant.FName.1").getValueAsString())
                .isEqualTo("JOHN");
            assertThat(form.getField("Dependent.FName.1").getValueAsString())
                .isEqualTo("Alice");
            assertThat(form.getField("Dependent.Addr.Street.1.1").getValueAsString())
                .isEqualTo("123 Main St");
        }
    }
}
```

> ‚úÖ **No external files needed** ‚Äî everything is generated at test runtime!

---

## üîç What This Gives You

| Benefit | Description |
|-------|-------------|
| **Reproducible** | Same PDF every time |
| **Version-controlled** | Generator code lives in Git |
| **Flexible** | Change `maxDependents` per test |
| **CI/CD friendly** | Runs anywhere with Java |
| **No manual steps** | Fully automated |

---

## üõ†Ô∏è Tips & Extensions

### 1. **Add more field types**
```java
// Checkbox example
PDCheckbox checkbox = new PDCheckbox(acroForm);
checkbox.setPartialName("AgreeToTerms");
```

### 2. **Support multiline fields**
```java
field.setMultiline(true);
```

### 3. **Add validation in generator**
```java
if (maxDependents < 0 || maxDependents > 10) {
    throw new IllegalArgumentException("Reasonable limit");
}
```

### 4. **Generate multiple pages**
```java
PDPage page2 = new PDPage();
document.addPage(page2);
// add fields to page2
```

---

## ‚ñ∂Ô∏è Run It

1. Compile:
   ```bash
   mvn compile
   ```
2. Generate a test PDF (optional):
   ```bash
   java -cp target/classes TestPdfGenerator
   ```
3. Run tests:
   ```bash
   mvn test
   ```

---

You now have a **fully automated, self-contained testing pipeline**:
- ‚úÖ Generate PDFs on-the-fly
- ‚úÖ Populate with real data
- ‚úÖ Validate output programmatically

This is how **professional PDF processing systems** are tested! Let me know if you'd like to add **checkboxes**, **dropdowns**, or **digital signatures** to your test PDFs.
