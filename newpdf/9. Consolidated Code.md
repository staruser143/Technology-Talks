Absolutely! Below is the **complete, consolidated, production-ready Java code** that supports:

âœ… Single-value fields  
âœ… Repeating fields with **1-based indexing**  
âœ… **Conditional repeats** (`condition`)  
âœ… **Max repeat limit** (`max_items`)  
âœ… **Nested repeats** (with `{index}` and `{parent_index}` placeholders)  
âœ… **YAML + Jackson** config  
âœ… **JsonPath** for nested JSON  
âœ… **Apache PDFBox 3.x**  
âœ… **Java 17+ records & sealed classes**

---

### ðŸ“¦ `pom.xml` (Maven Dependencies)

```xml
<project>
  <modelVersion>4.0.0</modelVersion>
  <groupId>com.example</groupId>
  <artifactId>pdf-form-filler</artifactId>
  <version>1.0</version>

  <properties>
    <maven.compiler.release>17</maven.compiler.release>
  </properties>

  <dependencies>
    <!-- PDFBox -->
    <dependency>
      <groupId>org.apache.pdfbox</groupId>
      <artifactId>pdfbox</artifactId>
      <version>3.0.2</version>
    </dependency>

    <!-- Jackson for YAML/JSON -->
    <dependency>
      <groupId>com.fasterxml.jackson.core</groupId>
      <artifactId>jackson-databind</artifactId>
      <version>2.17.2</version>
    </dependency>
    <dependency>
      <groupId>com.fasterxml.jackson.dataformat</groupId>
      <artifactId>jackson-dataformat-yaml</artifactId>
      <version>2.17.2</version>
    </dependency>

    <!-- JsonPath for nested queries -->
    <dependency>
      <groupId>com.jayway.jsonpath</groupId>
      <artifactId>json-path</artifactId>
      <version>2.9.0</version>
    </dependency>
  </dependencies>
</project>
```

---

### ðŸ“„ `PdfFormFiller.java` (Complete Code)

```java
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;
import com.jayway.jsonpath.JsonPath;
import com.jayway.jsonpath.PathNotFoundException;

import org.apache.pdfbox.pdmodel.PDDocument;
import org.apache.pdfbox.pdmodel.interactive.form.PDAcroForm;
import org.apache.pdfbox.pdmodel.interactive.form.PDField;

import java.io.File;
import java.math.BigDecimal;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.text.NumberFormat;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.stream.Collectors;

public class PdfFormFiller {

    // ===== CONFIGURATION RECORDS =====

    public record MappingConfig(List<FieldOrBlock> fields) {}

    public sealed interface FieldOrBlock permits SingleField, RepeatBlock {}

    public record SingleField(
        String pdf_field,
        String json_path,
        String transform,
        Boolean multi,
        String delimiter
    ) implements FieldOrBlock {
        public SingleField {
            if (multi == null) multi = false;
            if (delimiter == null || delimiter.isEmpty()) delimiter = ", ";
        }
    }

    public record RepeatBlock(
        String json_array_path,
        String condition,      // optional: JsonPath expr that must be true
        Integer max_items,     // optional: max number of items to process
        List<FieldOrBlock> items
    ) implements FieldOrBlock {
        public RepeatBlock {
            if (max_items == null) max_items = Integer.MAX_VALUE;
            if (items == null) items = List.of();
        }
    }

    // ===== CONTEXT FOR NESTED REPEATS =====

    private static class FillContext {
        final String itemJson;
        final int index;
        final Integer parentIndex;

        FillContext(String itemJson, int index, Integer parentIndex) {
            this.itemJson = itemJson;
            this.index = index;
            this.parentIndex = parentIndex;
        }
    }

    // ===== MAIN ENTRY POINT =====

    public static void main(String[] args) throws Exception {
        String jsonText = Files.readString(Paths.get("data.json"));
        ObjectMapper yamlMapper = new ObjectMapper(new YAMLFactory());
        MappingConfig config = yamlMapper.readValue(new File("mapping.yaml"), MappingConfig.class);

        try (PDDocument document = PDDocument.load(new File("template.pdf"))) {
            PDAcroForm form = document.getDocumentCatalog().getAcroForm();
            if (form == null) {
                throw new IllegalStateException("PDF contains no form fields.");
            }

            for (FieldOrBlock block : config.fields()) {
                if (block instanceof SingleField single) {
                    fillSingleField(form, jsonText, single);
                } else if (block instanceof RepeatBlock repeat) {
                    fillRepeatBlock(form, jsonText, repeat, null); // top-level
                }
            }

            document.save("filled_form.pdf");
        }
    }

    // ===== SINGLE FIELD HANDLING =====

    private static void fillSingleField(PDAcroForm form, String jsonText, SingleField field) {
        String value = evaluateJsonPath(jsonText, field.json_path(), field.multi());
        String transformed = applyTransform(value, field.transform());
        setPdfField(form, field.pdf_field(), transformed);
    }

    // ===== REPEATING BLOCK HANDLING (RECURSIVE) =====

    private static void fillRepeatBlock(PDAcroForm form, String rootJson, RepeatBlock block, Integer parentIndex) {
        try {
            Object arrayObj = JsonPath.read(rootJson, block.json_array_path());
            if (!(arrayObj instanceof List)) {
                System.err.println("Expected JSON array at: " + block.json_array_path());
                return;
            }

            List<?> array = (List<?>) arrayObj;
            int processCount = Math.min(array.size(), block.max_items());

            for (int i = 0; i < processCount; i++) {
                Object item = array.get(i);
                String itemJson = toJsonString(item);

                // Apply condition (if specified)
                if (block.condition() != null && !block.condition().isEmpty()) {
                    try {
                        String wrapper = "{\"item\":" + itemJson + "}";
                        boolean include = JsonPath.read(wrapper, "$.item" + block.condition().substring(1));
                        if (!Boolean.TRUE.equals(include)) {
                            continue;
                        }
                    } catch (Exception e) {
                        System.err.println("Condition evaluation failed for item " + (i + 1) + ": " + e.getMessage());
                        continue;
                    }
                }

                FillContext ctx = new FillContext(itemJson, i + 1, parentIndex);
                fillBlockItems(form, ctx, block.items());
            }
        } catch (PathNotFoundException e) {
            System.err.println("JsonPath not found (repeat block): " + block.json_array_path());
        } catch (Exception e) {
            System.err.println("Error processing repeat block: " + e.getMessage());
        }
    }

    private static void fillBlockItems(PDAcroForm form, FillContext ctx, List<FieldOrBlock> items) {
        for (FieldOrBlock item : items) {
            if (item instanceof SingleField field) {
                String value = evaluateRelativeJsonPath(ctx.itemJson, field.json_path());
                String transformed = applyTransform(value, field.transform());
                String pdfName = resolvePdfFieldName(field.pdf_field(), ctx);
                setPdfField(form, pdfName, transformed);
            } else if (item instanceof RepeatBlock repeat) {
                fillRepeatBlock(form, ctx.itemJson, repeat, ctx.index);
            }
        }
    }

    // ===== UTILITY METHODS =====

    private static String toJsonString(Object obj) {
        try {
            return new ObjectMapper().writeValueAsString(obj);
        } catch (Exception e) {
            // Fallback for non-serializable objects (should not happen with JsonPath)
            return "\"" + String.valueOf(obj).replace("\"", "\\\"") + "\"";
        }
    }

    private static String evaluateJsonPath(String json, String jsonPath, boolean multi) {
        try {
            Object result = JsonPath.read(json, jsonPath);
            if (multi) {
                List<?> list = (result instanceof List) ? (List<?>) result : Arrays.asList(result);
                return list.stream()
                    .map(PdfFormFiller::toStringSafe)
                    .filter(s -> !s.isEmpty())
                    .collect(Collectors.joining("\n"));
            } else {
                if (result instanceof List) {
                    List<?> list = (List<?>) result;
                    return list.isEmpty() ? "" : toStringSafe(list.get(0));
                }
                return toStringSafe(result);
            }
        } catch (Exception e) {
            return "";
        }
    }

    private static String evaluateRelativeJsonPath(String itemJson, String relativePath) {
        try {
            String wrapper = "{\"item\":" + itemJson + "}";
            Object result = JsonPath.read(wrapper, "$.item" + relativePath.substring(1));
            return toStringSafe(result);
        } catch (Exception e) {
            return "";
        }
    }

    private static String resolvePdfFieldName(String template, FillContext ctx) {
        String result = template.replace("{index}", String.valueOf(ctx.index));
        if (ctx.parentIndex != null) {
            result = result.replace("{parent_index}", String.valueOf(ctx.parentIndex));
        }
        // Extend here for deeper nesting if needed, e.g., {root_index}
        return result;
    }

    private static void setPdfField(PDAcroForm form, String fieldName, String value) {
        PDField field = form.getField(fieldName);
        if (field != null) {
            field.setValue(value);
        } else {
            System.err.println("PDF field not found: " + fieldName);
        }
    }

    private static String toStringSafe(Object obj) {
        return obj == null ? "" : obj.toString();
    }

    private static String applyTransform(String value, String transformSpec) {
        if (transformSpec == null || transformSpec.isEmpty()) return value;
        value = value.trim();

        if ("uppercase".equals(transformSpec)) {
            return value.toUpperCase();
        } else if ("lowercase".equals(transformSpec)) {
            return value.toLowerCase();
        } else if (transformSpec.startsWith("date:")) {
            String pattern = transformSpec.substring(5);
            try {
                LocalDate date = LocalDate.parse(value);
                return date.format(DateTimeFormatter.ofPattern(pattern));
            } catch (Exception e) {
                return "INVALID_DATE";
            }
        } else if (transformSpec.startsWith("currency:")) {
            String localeTag = transformSpec.substring(9);
            try {
                Number number = new BigDecimal(value);
                Locale locale = Locale.forLanguageTag(localeTag);
                return NumberFormat.getCurrencyInstance(locale).format(number);
            } catch (Exception e) {
                return "INVALID_CURRENCY";
            }
        } else if (transformSpec.startsWith("boolean:")) {
            String[] parts = transformSpec.substring(8).split("\\|", -1);
            boolean boolVal = Boolean.parseBoolean(value);
            return boolVal ? (parts.length > 0 ? parts[0] : "true") : (parts.length > 1 ? parts[1] : "false");
        }
        return value;
    }
}
```

---

### ðŸ“„ Example `mapping.yaml`

```yaml
fields:
  - pdf_field: "PrimaryApplicant.FName.1"
    json_path: "$.primaryApplicant.firstName"
    transform: "uppercase"

  - pdf_field: "PrimaryApplicant.LName.1"
    json_path: "$.primaryApplicant.lastName"
    transform: "uppercase"

  - repeat: true
    json_array_path: "$.dependents"
    condition: "$.includeInForm == true"
    max_items: 5
    items:
      - pdf_field: "Dependent.FName.{index}"
        json_path: "$.firstName"
      - pdf_field: "Dependent.LName.{index}"
        json_path: "$.lastName"

      - repeat: true
        json_array_path: "$.addresses"
        max_items: 3
        items:
          - pdf_field: "Dependent.Addr.Street.{parent_index}.{index}"
            json_path: "$.street"
          - pdf_field: "Dependent.Addr.City.{parent_index}.{index}"
            json_path: "$.city"
```

---

### ðŸ“„ Example `data.json`

```json
{
  "primaryApplicant": {
    "firstName": "john",
    "lastName": "doe"
  },
  "dependents": [
    {
      "firstName": "Alice",
      "lastName": "Doe",
      "includeInForm": true,
      "addresses": [
        { "street": "123 Main St", "city": "New York" },
        { "street": "456 Park Ave", "city": "New York" }
      ]
    },
    {
      "firstName": "Bob",
      "lastName": "Smith",
      "includeInForm": false,
      "addresses": [ ... ]
    }
  ]
}
```

---

### âœ… How to Run

1. Place `template.pdf`, `data.json`, and `mapping.yaml` in your project root.
2. Build and run with Java 17+:
   ```bash
   mvn compile exec:java -Dexec.mainClass=PdfFormFiller
   ```
3. Output: `filled_form.pdf`

---

### ðŸ”’ Notes

- **PDF fields must exist** in the template (e.g., `Dependent.FName.1`, `.2`, etc.)
- **Indexing is 1-based** to match your PDF convention
- **Nested repeats** support 2 levels out of the box (`{index}`, `{parent_index}`)
- **Conditions** use JsonPath relative to each array item
- **Safe defaults**: missing paths/fields â†’ empty string, no crash

---

You now have a **fully featured, extensible PDF form filler** ready for real-world use! Let me know if you need help with **testing**, **logging**, or **command-line arguments**.