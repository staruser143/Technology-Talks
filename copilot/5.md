Excellent â€” letâ€™s take the macro + YAML registry idea one step further and make it purely dataâ€‘driven. Instead of hardcoding if/else in the dispatcher, weâ€™ll let the YAML specify the macro name, and the Java side will inject both the registry and the macro library into Freemarker.  

---

ğŸ“‘ YAML Schema (layoutRegistry.yaml)

`yaml
layoutRegistry:
  - id: header
    macro: header
    field: title

  - id: description
    macro: paragraph
    field: description

  - id: itemsTable
    macro: table
    field: items
    columns:
      - name: Item
      - name: Value

  - id: footer
    macro: footer
    field: footerText
`

---

ğŸ› ï¸ Macro Library (macros.ftl)

`ftl
<#macro header data>
  <h1>${data}</h1>
</#macro>

<#macro paragraph data>
  <p>${data}</p>
</#macro>

<#macro table rows columns>
  <table border="1">
    <tr>
      <#list columns as col>
        <th>${col.name}</th>
      </#list>
    </tr>
    <#list rows as row>
      <tr>
        <td>${row.item}</td>
        <td>${row.value}</td>
      </tr>
    </#list>
  </table>
</#macro>

<#macro footer data>
  <footer>${data}</footer>
</#macro>
`

---

ğŸ› ï¸ Dispatcher Template (dispatcher.ftl)

Hereâ€™s the trick: instead of branching, we dynamically resolve the macro name from YAML and call it.

`ftl
<#import "macros.ftl" as layouts>

<#list layoutRegistry as block>
  <#-- Use dynamic macro invocation -->
  <@layouts[block.macro]
      data=model[block.field]!
      rows=model[block.field]!
      columns=block.columns! />
</#list>
`

ğŸ‘‰ Freemarker allows you to call macros dynamically using layouts[block.macro].  
This means the dispatcher doesnâ€™t need to know which macros exist â€” it just trusts the registry.

---

ğŸ› ï¸ Java Loader with Jackson (Spring Boot)

`java
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;
import org.springframework.stereotype.Component;

import java.io.InputStream;

@Component
public class LayoutRegistryLoader {

    private final LayoutRegistry registry;

    public LayoutRegistryLoader() throws Exception {
        ObjectMapper mapper = new ObjectMapper(new YAMLFactory());
        try (InputStream is = getClass().getResourceAsStream("/layoutRegistry.yaml")) {
            this.registry = mapper.readValue(is, LayoutRegistry.class);
        }
    }

    public LayoutRegistry getRegistry() {
        return registry;
    }
}
`

---

ğŸ› ï¸ Controller to Inject Registry + Data

`java
@Controller
public class DocumentController {

    private final LayoutRegistryLoader loader;

    public DocumentController(LayoutRegistryLoader loader) {
        this.loader = loader;
    }

    @GetMapping("/render")
    public String render(Model model) {
        Map<String, Object> businessData = Map.of(
            "title", "Dynamic Report",
            "description", "Generated at runtime",
            "items", List.of(Map.of("item", "A", "value", 10),
                             Map.of("item", "B", "value", 20)),
            "footerText", "Confidential"
        );

        model.addAttribute("model", businessData);
        model.addAttribute("layoutRegistry", loader.getRegistry().getLayoutRegistry());
        return "dispatcher"; // Freemarker template
    }
}
`

---

ğŸ”„ Flow Visualization

`mermaid
flowchart TD
    YAML[Layout Schema Registry] --> Loader[Jackson Loader]
    Loader --> SpringModel[Spring Model]
    SpringModel --> Dispatcher[dispatcher.ftl]
    Dispatcher --> Macros[macros.ftl]
    Model[Business Data] --> Dispatcher
    Macros --> Output[Rendered Layout]
`

---

âœ… Benefits
- No branching in dispatcher â†’ macros are resolved dynamically.
- Registry-driven orchestration â†’ YAML decides which macro to call.
- Plug-and-play extensibility â†’ add a new macro + YAML entry, no code changes.
- Auditability â†’ YAML is the single source of truth.

---

ğŸ‘‰ Sridhar, this gives you a true registry-driven dispatcher: YAML defines the orchestration, macros encapsulate rendering, and Freemarker dynamically invokes them. Would you like me to also show how to validate the YAML against a schema (JSON Schema or Jackson validation) so governance teams can ensure only approved block types/macros are used?