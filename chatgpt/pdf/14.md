Excellent üëç ‚Äî this will complete your **unified PDF generation framework**, with a **generic Freemarker-based HTML processor** that mirrors the AcroFormProcessor‚Äôs capabilities ‚Äî including:

‚úÖ YAML-driven mapping
‚úÖ Support for arrays and nested objects
‚úÖ Generic `groupBy` handling with `{group}` and `{index}` placeholders
‚úÖ No domain-specific assumptions
‚úÖ Direct PDF rendering via OpenHTMLToPDF

---

## üß© Updated `FreemarkerHtmlProcessor.java`

```java
package com.example.pdfgen.processor;

import com.example.pdfgen.config.FieldMapping;
import com.example.pdfgen.config.PdfMappingConfig;
import com.example.pdfgen.util.YamlConfigLoader;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import freemarker.template.Configuration;
import freemarker.template.Template;
import freemarker.template.TemplateExceptionHandler;
import com.openhtmltopdf.pdfboxout.PdfRendererBuilder;

import java.io.*;
import java.nio.charset.StandardCharsets;
import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.StreamSupport;

public class FreemarkerHtmlProcessor {

    private final ObjectMapper mapper = new ObjectMapper();

    public void generatePdf(File htmlTemplateFile, File jsonDataFile, File yamlMappingFile, File outputPdf) throws Exception {
        PdfMappingConfig config = YamlConfigLoader.load(yamlMappingFile.getAbsolutePath());
        JsonNode jsonData = mapper.readTree(jsonDataFile);

        // Build the model data for Freemarker
        Map<String, Object> templateData = buildTemplateData(config.getMappings(), jsonData);

        // Setup Freemarker configuration
        Configuration cfg = new Configuration(Configuration.VERSION_2_3_32);
        cfg.setDirectoryForTemplateLoading(htmlTemplateFile.getParentFile());
        cfg.setDefaultEncoding("UTF-8");
        cfg.setTemplateExceptionHandler(TemplateExceptionHandler.RETHROW_HANDLER);

        Template template = cfg.getTemplate(htmlTemplateFile.getName());
        StringWriter writer = new StringWriter();
        template.process(templateData, writer);

        String htmlContent = writer.toString();

        // Convert HTML ‚Üí PDF using OpenHTMLToPDF
        try (OutputStream os = new FileOutputStream(outputPdf)) {
            PdfRendererBuilder builder = new PdfRendererBuilder();
            builder.useFastMode();
            builder.withHtmlContent(htmlContent, htmlTemplateFile.getParentFile().toURI().toString());
            builder.toStream(os);
            builder.run();
        }
    }

    /**
     * Builds the Freemarker model by flattening and grouping JSON data
     * according to YAML mapping configuration.
     */
    private Map<String, Object> buildTemplateData(List<FieldMapping> mappings, JsonNode jsonData) {
        Map<String, Object> model = new HashMap<>();

        for (FieldMapping mapping : mappings) {
            processMapping(mapping, jsonData, model);
        }

        return model;
    }

    private void processMapping(FieldMapping mapping, JsonNode jsonData, Map<String, Object> model) {
        String source = mapping.getSource();

        if (source.endsWith("[]")) {
            String arrayPath = source.substring(0, source.length() - 2);
            JsonNode arrayNode = jsonData.at("/" + arrayPath.replace('.', '/'));
            if (arrayNode == null || !arrayNode.isArray()) return;

            if (mapping.getGroupBy() != null) {
                processGroupedArray(mapping, arrayNode, model);
            } else {
                processFlatArray(mapping, arrayNode, model);
            }
        } else {
            JsonNode valueNode = jsonData.at("/" + source.replace('.', '/'));
            if (!valueNode.isMissingNode()) {
                model.put(mapping.getTarget(), valueNode.asText());
            }
        }
    }

    private void processFlatArray(FieldMapping mapping, JsonNode arrayNode, Map<String, Object> model) {
        List<Map<String, Object>> list = new ArrayList<>();
        int index = 1;

        for (JsonNode element : arrayNode) {
            Map<String, Object> item = new HashMap<>();
            if (mapping.getFields() == null) continue;

            for (FieldMapping field : mapping.getFields()) {
                JsonNode valNode = element.path(field.getSource());
                if (!valNode.isMissingNode()) {
                    String key = field.getTarget().replace("{index}", String.valueOf(index));
                    item.put(key, valNode.asText());
                }
            }

            list.add(item);
            index++;
        }

        // Add array to model using base name
        String baseKey = mapping.getSource().replace("[]", "");
        model.put(baseKey, list);
    }

    private void processGroupedArray(FieldMapping mapping, JsonNode arrayNode, Map<String, Object> model) {
        String groupBy = mapping.getGroupBy();
        String transform = mapping.getGroupTransform();

        Map<String, List<JsonNode>> grouped = StreamSupport.stream(arrayNode.spliterator(), false)
                .filter(JsonNode::isObject)
                .collect(Collectors.groupingBy(node -> node.path(groupBy).asText()));

        for (Map.Entry<String, List<JsonNode>> groupEntry : grouped.entrySet()) {
            String groupValue = applyTransform(groupEntry.getKey(), transform);
            List<JsonNode> groupItems = groupEntry.getValue();

            List<Map<String, Object>> groupData = new ArrayList<>();
            for (int i = 0; i < groupItems.size(); i++) {
                JsonNode element = groupItems.get(i);
                int index = i + 1;
                Map<String, Object> item = new HashMap<>();

                if (mapping.getFields() == null) continue;
                for (FieldMapping field : mapping.getFields()) {
                    JsonNode valNode = element.path(field.getSource());
                    if (!valNode.isMissingNode()) {
                        String key = field.getTarget()
                                .replace("{group}", groupValue)
                                .replace("{index}", String.valueOf(index));
                        item.put(key, valNode.asText());
                    }
                }

                groupData.add(item);
            }

            model.put(groupValue, groupData);
        }
    }

    private String applyTransform(String value, String transform) {
        if (value == null) return "";
        if (transform == null) return value;

        switch (transform.toLowerCase(Locale.ROOT)) {
            case "lower":
                return value.toLowerCase(Locale.ROOT);
            case "upper":
                return value.toUpperCase(Locale.ROOT);
            case "snake":
                return value.replaceAll("\\s+", "_").toLowerCase(Locale.ROOT);
            case "camel":
                return Character.toLowerCase(value.charAt(0)) + value.substring(1);
            default:
                return value;
        }
    }
}
```

---

## üß© Example YAML (Same as AcroForm)

```yaml
template:
  name: "ApplicantForm"
  type: "freemarker"

mappings:
  - source: applicantList[]
    groupBy: relationship
    groupTransform: lower
    fields:
      - source: fname
        target: "{group}.fname.{index}"
      - source: lname
        target: "{group}.lname.{index}"
```

---

## üß© Example JSON

```json
{
  "applicantList": [
    { "relationship": "Primary", "fname": "John", "lname": "Doe" },
    { "relationship": "Spouse", "fname": "Jane", "lname": "Doe" },
    { "relationship": "Child", "fname": "Sara", "lname": "Doe" }
  ]
}
```

---

## üß© Example Freemarker Template (`applicant_form.ftl`)

```html
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Application Form</title>
  <style>
    body { font-family: Arial, sans-serif; font-size: 12pt; }
    h2 { border-bottom: 1px solid #999; }
  </style>
</head>
<body>

<h2>Primary Applicant</h2>
<#if primary?? && primary?size > 0>
  <#list primary as p>
    <p>${p["primary.fname." + (p?index + 1)]} ${p["primary.lname." + (p?index + 1)]}</p>
  </#list>
</#if>

<h2>Spouse</h2>
<#if spouse?? && spouse?size > 0>
  <#list spouse as s>
    <p>${s["spouse.fname." + (s?index + 1)]} ${s["spouse.lname." + (s?index + 1)]}</p>
  </#list>
</#if>

<h2>Children</h2>
<#if child?? && child?size > 0>
  <#list child as c>
    <p>${c["child.fname." + (c?index + 1)]} ${c["child.lname." + (c?index + 1)]}</p>
  </#list>
</#if>

</body>
</html>
```

---

## üß© Output PDF

The resulting PDF will have sections rendered dynamically based on the `relationship` field in your JSON, identical to how the AcroForm fields would be filled.

---

## ‚úÖ Key Advantages

| Feature                                 | Supported |
| --------------------------------------- | --------- |
| Same YAML mapping as PDFBox             | ‚úÖ         |
| Fully data-driven (no code edits)       | ‚úÖ         |
| Handles `groupBy`, `{group}`, `{index}` | ‚úÖ         |
| Supports nested and repeated arrays     | ‚úÖ         |
| Reuses JSON logic for AcroForm + HTML   | ‚úÖ         |
| Produces final PDF using OpenHTMLToPDF  | ‚úÖ         |

---

## üß© Unified Processor Usage Example

```java
new TemplateProcessor().generate(
    new File("templates/applicant_form.ftl"),   // or .pdf
    new File("data/applicant_data.json"),
    new File("config/pdf-mapping.yaml"),
    new File("output/final.pdf")
);
```

---

If you like, I can now show you the **common YAML schema extension** that would allow both:

* multi-page Freemarker templates (partials or summary pages), and
* merging existing AcroForm-based PDFs (like annexures or attachments)
  ‚Äî all driven by the same unified YAML.

Would you like to see that next?
