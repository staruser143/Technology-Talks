Excellent question ‚úÖ ‚Äî this is exactly the next logical step in evolving your YAML-driven PDF generation framework into a **true data-mapping and transformation engine**.

Right now, your YAML defines *what* to map (source ‚Üí target).
Now you want to add *how to transform* the data before applying it ‚Äî for example:

* format names (`upper`, `title`, etc.)
* format dates (`yyyy-MM-dd ‚Üí dd/MM/yyyy`)
* concatenate fields
* handle defaults or conditional values

Let‚Äôs go step-by-step. üëá

---

## üß© 1Ô∏è‚É£ YAML Transformation Support

We‚Äôll extend each field mapping to include a `transform` (and optionally, a `script`) block.

### Example YAML

```yaml
template:
  name: "ApplicantForm"
  type: "freemarker"

mappings:
  - source: applicantList[]
    groupBy: relationship
    groupTransform: lower
    fields:
      - source: fname
        target: "{group}.fname.{index}"
        transform: "capitalize"

      - source: dob
        target: "{group}.dob.{index}"
        transform:
          type: "dateFormat"
          from: "yyyy-MM-dd"
          to: "dd/MM/yyyy"

      - source: lname
        target: "{group}.fullname.{index}"
        script: "fname + ' ' + lname"  # custom expression

      - source: phone
        target: "{group}.phone.{index}"
        transform: "maskLast4"
```

---

## üß© 2Ô∏è‚É£ Update `FieldMapping.java`

```java
package com.example.pdfgen.config;

import java.util.Map;

public class FieldMapping {
    private String source;
    private String target;
    private String transform; // simple named transform (e.g., upper, lower)
    private Map<String, String> transformParams; // e.g. for dateFormat
    private String script; // custom inline expression
    private String groupBy;
    private String groupTransform;
    private java.util.List<FieldMapping> fields;

    public String getSource() { return source; }
    public void setSource(String source) { this.source = source; }

    public String getTarget() { return target; }
    public void setTarget(String target) { this.target = target; }

    public String getTransform() { return transform; }
    public void setTransform(String transform) { this.transform = transform; }

    public Map<String, String> getTransformParams() { return transformParams; }
    public void setTransformParams(Map<String, String> transformParams) { this.transformParams = transformParams; }

    public String getScript() { return script; }
    public void setScript(String script) { this.script = script; }

    public String getGroupBy() { return groupBy; }
    public void setGroupBy(String groupBy) { this.groupBy = groupBy; }

    public String getGroupTransform() { return groupTransform; }
    public void setGroupTransform(String groupTransform) { this.groupTransform = groupTransform; }

    public java.util.List<FieldMapping> getFields() { return fields; }
    public void setFields(java.util.List<FieldMapping> fields) { this.fields = fields; }
}
```

---

## üß© 3Ô∏è‚É£ Add a `TransformEngine.java`

This central class will handle:

* Named transforms (`upper`, `lower`, etc.)
* Parameterized transforms (like date format)
* Inline script expressions (via MVEL or built-in engine)

### Maven (for MVEL expression support)

```xml
<dependency>
  <groupId>org.mvel</groupId>
  <artifactId>mvel2</artifactId>
  <version>2.5.0.Final</version>
</dependency>
```

### Implementation

```java
package com.example.pdfgen.util;

import org.mvel2.MVEL;
import java.text.SimpleDateFormat;
import java.util.*;
import java.util.regex.*;

public class TransformEngine {

    public static String apply(Object value, String transform, Map<String, String> params, Map<String, Object> context) {
        if (value == null) return "";

        String strVal = value.toString();

        if (transform != null) {
            switch (transform.toLowerCase(Locale.ROOT)) {
                case "upper":
                    return strVal.toUpperCase(Locale.ROOT);
                case "lower":
                    return strVal.toLowerCase(Locale.ROOT);
                case "capitalize":
                    return capitalize(strVal);
                case "title":
                    return toTitleCase(strVal);
                case "masklast4":
                    return maskLast4(strVal);
                case "dateformat":
                    return reformatDate(strVal, params);
                default:
                    return strVal;
            }
        }

        return strVal;
    }

    public static String applyScript(String script, Map<String, Object> context) {
        if (script == null || script.trim().isEmpty()) return "";
        try {
            Object result = MVEL.eval(script, context);
            return result != null ? result.toString() : "";
        } catch (Exception e) {
            System.err.println("‚ö†Ô∏è Error evaluating script: " + script);
            e.printStackTrace();
            return "";
        }
    }

    private static String capitalize(String str) {
        if (str.isEmpty()) return str;
        return Character.toUpperCase(str.charAt(0)) + str.substring(1).toLowerCase();
    }

    private static String toTitleCase(String input) {
        String[] words = input.split("\\s+");
        StringBuilder sb = new StringBuilder();
        for (String w : words) {
            if (w.length() > 0)
                sb.append(Character.toUpperCase(w.charAt(0))).append(w.substring(1).toLowerCase()).append(" ");
        }
        return sb.toString().trim();
    }

    private static String maskLast4(String s) {
        if (s.length() <= 4) return "****";
        return s.substring(0, s.length() - 4).replaceAll(".", "*") + s.substring(s.length() - 4);
    }

    private static String reformatDate(String val, Map<String, String> params) {
        if (params == null) return val;
        try {
            String from = params.getOrDefault("from", "yyyy-MM-dd");
            String to = params.getOrDefault("to", "dd/MM/yyyy");
            SimpleDateFormat srcFmt = new SimpleDateFormat(from);
            SimpleDateFormat tgtFmt = new SimpleDateFormat(to);
            return tgtFmt.format(srcFmt.parse(val));
        } catch (Exception e) {
            return val;
        }
    }
}
```

---

## üß© 4Ô∏è‚É£ Update the Processor (AcroForm / Freemarker)

In both processors, right before you assign the value to the target field, you now apply the transform logic.

For example (inside your `processMapping()` loop):

```java
JsonNode valNode = element.path(field.getSource());
if (!valNode.isMissingNode()) {
    Object rawValue = valNode.asText();

    // Create context for expression evaluation
    Map<String, Object> context = new HashMap<>();
    element.fieldNames().forEachRemaining(n -> context.put(n, element.path(n).asText()));

    String finalValue;
    if (field.getScript() != null) {
        finalValue = TransformEngine.applyScript(field.getScript(), context);
    } else {
        finalValue = TransformEngine.apply(rawValue, field.getTransform(), field.getTransformParams(), context);
    }

    String key = field.getTarget()
                      .replace("{group}", groupValue)
                      .replace("{index}", String.valueOf(index));
    item.put(key, finalValue);
}
```

---

## üß© 5Ô∏è‚É£ Example Results

Given JSON:

```json
{
  "fname": "john",
  "lname": "doe",
  "dob": "1988-05-23",
  "phone": "9876543210"
}
```

and YAML:

```yaml
fields:
  - source: fname
    target: "user.fname"
    transform: "capitalize"

  - source: dob
    target: "user.dob"
    transform:
      type: "dateFormat"
      from: "yyyy-MM-dd"
      to: "dd/MM/yyyy"

  - source: phone
    target: "user.phone"
    transform: "maskLast4"

  - source: lname
    target: "user.fullname"
    script: "fname + ' ' + lname"
```

‚û°Ô∏è Output:

```json
{
  "user.fname": "John",
  "user.dob": "23/05/1988",
  "user.phone": "******3210",
  "user.fullname": "john doe"
}
```

---

## ‚úÖ Benefits

| Feature                    | Description                                      |
| -------------------------- | ------------------------------------------------ |
| **Transform chaining**     | Add reusable, named transforms                   |
| **Inline scripts**         | Define expressions like `"fname + ' ' + lname"`  |
| **Date & text formatting** | Built-in common transformations                  |
| **Context-aware**          | You can reference sibling fields                 |
| **No Java code change**    | All logic lives in YAML                          |
| **Safe & modular**         | Controlled script execution with MVEL sandboxing |

---

## üß© 6Ô∏è‚É£ (Optional) Advanced Extensions

You can go further by allowing:

* **Chained transforms:**

  ```yaml
  transform: ["trim", "upper", "substring:0,10"]
  ```
* **Reusable transform functions** registered via a service provider (`TransformRegistry`)
* **Global pre/post processors** to normalize the JSON before mapping

---

Would you like me to extend the example to show **chained transformations** (multiple transforms applied in sequence), and **a custom registry for reusable named transforms** next?
