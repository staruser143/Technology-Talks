Got it âœ… â€” you now want a **unified, extensible PDF generation library** that:

* Accepts **either** an AcroForm-based PDF template **or** a Freemarker-based HTML template
* Uses the **same YAML-based mapping spec** for data binding
* Produces a **final PDF output** in both cases

Letâ€™s build this properly â€” like a reusable open-source-grade Java library.

---

# ðŸ§± Architecture Overview

### Unified Workflow

```
JSON Data + YAML Mapping + Template File
            â”‚
            â–¼
    Unified TemplateProcessor
       â”œâ”€â”€ AcroFormProcessor (PDFBox)
       â””â”€â”€ FreemarkerHtmlProcessor (FreeMarker + OpenHTMLToPDF / Flying Saucer)
            â–¼
         Final PDF Output
```

You can switch between template types by:

* detecting the input file extension (`.pdf` â†’ AcroForm, `.ftl`/`.html` â†’ Freemarker HTML), or
* explicitly specifying the template type in YAML.

---

# ðŸ§© 1. YAML Configuration (Extended)

Extend the existing `pdf-mapping.yaml` to include `templateType` and optional `outputOptions`.

```yaml
template:
  name: "ApplicationForm"
  type: "acroform"       # or "freemarker"
  description: "Mapping for applicant form with HTML/PDF support"

output:
  flatten: true
  pageSize: A4

mappings:
  - source: applicantList[]
    groupBy: relationship
    relationshipMapping:
      Primary: primaryapplicant
      Spouse: spouse
      Child: dependents
      Dependent: dependents
    fields:
      - source: fname
        target: "{role}.fname.{index+1}"
      - source: lname
        target: "{role}.lname.{index+1}"
```

---

# ðŸ§© 2. Updated Config Classes

### `PdfMappingConfig.java`

```java
package com.example.pdfgen.config;

import java.util.List;

public class PdfMappingConfig {
    private TemplateMeta template;
    private OutputOptions output;
    private List<FieldMapping> mappings;

    public TemplateMeta getTemplate() { return template; }
    public void setTemplate(TemplateMeta template) { this.template = template; }

    public OutputOptions getOutput() { return output; }
    public void setOutput(OutputOptions output) { this.output = output; }

    public List<FieldMapping> getMappings() { return mappings; }
    public void setMappings(List<FieldMapping> mappings) { this.mappings = mappings; }

    public static class TemplateMeta {
        private String name;
        private String type;
        private String description;

        public String getName() { return name; }
        public void setName(String name) { this.name = name; }

        public String getType() { return type; }
        public void setType(String type) { this.type = type; }

        public String getDescription() { return description; }
        public void setDescription(String description) { this.description = description; }
    }

    public static class OutputOptions {
        private boolean flatten = true;
        private String pageSize = "A4";

        public boolean isFlatten() { return flatten; }
        public void setFlatten(boolean flatten) { this.flatten = flatten; }

        public String getPageSize() { return pageSize; }
        public void setPageSize(String pageSize) { this.pageSize = pageSize; }
    }
}
```

---

# ðŸ§© 3. `TemplateProcessor` (Unified entry point)

```java
package com.example.pdfgen.processor;

import com.example.pdfgen.config.PdfMappingConfig;
import com.example.pdfgen.util.YamlConfigLoader;
import com.fasterxml.jackson.databind.ObjectMapper;

import java.io.File;

public class TemplateProcessor {

    private final ObjectMapper mapper = new ObjectMapper();

    public void generate(File templateFile, File jsonFile, File yamlFile, File outputPdf) throws Exception {
        PdfMappingConfig config = YamlConfigLoader.load(yamlFile.getAbsolutePath());
        String type = config.getTemplate().getType().toLowerCase();

        switch (type) {
            case "acroform":
                new AcroFormProcessor().fillTemplate(templateFile, jsonFile, yamlFile, outputPdf);
                break;
            case "freemarker":
                new FreemarkerHtmlProcessor().generatePdf(templateFile, jsonFile, yamlFile, outputPdf);
                break;
            default:
                throw new IllegalArgumentException("Unsupported template type: " + type);
        }
    }
}
```

---

# ðŸ§© 4. `FreemarkerHtmlProcessor.java`

This processor:

1. Loads the HTML/FTL Freemarker template
2. Applies the same YAML mapping logic to inject JSON data
3. Converts the rendered HTML to PDF using **OpenHTMLToPDF** (or Flying Saucer)

### Dependencies (in `pom.xml`)

```xml
<dependency>
  <groupId>org.freemarker</groupId>
  <artifactId>freemarker</artifactId>
  <version>2.3.32</version>
</dependency>

<dependency>
  <groupId>com.openhtmltopdf</groupId>
  <artifactId>openhtmltopdf-pdfbox</artifactId>
  <version>1.0.10</version>
</dependency>

<dependency>
  <groupId>com.openhtmltopdf</groupId>
  <artifactId>openhtmltopdf-slf4j</artifactId>
  <version>1.0.10</version>
</dependency>
```

---

### Full Implementation

```java
package com.example.pdfgen.processor;

import com.example.pdfgen.config.FieldMapping;
import com.example.pdfgen.config.PdfMappingConfig;
import com.example.pdfgen.util.YamlConfigLoader;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import freemarker.template.Configuration;
import freemarker.template.Template;
import freemarker.template.TemplateExceptionHandler;
import com.openhtmltopdf.pdfboxout.PdfRendererBuilder;

import java.io.*;
import java.nio.charset.StandardCharsets;
import java.util.*;

public class FreemarkerHtmlProcessor {

    private final ObjectMapper mapper = new ObjectMapper();

    public void generatePdf(File htmlTemplateFile, File jsonDataFile, File yamlMappingFile, File outputPdf) throws Exception {
        PdfMappingConfig config = YamlConfigLoader.load(yamlMappingFile.getAbsolutePath());
        JsonNode jsonData = mapper.readTree(jsonDataFile);

        // Flatten JSON according to YAML mappings for Freemarker model
        Map<String, Object> templateData = mapJsonToTemplateData(config.getMappings(), jsonData);

        // Setup Freemarker
        Configuration cfg = new Configuration(Configuration.VERSION_2_3_32);
        cfg.setDirectoryForTemplateLoading(htmlTemplateFile.getParentFile());
        cfg.setDefaultEncoding("UTF-8");
        cfg.setTemplateExceptionHandler(TemplateExceptionHandler.RETHROW_HANDLER);

        Template template = cfg.getTemplate(htmlTemplateFile.getName());
        StringWriter writer = new StringWriter();
        template.process(templateData, writer);

        String htmlContent = writer.toString();

        // Convert rendered HTML to PDF
        try (OutputStream os = new FileOutputStream(outputPdf)) {
            PdfRendererBuilder builder = new PdfRendererBuilder();
            builder.useFastMode();
            builder.withHtmlContent(htmlContent, htmlTemplateFile.getParentFile().toURI().toString());
            builder.toStream(os);
            builder.run();
        }
    }

    private Map<String, Object> mapJsonToTemplateData(List<FieldMapping> mappings, JsonNode jsonData) {
        Map<String, Object> model = new HashMap<>();

        for (FieldMapping mapping : mappings) {
            String source = mapping.getSource();

            if (source.endsWith("[]")) {
                String basePath = source.substring(0, source.length() - 2);
                JsonNode arrayNode = jsonData.at("/" + basePath.replace('.', '/'));
                if (arrayNode == null || !arrayNode.isArray()) continue;

                List<Map<String, Object>> processed = new ArrayList<>();
                for (JsonNode element : arrayNode) {
                    Map<String, Object> child = new HashMap<>();
                    if (mapping.getFields() != null) {
                        for (FieldMapping subField : mapping.getFields()) {
                            JsonNode valNode = element.path(subField.getSource());
                            if (!valNode.isMissingNode())
                                child.put(subField.getTarget(), valNode.asText());
                        }
                    }
                    processed.add(child);
                }
                model.put(basePath, processed);
            } else {
                JsonNode valueNode = jsonData.at("/" + source.replace('.', '/'));
                if (!valueNode.isMissingNode()) {
                    model.put(mapping.getTarget(), valueNode.asText());
                }
            }
        }
        return model;
    }
}
```

---

# ðŸ§© 5. Example HTML Template (`application_form.ftl`)

```html
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>${templateName}</title>
  <style>
    body { font-family: Arial, sans-serif; font-size: 12pt; }
    h2 { border-bottom: 1px solid #aaa; }
  </style>
</head>
<body>
  <h2>Applicant Information</h2>

  <p><strong>Primary Applicant:</strong> ${primaryapplicant.fname.1} ${primaryapplicant.lname.1}</p>
  <p><strong>Spouse:</strong> ${spouse.fname.1} ${spouse.lname.1}</p>

  <#if dependents?? && dependents?size > 0>
    <h3>Dependents</h3>
    <#list dependents as dep>
      <p>${dep["dependents.fname." + (dep?index + 1)]} ${dep["dependents.lname." + (dep?index + 1)]}</p>
    </#list>
  </#if>
</body>
</html>
```

---

# ðŸ§© 6. Usage

```java
new TemplateProcessor().generate(
    new File("templates/application_form.pdf"),     // or .ftl
    new File("data/application.json"),
    new File("config/pdf-mapping.yaml"),
    new File("output/final.pdf")
);
```

---

# âœ… Unified Feature Matrix

| Feature                | AcroForm (PDFBox) | Freemarker HTML   |
| ---------------------- | ----------------- | ----------------- |
| YAML-based mapping     | âœ…                 | âœ…                 |
| Arrays and nested JSON | âœ…                 | âœ…                 |
| Transformations        | âœ…                 | âœ…                 |
| Relationship grouping  | âœ…                 | âœ…                 |
| Same config structure  | âœ…                 | âœ…                 |
| Output to PDF          | âœ… (PDFBox)        | âœ… (OpenHTMLToPDF) |

---

# ðŸ§  Next Enhancements (Optional)

* Add **template type autodetection** from file extension
* Support **multi-page HTML templates** via YAML `pages:` section
* Add **custom transformation registry** for user-defined logic (e.g., date formatting)
* Allow **PDF merging** or **summary page insertion** from YAML

---

Would you like me to show the **extended YAML schema** that supports both:

* Freemarker template merging with multiple pages or partials, and
* Merging existing PDFs (like summary pages or annexures)
  in a single unified workflow?
