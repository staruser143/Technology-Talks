Perfect üëç ‚Äî let‚Äôs upgrade your **PDFBox-based PDF generation library** to support **nested JSON objects and arrays of any depth**, with no manual mapping needed per field.

This updated version:

* Recursively walks through your entire JSON tree
* Fills AcroForm fields matching JSON paths (e.g., `invoice.customer.name`, `items[0].price`, etc.)
* Works with variable-length arrays and deeply nested objects
* Keeps YAML config optional for flexibility

---

## üß© Updated Project Overview

```
pdf-generator-lib/
 ‚îú‚îÄ‚îÄ pom.xml
 ‚îî‚îÄ‚îÄ src/
     ‚îú‚îÄ‚îÄ main/java/com/example/pdfgen/
     ‚îÇ    ‚îú‚îÄ‚îÄ PdfGenerator.java
     ‚îÇ    ‚îú‚îÄ‚îÄ processor/AcroFormProcessor.java
     ‚îÇ    ‚îú‚îÄ‚îÄ config/MappingConfig.java
     ‚îÇ    ‚îú‚îÄ‚îÄ config/{TemplateConfig,OutputConfig}.java
     ‚îÇ    ‚îú‚îÄ‚îÄ util/{YamlUtils,JsonUtils}.java
     ‚îî‚îÄ‚îÄ main/resources/
          ‚îú‚îÄ‚îÄ configs/mapping.yaml
          ‚îú‚îÄ‚îÄ data/invoice.json
          ‚îî‚îÄ‚îÄ templates/invoice.pdf
```

---

## ‚úÖ `pom.xml` (unchanged)

Same as before, using PDFBox 2.0.7 + Jackson + SLF4J.

---

## üß† New Capability

No longer limited to flat mappings ‚Äî it walks the JSON structure automatically.

---

## üß© `AcroFormProcessor.java` (Updated)

```java
package com.example.pdfgen.processor;

import com.example.pdfgen.config.MappingConfig;
import com.example.pdfgen.util.JsonUtils;
import com.fasterxml.jackson.databind.JsonNode;
import org.apache.pdfbox.pdmodel.PDDocument;
import org.apache.pdfbox.pdmodel.interactive.form.PDAcroForm;
import org.apache.pdfbox.pdmodel.interactive.form.PDField;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.File;
import java.io.IOException;
import java.util.Iterator;

/**
 * AcroForm processor supporting nested JSON objects and arrays of any depth.
 * Fills fields matching JSON path names (e.g. invoice.customer.name, items[0].desc)
 */
public class AcroFormProcessor {

    private static final Logger log = LoggerFactory.getLogger(AcroFormProcessor.class);

    public void generate(MappingConfig config, JsonNode data) throws Exception {
        File templateFile = new File(config.getTemplate().getPath());
        if (!templateFile.exists()) {
            throw new IllegalArgumentException("Template not found: " + templateFile.getAbsolutePath());
        }

        PDDocument document = PDDocument.load(templateFile);
        PDAcroForm form = document.getDocumentCatalog().getAcroForm();
        if (form == null) {
            throw new IllegalStateException("No AcroForm found in template.");
        }

        log.info("Starting recursive fill for template: {}", templateFile.getName());
        fillFormFields(form, data, "");

        form.flatten(); // optional
        document.save(config.getOutput().getPath());
        document.close();

        log.info("PDF generated successfully: {}", config.getOutput().getPath());
    }

    private void fillFormFields(PDAcroForm form, JsonNode node, String prefix) throws IOException {
        if (node.isObject()) {
            Iterator<String> fieldNames = node.fieldNames();
            while (fieldNames.hasNext()) {
                String name = fieldNames.next();
                fillFormFields(form, node.get(name), buildPath(prefix, name));
            }
        } else if (node.isArray()) {
            for (int i = 0; i < node.size(); i++) {
                fillFormFields(form, node.get(i), buildPath(prefix, "[" + i + "]"));
            }
        } else if (node.isValueNode()) {
            PDField field = form.getField(prefix);
            if (field != null) {
                String value = node.asText();
                field.setValue(value);
                log.info("Filled field: {} = {}", prefix, value);
            } else {
                log.debug("No matching field for {}", prefix);
            }
        }
    }

    private String buildPath(String prefix, String name) {
        if (prefix == null || prefix.isEmpty()) return name;
        if (name.startsWith("[")) return prefix + name;  // array element
        return prefix + "." + name;                      // nested field
    }
}
```

### üß© Key Features:

‚úÖ Handles **any JSON depth**
‚úÖ Supports arrays (creates paths like `items[0].desc`)
‚úÖ Matches AcroForm field names using **dot notation**
‚úÖ Gracefully skips missing fields

---

## üß© `PdfGenerator.java`

You can now generate a PDF either by mapping YAML config, or directly if your JSON and form field names match paths.

```java
package com.example.pdfgen;

import com.example.pdfgen.config.MappingConfig;
import com.example.pdfgen.processor.AcroFormProcessor;
import com.example.pdfgen.util.JsonUtils;
import com.example.pdfgen.util.YamlUtils;
import com.fasterxml.jackson.databind.JsonNode;

public class PdfGenerator {

    public static void main(String[] args) throws Exception {
        String configPath = "src/main/resources/configs/mapping.yaml";
        String dataPath = "src/main/resources/data/invoice.json";

        MappingConfig config = YamlUtils.loadConfig(configPath);
        JsonNode data = JsonUtils.loadJson(dataPath);

        if ("acroform".equalsIgnoreCase(config.getTemplate().getType())) {
            new AcroFormProcessor().generate(config, data);
        } else {
            throw new UnsupportedOperationException("Only 'acroform' supported in this build.");
        }
    }
}
```

---

## üßæ Example JSON (`invoice.json`)

```json
{
  "invoice": {
    "customer": {
      "name": "Alice Johnson",
      "address": {
        "line1": "123 Main Street",
        "city": "Springfield",
        "zip": "90210"
      }
    },
    "items": [
      { "desc": "Pen", "qty": 2, "price": 1.25 },
      { "desc": "Notebook", "qty": 1, "price": 5.50 }
    ],
    "summary": {
      "subtotal": 7.00,
      "tax": 0.63,
      "total": 7.63
    }
  }
}
```

---

## üßæ Example YAML (`mapping.yaml`)

```yaml
template:
  type: acroform
  path: src/main/resources/templates/invoice.pdf

output:
  path: target/output/invoice_filled.pdf
```

### Note:

No need to manually list mappings anymore ‚Äî it walks through the whole JSON tree automatically.
You only need to ensure your **PDF form fields** use names matching JSON paths, e.g.:

```
invoice.customer.name
invoice.customer.address.line1
invoice.customer.address.city
invoice.items[0].desc
invoice.items[1].desc
invoice.summary.total
```

---

## ‚ñ∂Ô∏è Run

```bash
mvn clean package
java -jar target/pdf-generator-lib-1.0.0-jar-with-dependencies.jar
```

Output PDF ‚Üí
`target/output/invoice_filled.pdf`

---

## ‚úÖ Summary of Enhancements

| Feature                 | Status                    |
| ----------------------- | ------------------------- |
| Nested objects          | ‚úÖ Fully supported         |
| Arrays                  | ‚úÖ Supported via `[index]` |
| Arbitrary depth         | ‚úÖ Recursive               |
| Manual mapping          | ‚öôÔ∏è Optional               |
| Graceful missing fields | ‚úÖ Yes                     |
| PDFBox 2.0.7 compatible | ‚úÖ Yes                     |

---

Would you like me to extend this next to also:

* ‚úÖ **Auto-expand repeating rows** (e.g., dynamically create text fields for array items beyond what exists in the form), and/or
* ‚úÖ **Add support for merging multiple PDF templates (summary pages, etc.)** using YAML config?

These are natural next steps to make this a complete PDF generation framework.
