Perfect â€” letâ€™s extend the full unified PDF generation framework so that in addition to **named Java-based transformations**, your YAML config can also specify **inline or online script transformations** (like JavaScript or Groovy snippets) for flexible dynamic behavior â€” without recompiling Java code.

Weâ€™ll add:

1. **TransformRegistry** â€“ manages named transforms (Java-based).
2. **ScriptTransform** â€“ executes inline scripts dynamically.
3. **ChainedTransform** â€“ supports multiple transforms per field.
4. **UnifiedProcessor** â€“ handles both AcroForm PDF (PDFBox) and FreeMarker HTML templates, applies transforms from YAML, and merges data.

---

### ðŸ§© YAML Example (`config.yaml`)

```yaml
template:
  type: "pdf"  # or "html"
  path: "templates/application_form.pdf"

mapping:
  fields:
    - target: "primary.fname.1"
      source: "applicantList[?(@.relationship == 'PRIMARY')].firstName"
      transforms:
        - toUpperCase
        - script: "value + ' (Primary Applicant)'"

    - target: "spouse.fname.1"
      source: "applicantList[?(@.relationship == 'SPOUSE')].firstName"
      transforms:
        - toTitleCase

    - target: "dependents.fname.*"
      source: "applicantList[?(@.relationship == 'CHILD')].firstName"
      transforms:
        - script: "'Child: ' + value"
```

---

### ðŸ§© Project Structure

```
src/main/java/com/example/pdfgen/
â”œâ”€â”€ MainApp.java
â”œâ”€â”€ config/
â”‚   â””â”€â”€ YamlConfig.java
â”œâ”€â”€ mapping/
â”‚   â”œâ”€â”€ MappingSpec.java
â”‚   â”œâ”€â”€ FieldMapping.java
â”‚   â”œâ”€â”€ Transform.java
â”‚   â”œâ”€â”€ TransformRegistry.java
â”‚   â”œâ”€â”€ ChainedTransform.java
â”‚   â””â”€â”€ ScriptTransform.java
â”œâ”€â”€ processor/
â”‚   â”œâ”€â”€ UnifiedProcessor.java
â”‚   â”œâ”€â”€ AcroFormProcessor.java
â”‚   â””â”€â”€ HtmlTemplateProcessor.java
â””â”€â”€ util/
    â””â”€â”€ JsonUtils.java
```

---

### ðŸ§  Core Implementation

#### `Transform.java`

```java
package com.example.pdfgen.mapping;

@FunctionalInterface
public interface Transform {
    Object apply(Object value);
}
```

---

#### `TransformRegistry.java`

```java
package com.example.pdfgen.mapping;

import java.util.HashMap;
import java.util.Map;

public class TransformRegistry {
    private static final Map<String, Transform> registry = new HashMap<>();

    static {
        registry.put("toUpperCase", v -> v != null ? v.toString().toUpperCase() : null);
        registry.put("toLowerCase", v -> v != null ? v.toString().toLowerCase() : null);
        registry.put("toTitleCase", v -> {
            if (v == null) return null;
            String[] parts = v.toString().split(" ");
            StringBuilder sb = new StringBuilder();
            for (String p : parts) sb.append(Character.toUpperCase(p.charAt(0))).append(p.substring(1).toLowerCase()).append(" ");
            return sb.toString().trim();
        });
    }

    public static Transform get(String name) {
        return registry.get(name);
    }

    public static void register(String name, Transform transform) {
        registry.put(name, transform);
    }
}
```

---

#### `ScriptTransform.java`

```java
package com.example.pdfgen.mapping;

import javax.script.ScriptEngine;
import javax.script.ScriptEngineManager;
import javax.script.SimpleBindings;
import java.util.Map;

public class ScriptTransform implements Transform {
    private final String script;
    private final ScriptEngine engine;

    public ScriptTransform(String script) {
        this.script = script;
        this.engine = new ScriptEngineManager().getEngineByName("nashorn"); // or "groovy" if available
    }

    @Override
    public Object apply(Object value) {
        try {
            Map<String, Object> bindings = Map.of("value", value);
            Object result = engine.eval(script, new SimpleBindings(bindings));
            return result != null ? result : value;
        } catch (Exception e) {
            System.err.println("Script error: " + e.getMessage());
            return value;
        }
    }
}
```

---

#### `ChainedTransform.java`

```java
package com.example.pdfgen.mapping;

import java.util.List;

public class ChainedTransform implements Transform {
    private final List<Transform> transforms;

    public ChainedTransform(List<Transform> transforms) {
        this.transforms = transforms;
    }

    @Override
    public Object apply(Object value) {
        Object current = value;
        for (Transform t : transforms) {
            current = t.apply(current);
        }
        return current;
    }
}
```

---

#### `FieldMapping.java`

```java
package com.example.pdfgen.mapping;

import java.util.ArrayList;
import java.util.List;

public class FieldMapping {
    private String target;
    private String source;
    private List<String> transforms = new ArrayList<>();

    // getters/setters
    public String getTarget() { return target; }
    public void setTarget(String target) { this.target = target; }
    public String getSource() { return source; }
    public void setSource(String source) { this.source = source; }
    public List<String> getTransforms() { return transforms; }
    public void setTransforms(List<String> transforms) { this.transforms = transforms; }
}
```

---

#### `YamlConfig.java`

```java
package com.example.pdfgen.config;

import com.example.pdfgen.mapping.FieldMapping;
import java.util.List;

public class YamlConfig {
    private Template template;
    private Mapping mapping;

    public static class Template {
        private String type;
        private String path;
        public String getType() { return type; }
        public void setType(String type) { this.type = type; }
        public String getPath() { return path; }
        public void setPath(String path) { this.path = path; }
    }

    public static class Mapping {
        private List<FieldMapping> fields;
        public List<FieldMapping> getFields() { return fields; }
        public void setFields(List<FieldMapping> fields) { this.fields = fields; }
    }

    public Template getTemplate() { return template; }
    public void setTemplate(Template template) { this.template = template; }
    public Mapping getMapping() { return mapping; }
    public void setMapping(Mapping mapping) { this.mapping = mapping; }
}
```

---

#### `UnifiedProcessor.java`

```java
package com.example.pdfgen.processor;

import com.example.pdfgen.config.YamlConfig;
import com.example.pdfgen.mapping.*;
import com.example.pdfgen.util.JsonUtils;
import org.apache.pdfbox.pdmodel.PDDocument;

import java.io.File;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

public class UnifiedProcessor {
    private final YamlConfig config;
    private final Map<String, Object> jsonData;

    public UnifiedProcessor(YamlConfig config, Map<String, Object> jsonData) {
        this.config = config;
        this.jsonData = jsonData;
    }

    public void process() throws Exception {
        String templateType = config.getTemplate().getType();
        if ("pdf".equalsIgnoreCase(templateType)) {
            new AcroFormProcessor().process(config, jsonData);
        } else if ("html".equalsIgnoreCase(templateType)) {
            new HtmlTemplateProcessor().process(config, jsonData);
        }
    }

    public static Transform buildTransformChain(List<String> transformDefs) {
        List<Transform> transforms = new ArrayList<>();
        for (String def : transformDefs) {
            if (def.startsWith("script:")) {
                transforms.add(new ScriptTransform(def.substring("script:".length()).trim()));
            } else {
                Transform t = TransformRegistry.get(def);
                if (t != null) transforms.add(t);
            }
        }
        return new ChainedTransform(transforms);
    }
}
```

---

#### `AcroFormProcessor.java`

(Uses PDFBox to fill AcroForm fields)

```java
package com.example.pdfgen.processor;

import com.example.pdfgen.config.YamlConfig;
import com.example.pdfgen.mapping.Transform;
import com.example.pdfgen.util.JsonUtils;
import org.apache.pdfbox.pdmodel.PDDocument;
import org.apache.pdfbox.pdmodel.interactive.form.PDAcroForm;

import java.io.File;
import java.util.Map;

public class AcroFormProcessor {
    public void process(YamlConfig config, Map<String, Object> jsonData) throws Exception {
        PDDocument doc = PDDocument.load(new File(config.getTemplate().getPath()));
        PDAcroForm acroForm = doc.getDocumentCatalog().getAcroForm();

        for (var field : config.getMapping().getFields()) {
            Object value = JsonUtils.extractValue(jsonData, field.getSource());
            Transform transform = UnifiedProcessor.buildTransformChain(field.getTransforms());
            Object transformed = transform.apply(value);

            if (acroForm.getField(field.getTarget()) != null)
                acroForm.getField(field.getTarget()).setValue(transformed != null ? transformed.toString() : "");
        }

        doc.save("output.pdf");
        doc.close();
    }
}
```

---

#### `HtmlTemplateProcessor.java`

```java
package com.example.pdfgen.processor;

import com.example.pdfgen.config.YamlConfig;
import com.example.pdfgen.mapping.Transform;
import com.example.pdfgen.util.JsonUtils;
import freemarker.template.Configuration;
import freemarker.template.Template;

import java.io.File;
import java.io.FileWriter;
import java.util.HashMap;
import java.util.Map;

public class HtmlTemplateProcessor {
    public void process(YamlConfig config, Map<String, Object> jsonData) throws Exception {
        Configuration cfg = new Configuration(Configuration.VERSION_2_3_31);
        cfg.setDirectoryForTemplateLoading(new File("templates"));
        Template template = cfg.getTemplate(new File(config.getTemplate().getPath()).getName());

        Map<String, Object> model = new HashMap<>();
        for (var field : config.getMapping().getFields()) {
            Object value = JsonUtils.extractValue(jsonData, field.getSource());
            Transform transform = UnifiedProcessor.buildTransformChain(field.getTransforms());
            model.put(field.getTarget(), transform.apply(value));
        }

        try (FileWriter writer = new FileWriter("output.html")) {
            template.process(model, writer);
        }
    }
}
```

---

#### `JsonUtils.java`

```java
package com.example.pdfgen.util;

import com.jayway.jsonpath.JsonPath;
import java.util.Map;

public class JsonUtils {
    public static Object extractValue(Map<String, Object> jsonData, String path) {
        try {
            return JsonPath.read(jsonData, "$." + path);
        } catch (Exception e) {
            return null;
        }
    }
}
```

---

### âœ… **You Can Now:**

* Define any number of transformations in YAML (Java or script-based).
* Chain multiple transforms per field.
* Use the same mapping for both PDF and HTML templates.
* Keep transformations dynamic via script execution.

---

Would you like me to extend this to **support loading external scripts** (e.g. `.groovy` or `.js` files referenced in YAML by path instead of inline)?
Thatâ€™s often useful in enterprise setups where logic evolves separately from deployment.
