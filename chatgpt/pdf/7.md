Excellent ‚Äî this is the **right next step**.
Once your core PDF processor works (which it now does), the YAML configuration becomes the *‚Äúbrain‚Äù* that tells your engine **what to map, how to map, and how to transform**.

Let‚Äôs design this carefully so it‚Äôs **flexible**, **readable**, and **easy to extend** later (e.g. for Freemarker HTML templates, merging, etc.).

---

## üß© Goals of the YAML Mapping Specification

We want the YAML file to:

1. **Specify mapping** between JSON fields and PDF form fields.

   * Support direct mappings (`json.field ‚Üí pdf.field`)
   * Support array expansions (`dependents[].fname ‚Üí dependents.fname.{index+1}`)

2. **Support transformations** (optional).

   * Example: uppercase, date format, concatenation, conditional

3. **Allow per-template configuration**.

   * Each PDF template can have its own mapping file.

4. **Allow default mapping behavior** when not explicitly specified.

   * The code will fall back to automatic JSON path inference if YAML doesn‚Äôt cover a field.

---

## üßæ Example YAML Specification

Let‚Äôs take the same JSON example:

```json
{
  "primaryapplicant": { "fname": "John", "lname": "Doe" },
  "spouse": { "fname": "Jane", "lname": "Doe" },
  "dependents": [
    { "fname": "Sam", "lname": "Doe" },
    { "fname": "Ella", "lname": "Doe" }
  ]
}
```

And the PDF fields look like:

```
primaryapplicant.fname.1
primaryapplicant.lname.1
spouse.fname.1
spouse.lname.1
dependents.fname.1
dependents.lname.1
dependents.fname.2
dependents.lname.2
```

Here‚Äôs what a **clean YAML mapping spec** could look like üëá

---

### üìò `src/main/resources/config/pdf-mapping.yaml`

```yaml
template:
  name: "ApplicationForm"
  description: "Mapping for applicant, spouse, and dependents form"

mappings:
  # Direct simple mappings
  - source: primaryapplicant.fname
    target: primaryapplicant.fname.1
  - source: primaryapplicant.lname
    target: primaryapplicant.lname.1

  - source: spouse.fname
    target: spouse.fname.1
  - source: spouse.lname
    target: spouse.lname.1

  # Array expansion
  - source: dependents[].fname
    target: dependents.fname.{index+1}
  - source: dependents[].lname
    target: dependents.lname.{index+1}

  # Optional transformation example
  - source: primaryapplicant.lname
    target: primaryapplicant.lname.1
    transform: uppercase

  # Derived field example
  - source: primaryapplicant
    target: full_name.1
    transform: concat(fname, ' ', lname)
```

---

## üß† Breakdown

| Key         | Description                                                               |
| ----------- | ------------------------------------------------------------------------- |
| `source`    | JSON path (supports arrays via `[]`)                                      |
| `target`    | PDF field name (may include `{index+1}` placeholders for repeated fields) |
| `transform` | Optional transformation rule (`uppercase`, `concat`, etc.)                |
| `template`  | Metadata for clarity and versioning                                       |

---

## üß∞ YAML Model Classes (Java)

Define a few POJOs to load YAML easily via SnakeYAML:

### üìÑ `src/main/java/com/example/pdfgen/config/PdfMappingConfig.java`

```java
package com.example.pdfgen.config;

import java.util.List;

public class PdfMappingConfig {
    private TemplateMeta template;
    private List<FieldMapping> mappings;

    // getters and setters
    public TemplateMeta getTemplate() { return template; }
    public void setTemplate(TemplateMeta template) { this.template = template; }

    public List<FieldMapping> getMappings() { return mappings; }
    public void setMappings(List<FieldMapping> mappings) { this.mappings = mappings; }

    public static class TemplateMeta {
        private String name;
        private String description;

        // getters and setters
        public String getName() { return name; }
        public void setName(String name) { this.name = name; }

        public String getDescription() { return description; }
        public void setDescription(String description) { this.description = description; }
    }
}
```

### üìÑ `src/main/java/com/example/pdfgen/config/FieldMapping.java`

```java
package com.example.pdfgen.config;

public class FieldMapping {
    private String source;
    private String target;
    private String transform;

    public String getSource() { return source; }
    public void setSource(String source) { this.source = source; }

    public String getTarget() { return target; }
    public void setTarget(String target) { this.target = target; }

    public String getTransform() { return transform; }
    public void setTransform(String transform) { this.transform = transform; }
}
```

---

## ‚öôÔ∏è YAML Loader Utility

Use **SnakeYAML** (`org.yaml:snakeyaml:2.0`).

### üìÑ `src/main/java/com/example/pdfgen/util/YamlConfigLoader.java`

```java
package com.example.pdfgen.util;

import com.example.pdfgen.config.PdfMappingConfig;
import org.yaml.snakeyaml.Yaml;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;

public class YamlConfigLoader {

    public static PdfMappingConfig load(String yamlFilePath) throws IOException {
        Yaml yaml = new Yaml();
        try (InputStream in = new FileInputStream(yamlFilePath)) {
            return yaml.loadAs(in, PdfMappingConfig.class);
        }
    }
}
```

---

## üß© Integrating YAML with `AcroFormProcessor`

You can now modify your processor to accept the mapping config and use it to fill fields instead of relying purely on JSON path inference.

### Extended Method Signature:

```java
public void fillTemplate(File pdfTemplate, File jsonDataFile, File yamlMappingFile, File outputPdf)
```

Then, inside:

```java
PdfMappingConfig config = YamlConfigLoader.load(yamlMappingFile.getAbsolutePath());
for (FieldMapping mapping : config.getMappings()) {
    JsonNode valueNode = jsonData.at("/" + mapping.getSource().replace('.', '/'));
    if (valueNode.isMissingNode()) continue;

    String pdfFieldName = resolveIndexedTarget(mapping.getTarget(), mapping.getSource(), valueNode);
    PDField field = form.getField(pdfFieldName);

    if (field != null) {
        String value = applyTransform(mapping.getTransform(), valueNode.asText(), jsonData);
        field.setValue(value);
    }
}
```

---

### Helper for Transformations

```java
private String applyTransform(String transform, String value, JsonNode context) {
    if (transform == null || transform.isEmpty()) return value;

    switch (transform.toLowerCase()) {
        case "uppercase": return value.toUpperCase();
        case "lowercase": return value.toLowerCase();
        default:
            if (transform.startsWith("concat(")) {
                // Example: concat(fname, ' ', lname)
                String inner = transform.substring(7, transform.length() - 1);
                String[] parts = inner.split(",");
                StringBuilder sb = new StringBuilder();
                for (String p : parts) {
                    String part = p.trim().replace("'", "");
                    JsonNode n = context.at("/" + part.replace('.', '/'));
                    sb.append(n.isMissingNode() ? part : n.asText());
                }
                return sb.toString();
            }
    }
    return value;
}
```

---

## ‚úÖ Summary

| Feature                                 | Supported |
| --------------------------------------- | --------- |
| YAML-based mapping                      | ‚úÖ         |
| Nested JSON                             | ‚úÖ         |
| Arrays with `{index}` placeholders      | ‚úÖ         |
| Transformations (uppercase, concat)     | ‚úÖ         |
| Backward-compatible with old logic      | ‚úÖ         |
| Extensible to Freemarker HTML templates | ‚úÖ         |

---

Would you like me to show you the **updated AcroFormProcessor.java** (v2) that integrates this YAML mapping logic end-to-end ‚Äî so it can work with either direct auto-mapping or YAML-driven field mapping seamlessly?
