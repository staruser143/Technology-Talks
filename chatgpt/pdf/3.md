Excellent and very important question ‚úÖ ‚Äî because **real-world JSON data** almost always includes **nested objects and arrays**, e.g. customers, addresses, items, taxes, etc.

Let‚Äôs break this down carefully.

---

## üß† TL;DR ‚Äî The current code:

**‚úîÔ∏è Supports nested objects** (like `customer.name`)
**‚ùå Does not fully support arrays** (like `items[0].price` or repeating table rows) ‚Äî *yet.*

But you can easily extend it.
Let‚Äôs go through **what works now**, **what doesn‚Äôt**, and **how to enhance it**.

---

## ‚úÖ What Works (Already Supported)

Because the current implementation uses:

```java
JsonNode value = data.at("/" + fm.getSource().replace(".", "/"));
```

‚Ä¶it leverages **Jackson‚Äôs JSON Pointer syntax**, which supports:

* Nested objects:
  ‚úÖ `/customer/name` ‚Üí `"John Doe"`
* Deep nesting:
  ‚úÖ `/invoice/details/tax/amount`

So, any dot-separated path in your YAML like:

```yaml
- source: invoice.details.tax.amount
  target: tax_amount
```

will correctly resolve to the value.

---

## ‚ö†Ô∏è What‚Äôs Not Fully Supported Yet

### 1. JSON arrays (like `items[0].price`)

Jackson‚Äôs `.at()` **does** support numeric indices, so technically:

```yaml
- source: items/0/price
```

works.

However, your YAML config currently maps **one field to one target**, meaning you cannot automatically iterate arrays and render dynamic sections like tables or repeating rows (common in invoices, order lists, etc).

---

## üß© Option 1: Minimal Enhancement (Static Array Access)

If you just want to fill specific array elements (like first 3 items), you can write:

```yaml
mapping:
  - source: items/0/name
    target: item1_name
  - source: items/0/price
    target: item1_price
  - source: items/1/name
    target: item2_name
```

‚úÖ Works fine
‚ö†Ô∏è Requires a fixed number of fields in your PDF form.

---

## üß© Option 2: Dynamic Array Handling (Recommended Upgrade)

If you want **variable-length lists**, e.g. automatically filling N rows of items in a table, you can extend `AcroFormProcessor` like this:

```java
if (value.isArray()) {
    for (int i = 0; i < value.size(); i++) {
        JsonNode element = value.get(i);
        String targetName = fm.getTarget().replace("{i}", String.valueOf(i + 1));
        PDField field = form.getField(targetName);
        if (field != null && element.isValueNode()) {
            field.setValue(element.asText());
        }
    }
}
```

Then in your YAML mapping, define placeholders:

```yaml
mapping:
  - source: items
    target: item_{i}
```

And in your AcroForm, define fields like:

```
item_1, item_2, item_3 ...
```

This way, the processor fills as many fields as exist in both data and form.

---

## üß© Option 3: Nested Object Arrays (Custom Logic)

If you have a complex structure:

```json
"items": [
  { "name": "Pen", "price": 1.25 },
  { "name": "Book", "price": 5.50 }
]
```

You can modify your processor to detect array nodes and recursively handle their children:

```java
private void fillFormFields(JsonNode data, PDAcroForm form, String prefix) throws IOException {
    Iterator<String> fieldNames = data.fieldNames();
    while (fieldNames.hasNext()) {
        String fieldName = fieldNames.next();
        JsonNode value = data.get(fieldName);

        if (value.isObject()) {
            fillFormFields(value, form, prefix + fieldName + ".");
        } else if (value.isArray()) {
            for (int i = 0; i < value.size(); i++) {
                fillFormFields(value.get(i), form, prefix + fieldName + "[" + i + "].");
            }
        } else {
            PDField field = form.getField(prefix + fieldName);
            if (field != null) {
                field.setValue(value.asText());
            }
        }
    }
}
```

Then you can flatten your mappings and call this once:

```java
fillFormFields(data, form, "");
```

Now, any field in your PDF like `items[0].name` or `items[1].price` will be filled automatically.

---

## üßæ Example

**JSON:**

```json
{
  "invoice": {
    "customer": {
      "name": "Alice",
      "address": "123 Main Street"
    },
    "items": [
      {"desc": "Pen", "qty": 2, "price": 1.25},
      {"desc": "Notebook", "qty": 1, "price": 5.50}
    ]
  }
}
```

**YAML:**

```yaml
template:
  type: acroform
  path: src/main/resources/templates/invoice.pdf

output:
  path: target/output/invoice_filled.pdf

mapping:
  - source: invoice.customer.name
    target: customer_name
  - source: invoice.customer.address
    target: customer_address
  - source: invoice.items
    target: item_{i}_desc
```

**PDF Fields:**

```
customer_name
customer_address
item_1_desc
item_2_desc
item_1_qty
item_1_price
item_2_qty
item_2_price
```

Result: dynamically fills all existing rows for however many items are in your JSON.

---

## ‚úÖ Summary

| Feature              | Supported Now | Enhancement Needed     |
| -------------------- | ------------- | ---------------------- |
| Nested objects       | ‚úÖ Yes         | ‚Äì                      |
| Deep nesting         | ‚úÖ Yes         | ‚Äì                      |
| Fixed arrays         | ‚úÖ Partial     | ‚Äì                      |
| Dynamic arrays       | ‚ùå             | Add simple loop logic  |
| Nested object arrays | ‚ùå             | Add recursive handling |

---

Would you like me to **update your Maven skeleton** to include full **recursive and array-aware field filling logic** (so it supports any depth and array combination automatically)?
That way, your library will handle any valid JSON structure without manually defining every mapping.
