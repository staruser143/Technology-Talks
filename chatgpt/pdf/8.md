Excellent question ‚úÖ ‚Äî this is a **realistic and production-like scenario** that comes up frequently in financial, insurance, and application processing systems.

Let‚Äôs go step-by-step through how to support a **generic `applicantList[]`** structure, where each element identifies its type (`relationship`) ‚Äî for example:

---

### üß© Example JSON Data

```json
{
  "applicantList": [
    {
      "relationship": "Primary",
      "fname": "John",
      "lname": "Doe"
    },
    {
      "relationship": "Spouse",
      "fname": "Jane",
      "lname": "Doe"
    },
    {
      "relationship": "Child",
      "fname": "Tom",
      "lname": "Doe"
    },
    {
      "relationship": "Child",
      "fname": "Lily",
      "lname": "Doe"
    }
  ]
}
```

---

### üß† Problem Statement

We must:

* Identify which `applicantList[i]` corresponds to:

  * Primary applicant ‚Üí fill fields like `primaryapplicant.fname.1`
  * Spouse ‚Üí fill fields like `spouse.fname.1`
  * Child/Dependent ‚Üí fill fields like `dependents.fname.1`, `dependents.fname.2`, etc.
* Dependents can be **zero or more**.
* The structure is **flat array + relationship tag**, so we must map dynamically.

---

### ‚úÖ Solution Design

We extend our processor logic in these ways:

1. Detect and handle the special case where the mapping source path starts with `applicantList[]`.
2. For each element, inspect `relationship` (case-insensitive).
3. Based on the `relationship`, route it to the correct PDF field prefix:

   * `"primary"` ‚Üí `primaryapplicant`
   * `"spouse"` ‚Üí `spouse`
   * `"child"` or `"dependent"` ‚Üí `dependents`
4. Track dependents count so they get `.1`, `.2`, etc.
5. The YAML mapping simply declares a generic pattern ‚Äî not per relationship.

---

### üßæ Updated YAML Example

```yaml
template:
  name: "ApplicationForm"
  description: "Applicant list mapping with relationship-based routing"

mappings:
  # The processor will detect relationship dynamically
  - source: applicantList[].fname
    target: "{relationship}.fname.{index+1}"
  - source: applicantList[].lname
    target: "{relationship}.lname.{index+1}"
```

Here:

* `{relationship}` is dynamically replaced by one of `primaryapplicant`, `spouse`, or `dependents`.
* `{index+1}` is the positional index for that category (not global array index).

---

### ‚öôÔ∏è Updated Logic (Core Snippet)

In your `AcroFormProcessor`, update `fillUsingYamlMapping()` to include special logic for this case:

```java
private void fillUsingYamlMapping(PDAcroForm form, JsonNode jsonData, PdfMappingConfig mappingConfig) throws IOException {
    for (FieldMapping mapping : mappingConfig.getMappings()) {
        String source = mapping.getSource();
        String target = mapping.getTarget();
        String transform = mapping.getTransform();

        if (source.startsWith("applicantList[]")) {
            JsonNode applicants = jsonData.get("applicantList");
            if (applicants != null && applicants.isArray()) {
                int depIndex = 1;
                for (JsonNode applicant : applicants) {
                    String rel = applicant.path("relationship").asText("").toLowerCase();
                    String role;
                    int roleIndex = 1;

                    switch (rel) {
                        case "primary":
                            role = "primaryapplicant";
                            break;
                        case "spouse":
                            role = "spouse";
                            break;
                        default:
                            role = "dependents";
                            roleIndex = depIndex++;
                    }

                    // Extract remaining path, e.g. fname or lname
                    String fieldPath = source.substring("applicantList[]".length() + 1); // remove "applicantList[]."
                    JsonNode valueNode = applicant.path(fieldPath);
                    if (valueNode.isMissingNode()) continue;

                    // Replace placeholders
                    String resolvedTarget = target
                            .replace("{relationship}", role)
                            .replace("{index+1}", String.valueOf(roleIndex))
                            .replace("{index}", String.valueOf(roleIndex - 1));

                    PDField field = form.getField(resolvedTarget);
                    if (field != null) {
                        String value = applyTransform(transform, valueNode.asText(), applicant);
                        field.setValue(value);
                        log.debug("Filled [{}] with value [{}]", resolvedTarget, value);
                    } else {
                        log.trace("Field not found for {}", resolvedTarget);
                    }
                }
            }
            continue;
        }

        // ... rest of your existing array and direct field logic ...
    }
}
```

---

### üí° Key Behaviors

| Relationship               | PDF Prefix Used    | Index Example         |
| -------------------------- | ------------------ | --------------------- |
| `"Primary"`                | `primaryapplicant` | `.1`                  |
| `"Spouse"`                 | `spouse`           | `.1`                  |
| `"Child"` or `"Dependent"` | `dependents`       | `.1`, `.2`, `.3`, ... |

---

### üßæ Resulting PDF Field Mapping

For the above JSON:

| Applicant Type | Field Filled               | Value |
| -------------- | -------------------------- | ----- |
| Primary        | `primaryapplicant.fname.1` | John  |
| Primary        | `primaryapplicant.lname.1` | Doe   |
| Spouse         | `spouse.fname.1`           | Jane  |
| Spouse         | `spouse.lname.1`           | Doe   |
| Child (1)      | `dependents.fname.1`       | Tom   |
| Child (1)      | `dependents.lname.1`       | Doe   |
| Child (2)      | `dependents.fname.2`       | Lily  |
| Child (2)      | `dependents.lname.2`       | Doe   |

---

### üß∞ Optional Enhancements

You can make it even smarter:

* Add a `relationshipMapping` section in YAML to map `"Child" ‚Üí dependents` or `"Partner" ‚Üí spouse`.
* Allow transforms per relationship type.
* Handle missing or unknown relationships gracefully.

---

Would you like me to show you the **complete updated `AcroFormProcessor.java`** including this applicantList logic merged with the previous version (so it‚Äôs a full drop-in replacement)?
