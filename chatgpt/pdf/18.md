Perfect üëè ‚Äî this is where your YAML-driven PDF generator really starts feeling like a **mini ETL framework** ‚Äî mapping + transformation + templating, all config-driven.

Let‚Äôs evolve it in **two steps**:

---

## üß© 1Ô∏è‚É£ YAML ‚Äî Supporting Chained Transforms

You can now express transformations like this:

```yaml
mappings:
  - source: fname
    target: user.displayName
    transforms:
      - name: "trim"
      - name: "capitalize"
      - name: "substring"
        params:
          start: 0
          end: 5

  - source: dob
    target: user.dob
    transforms:
      - name: "dateFormat"
        params:
          from: "yyyy-MM-dd"
          to: "dd MMM yyyy"

  - source: phone
    target: user.phone
    transforms:
      - name: "maskLast4"
```

---

## üß© 2Ô∏è‚É£ Update `FieldMapping.java`

```java
package com.example.pdfgen.config;

import java.util.List;
import java.util.Map;

public class FieldMapping {
    private String source;
    private String target;
    private String script;
    private List<TransformSpec> transforms; // multiple transforms
    private String groupBy;
    private String groupTransform;
    private List<FieldMapping> fields;

    // Getters/Setters

    public String getSource() { return source; }
    public void setSource(String source) { this.source = source; }

    public String getTarget() { return target; }
    public void setTarget(String target) { this.target = target; }

    public String getScript() { return script; }
    public void setScript(String script) { this.script = script; }

    public List<TransformSpec> getTransforms() { return transforms; }
    public void setTransforms(List<TransformSpec> transforms) { this.transforms = transforms; }

    public String getGroupBy() { return groupBy; }
    public void setGroupBy(String groupBy) { this.groupBy = groupBy; }

    public String getGroupTransform() { return groupTransform; }
    public void setGroupTransform(String groupTransform) { this.groupTransform = groupTransform; }

    public List<FieldMapping> getFields() { return fields; }
    public void setFields(List<FieldMapping> fields) { this.fields = fields; }

    // Inner class
    public static class TransformSpec {
        private String name;
        private Map<String, String> params;

        public String getName() { return name; }
        public void setName(String name) { this.name = name; }

        public Map<String, String> getParams() { return params; }
        public void setParams(Map<String, String> params) { this.params = params; }
    }
}
```

---

## üß© 3Ô∏è‚É£ Create `TransformRegistry.java`

A registry to register and lookup transform functions dynamically.

```java
package com.example.pdfgen.util;

import java.util.*;
import java.util.function.BiFunction;

public class TransformRegistry {

    private static final Map<String, BiFunction<String, Map<String, String>, String>> registry = new HashMap<>();

    static {
        // Register built-in transforms
        register("upper", (val, p) -> val.toUpperCase(Locale.ROOT));
        register("lower", (val, p) -> val.toLowerCase(Locale.ROOT));
        register("trim", (val, p) -> val.trim());
        register("capitalize", (val, p) -> capitalize(val));
        register("title", (val, p) -> toTitleCase(val));
        register("maskLast4", (val, p) -> maskLast4(val));
        register("dateFormat", (val, p) -> TransformEngine.reformatDate(val, p));
        register("substring", TransformRegistry::substringTransform);
    }

    public static void register(String name, BiFunction<String, Map<String, String>, String> transformFn) {
        registry.put(name.toLowerCase(Locale.ROOT), transformFn);
    }

    public static BiFunction<String, Map<String, String>, String> get(String name) {
        return registry.get(name.toLowerCase(Locale.ROOT));
    }

    public static boolean exists(String name) {
        return registry.containsKey(name.toLowerCase(Locale.ROOT));
    }

    private static String capitalize(String str) {
        if (str.isEmpty()) return str;
        return Character.toUpperCase(str.charAt(0)) + str.substring(1).toLowerCase();
    }

    private static String toTitleCase(String input) {
        String[] words = input.split("\\s+");
        StringBuilder sb = new StringBuilder();
        for (String w : words) {
            if (!w.isEmpty())
                sb.append(Character.toUpperCase(w.charAt(0)))
                  .append(w.substring(1).toLowerCase())
                  .append(" ");
        }
        return sb.toString().trim();
    }

    private static String maskLast4(String s) {
        if (s.length() <= 4) return "****";
        return s.substring(0, s.length() - 4).replaceAll(".", "*") + s.substring(s.length() - 4);
    }

    private static String substringTransform(String val, Map<String, String> params) {
        try {
            int start = Integer.parseInt(params.getOrDefault("start", "0"));
            int end = Integer.parseInt(params.getOrDefault("end", String.valueOf(val.length())));
            return val.substring(start, Math.min(end, val.length()));
        } catch (Exception e) {
            return val;
        }
    }
}
```

---

## üß© 4Ô∏è‚É£ Update `TransformEngine.java`

Now `TransformEngine` becomes a simple orchestrator for chaining transforms and running scripts.

```java
package com.example.pdfgen.util;

import org.mvel2.MVEL;
import java.util.*;

public class TransformEngine {

    public static String apply(Object value, List<FieldMapping.TransformSpec> transforms, Map<String, Object> context) {
        if (value == null) return "";

        String result = value.toString();

        if (transforms != null) {
            for (FieldMapping.TransformSpec spec : transforms) {
                String name = spec.getName();
                Map<String, String> params = spec.getParams();

                if (TransformRegistry.exists(name)) {
                    result = TransformRegistry.get(name).apply(result, params);
                } else {
                    System.err.println("‚ö†Ô∏è Unknown transform: " + name);
                }
            }
        }

        return result;
    }

    public static String applyScript(String script, Map<String, Object> context) {
        if (script == null || script.trim().isEmpty()) return "";
        try {
            Object result = MVEL.eval(script, context);
            return result != null ? result.toString() : "";
        } catch (Exception e) {
            System.err.println("‚ö†Ô∏è Error evaluating script: " + script);
            e.printStackTrace();
            return "";
        }
    }

    // Utility method used by dateFormat transform
    public static String reformatDate(String val, Map<String, String> params) {
        if (params == null) return val;
        try {
            String from = params.getOrDefault("from", "yyyy-MM-dd");
            String to = params.getOrDefault("to", "dd/MM/yyyy");
            java.text.SimpleDateFormat srcFmt = new java.text.SimpleDateFormat(from);
            java.text.SimpleDateFormat tgtFmt = new java.text.SimpleDateFormat(to);
            return tgtFmt.format(srcFmt.parse(val));
        } catch (Exception e) {
            return val;
        }
    }
}
```

---

## üß© 5Ô∏è‚É£ Usage in Processor

Inside your AcroForm or Freemarker processor loop:

```java
String finalValue;

if (field.getScript() != null) {
    finalValue = TransformEngine.applyScript(field.getScript(), context);
} else {
    finalValue = TransformEngine.apply(rawValue, field.getTransforms(), context);
}
```

---

## üß© 6Ô∏è‚É£ Register Custom Transforms Dynamically

You (or users) can add new transforms **without touching code**.

Example:

```java
TransformRegistry.register("addPrefix", (val, params) -> {
    String prefix = params.getOrDefault("prefix", "");
    return prefix + val;
});

TransformRegistry.register("replace", (val, params) -> {
    String from = params.getOrDefault("from", "");
    String to = params.getOrDefault("to", "");
    return val.replace(from, to);
});
```

Then in YAML:

```yaml
transforms:
  - name: "replace"
    params: { from: "-", to: "/" }
  - name: "addPrefix"
    params: { prefix: "DOB: " }
```

---

## üß© 7Ô∏è‚É£ Resulting Power

‚úÖ Declarative chaining:

```yaml
transforms:
  - name: trim
  - name: lower
  - name: capitalize
```

‚úÖ Date formatting:

```yaml
transforms:
  - name: dateFormat
    params:
      from: yyyy-MM-dd
      to: dd/MM/yyyy
```

‚úÖ Reusable, extendable registry ‚Äî no core changes required.
‚úÖ Works with both AcroForm PDF and Freemarker HTML templates.

---

Would you like me to show the **full integrated processor example** (showing how the registry and chained transforms work end-to-end with both PDFBox and Freemarker outputs)?
That version would include:

* YAML parsing
* Applying transformations
* Generating a PDF and HTML output side-by-side.
