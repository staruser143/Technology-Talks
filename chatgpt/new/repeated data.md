Perfect üëç ‚Äî let‚Äôs extend our previous **mapping engine design** to show **how repeated data (like multiple child applicants)** is rendered dynamically with indexed field names such as:

```
child.demographic.firstName.1
child.demographic.firstName.2
```

We‚Äôll go step by step üëá

---

## üßæ 1. Input JSON (Multiple Children)

Here‚Äôs an example enrollment input with **two Child applicants**:

```json
{
  "applicants": [
    {
      "type": "PrimaryApplicant",
      "demographic": {
        "firstName": "John",
        "lastName": "Doe",
        "dob": "1985-03-15"
      }
    },
    {
      "type": "Child",
      "demographic": {
        "firstName": "Alice",
        "lastName": "Doe",
        "dob": "2015-09-01"
      }
    },
    {
      "type": "Child",
      "demographic": {
        "firstName": "Bob",
        "lastName": "Doe",
        "dob": "2017-05-22"
      }
    }
  ]
}
```

---

## üß© 2. YAML Mapping Config (With Contexts and Child Looping)

Here‚Äôs how we define the contexts and field mapping in YAML:

```yaml
template: enrollment_form.pdf

contexts:
  primaryApplicant: "$applicants[type='PrimaryApplicant']"
  childApplicants: "$applicants[type='Child']"

mappings:
  primary:
    context: "$primaryApplicant"
    fields:
      firstName: "$demographic.firstName"
      lastName: "$demographic.lastName"
      dob: "$demographic.dob"

  child:
    context: "$childApplicants"
    repeat: true  # indicates this section repeats for each child
    fields:
      firstName: "$demographic.firstName"
      lastName: "$demographic.lastName"
      dob: "$demographic.dob"
```

> üîπ The key part here is `repeat: true`.
> It tells the engine: *‚Äúthis context can return multiple items; create indexed keys for each.‚Äù*

---

## ‚öôÔ∏è 3. Engine Logic for Repeated Contexts (Conceptually)

In pseudocode (Java-style):

```java
if (mappingSection.isRepeat()) {
    List<JsonNode> items = jsonataEval(contextExpr, source);
    int index = 1;
    for (JsonNode item : items) {
        Map<String, String> subResult = processFields(item, mappingSection.getFields());
        subResult.forEach((k, v) ->
            output.put(sectionName + "." + k + "." + index, v)
        );
        index++;
    }
} else {
    JsonNode contextNode = jsonataEval(contextExpr, source);
    Map<String, String> subResult = processFields(contextNode, mappingSection.getFields());
    subResult.forEach((k, v) ->
        output.put(sectionName + "." + k + ".1", v)
    );
}
```

This allows the engine to:

* Iterate over each child node in `$childApplicants`
* Flatten their fields
* Automatically suffix field names with `.1`, `.2`, `.3`, etc.

---

## üßÆ 4. Flattened Output (Result)

The output map generated by the engine:

```
primary.firstName.1 = John
primary.lastName.1 = Doe
primary.dob.1 = 1985-03-15

child.firstName.1 = Alice
child.lastName.1 = Doe
child.dob.1 = 2015-09-01

child.firstName.2 = Bob
child.lastName.2 = Doe
child.dob.2 = 2017-05-22
```

‚úÖ Clean, flattened structure
‚úÖ Works perfectly for PDF field naming conventions like:

```
child.firstName.1 ‚Üí Child1.FirstName
child.firstName.2 ‚Üí Child2.FirstName
```

---

## üß† 5. How It Works

| Step | What Happens                                                                          |
| ---- | ------------------------------------------------------------------------------------- |
| 1Ô∏è‚É£  | `$childApplicants` context evaluates to an array of 2 elements.                       |
| 2Ô∏è‚É£  | Since `repeat: true`, the engine loops through each element.                          |
| 3Ô∏è‚É£  | For each child, it evaluates field JSONata expressions like `$demographic.firstName`. |
| 4Ô∏è‚É£  | Appends the loop index to each flattened key.                                         |
| 5Ô∏è‚É£  | Produces predictable, repeat-safe field keys for PDFs or form binding.                |

---

## ‚ö° 6. Optional Enhancement ‚Äî Dynamic Naming Pattern

You could even make the suffix pattern configurable:

```yaml
repeat: true
indexPattern: ".{index}"  # default
# or use something like "-{index}" or "_{index}"
```

and in engine:

```java
String keyName = fieldBaseName + indexPattern.replace("{index}", String.valueOf(index));
```

This helps match whatever field naming convention your PDF form uses.

---

## üß± 7. Benefits of This Design

| Benefit                      | Explanation                                                                |
| ---------------------------- | -------------------------------------------------------------------------- |
| **Reusable contexts**        | `$childApplicants` and `$primaryApplicant` reused across multiple mappings |
| **Zero duplication**         | No repeated JSONata filters per field                                      |
| **Dynamic array handling**   | Any number of children supported                                           |
| **PDF-ready key flattening** | Matches standard AcroForm naming conventions                               |
| **Configurable structure**   | Suffix format can be easily adjusted                                       |

---

Would you like me to show the **complete Java implementation** of the reusable `MappingEngine` class that supports this `repeat` feature and the flattening logic exactly as described above?
