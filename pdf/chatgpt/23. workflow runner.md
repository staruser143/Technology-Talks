Great üëç Let‚Äôs add **YAML parsing + automatic workflow runner** so your engine can take a **YAML workflow file + data JSON** as inputs and produce the final PDF end-to-end.

---

# ‚úÖ YAML-Driven PDF Workflow Runner

---

## **1Ô∏è‚É£ Example Workflow Config (YAML)**

```yaml
workflow:
  coverPage:
    template: "coverTemplate.pdf"
    fields:
      title: "Invoice Report"
      date: "${currentDate}"
      customerName: "${customerName}"

  formPages:
    - template: "formTemplate.pdf"
      fieldMapping:
        sourceField1: targetField1
        sourceField2: targetField2

  summaryPage:
    template: "summaryTemplate.pdf"
    fields:
      totalAmount: "${invoiceTotal}"
      itemCount: "${itemCount}"

  annexures:
    - template: "annexure1.pdf"
    - template: "annexure2.pdf"

  merge:
    - "terms.pdf"
    - "legal_disclaimer.pdf"
```

---

## **2Ô∏è‚É£ POJOs for YAML Mapping**

```java
import java.util.List;
import java.util.Map;

public class WorkflowConfig {
    public CoverPage coverPage;
    public List<FormPage> formPages;
    public SummaryPage summaryPage;
    public List<Annexure> annexures;
    public List<String> merge;

    public static class CoverPage {
        public String template;
        public Map<String, String> fields;
    }

    public static class FormPage {
        public String template;
        public Map<String, String> fieldMapping;
    }

    public static class SummaryPage {
        public String template;
        public Map<String, String> fields;
    }

    public static class Annexure {
        public String template;
    }
}
```

---

## **3Ô∏è‚É£ YAML Parser Utility (SnakeYAML)**

```java
import org.yaml.snakeyaml.Yaml;
import org.yaml.snakeyaml.constructor.Constructor;

import java.io.FileInputStream;

public class YamlConfigLoader {
    public static WorkflowConfig loadConfig(String yamlPath) throws Exception {
        Yaml yaml = new Yaml(new Constructor(WorkflowConfig.class));
        try (FileInputStream fis = new FileInputStream(yamlPath)) {
            return yaml.load(fis);
        }
    }
}
```

---

## **4Ô∏è‚É£ Workflow Runner**

```java
import org.apache.pdfbox.pdmodel.PDDocument;
import java.io.FileOutputStream;
import java.util.*;

public class PdfWorkflowRunner {

    private final PdfWorkflowEngine engine;

    public PdfWorkflowRunner(PdfWorkflowEngine engine) {
        this.engine = engine;
    }

    /**
     * Executes workflow config with given input data and produces final PDF.
     */
    public void runWorkflow(WorkflowConfig config, Map<String, Object> data, String outputFile) throws Exception {
        List<PDDocument> docs = new ArrayList<>();

        // Cover Page
        if (config.coverPage != null) {
            Map<String, String> fields = resolveFields(config.coverPage.fields, data);
            docs.add(engine.fillForm(config.coverPage.template, fields));
        }

        // Form Pages
        if (config.formPages != null) {
            for (WorkflowConfig.FormPage formPage : config.formPages) {
                Map<String, String> fields = new HashMap<>();
                if (formPage.fieldMapping != null) {
                    for (Map.Entry<String, String> entry : formPage.fieldMapping.entrySet()) {
                        String sourceKey = entry.getKey();
                        String targetField = entry.getValue();
                        Object value = data.get(sourceKey);
                        fields.put(targetField, value != null ? value.toString() : "");
                    }
                }
                docs.add(engine.fillForm(formPage.template, fields));
            }
        }

        // Summary Page
        if (config.summaryPage != null) {
            Map<String, String> fields = resolveFields(config.summaryPage.fields, data);
            docs.add(engine.fillForm(config.summaryPage.template, fields));
        }

        // Annexures
        if (config.annexures != null) {
            for (WorkflowConfig.Annexure annex : config.annexures) {
                docs.add(engine.fillForm(annex.template, null));
            }
        }

        // Additional Merge PDFs
        if (config.merge != null) {
            for (String mergeFile : config.merge) {
                docs.add(engine.fillForm(mergeFile, null));
            }
        }

        // Merge everything into final output
        PDDocument finalDoc = engine.mergeDocuments(docs);
        finalDoc.save(new FileOutputStream(outputFile));
        finalDoc.close();

        // Cleanup
        for (PDDocument d : docs) {
            d.close();
        }
        System.out.println("‚úÖ Final PDF generated: " + outputFile);
    }

    /**
     * Replaces ${placeholders} in field values with data values.
     */
    private Map<String, String> resolveFields(Map<String, String> templateFields, Map<String, Object> data) {
        Map<String, String> resolved = new HashMap<>();
        if (templateFields == null) return resolved;

        for (Map.Entry<String, String> entry : templateFields.entrySet()) {
            String rawValue = entry.getValue();
            String finalValue = rawValue;

            // simple placeholder resolution
            if (rawValue != null && rawValue.startsWith("${") && rawValue.endsWith("}")) {
                String key = rawValue.substring(2, rawValue.length() - 1);
                Object value = data.get(key);
                finalValue = value != null ? value.toString() : "";
            }
            resolved.put(entry.getKey(), finalValue);
        }
        return resolved;
    }
}
```

---

## **5Ô∏è‚É£ Example Runner Main**

```java
import java.io.File;
import java.util.Map;

public class PdfRunnerExample {
    public static void main(String[] args) throws Exception {
        // Load workflow config from YAML
        WorkflowConfig config = YamlConfigLoader.loadConfig("workflow.yaml");

        // Example source data
        Map<String, Object> data = Map.of(
                "customerName", "Acme Corp",
                "currentDate", "2025-10-09",
                "sourceField1", "Foo",
                "sourceField2", "Bar",
                "invoiceTotal", 1234.56,
                "itemCount", 5
        );

        // Template provider: Local FS (could be S3 as well)
        TemplateProvider provider = new LocalTemplateProvider("/opt/app/pdf-templates");

        PdfWorkflowEngine engine = new PdfWorkflowEngine(provider);
        PdfWorkflowRunner runner = new PdfWorkflowRunner(engine);

        // Run workflow and generate final PDF
        runner.runWorkflow(config, data, "final-output.pdf");
    }
}
```

---

## **6Ô∏è‚É£ What We Achieved**

* **YAML config ‚Üí POJOs (SnakeYAML)**
* **Data map ‚Üí field resolution + placeholder substitution**
* **Engine automatically fills cover, form, summary, annexures, and merges**
* **Output is a single final PDF**

---

üëâ Next step could be:

* Add **support for looping sections** (e.g., multiple line items rendered as tables).
* Add **dynamic page creation (e.g., invoices with variable number of items)**.

Do you want me to extend this engine so it can **generate tables and repeating sections (line items)** directly from YAML + data?
