Perfect! Let's create a **flexible TemplateProvider abstraction** for your PDF generation engine. This will allow your YAML workflow to just specify template names, and the engine will fetch them **from local filesystem or S3**, with optional caching.

---

## **1️⃣ TemplateProvider Interface**

```java
import java.io.IOException;
import java.io.InputStream;

public interface TemplateProvider {
    /**
     * Fetches a template as an InputStream by name.
     * @param templateName The template file name (e.g., "formTemplate.pdf")
     * @return InputStream of the template
     */
    InputStream getTemplate(String templateName) throws IOException;
}
```

---

## **2️⃣ Local Filesystem Implementation**

```java
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;

public class LocalTemplateProvider implements TemplateProvider {

    private final String basePath;

    /**
     * @param basePath Root folder where templates are stored
     */
    public LocalTemplateProvider(String basePath) {
        this.basePath = basePath;
    }

    @Override
    public InputStream getTemplate(String templateName) throws IOException {
        File file = new File(basePath, templateName);
        if (!file.exists() || !file.isFile()) {
            throw new IOException("Template not found: " + file.getAbsolutePath());
        }
        return new FileInputStream(file);
    }
}
```

---

## **3️⃣ AWS S3 Implementation with Local Cache**

```java
import com.amazonaws.services.s3.AmazonS3;
import com.amazonaws.services.s3.model.S3Object;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.InputStream;
import java.io.IOException;

public class S3TemplateProvider implements TemplateProvider {

    private final AmazonS3 s3Client;
    private final String bucketName;
    private final File cacheDir;

    /**
     * @param s3Client   AWS S3 client
     * @param bucketName Bucket where templates are stored
     * @param cacheDir   Local folder to cache templates
     */
    public S3TemplateProvider(AmazonS3 s3Client, String bucketName, File cacheDir) {
        this.s3Client = s3Client;
        this.bucketName = bucketName;
        this.cacheDir = cacheDir;
        if (!cacheDir.exists()) {
            cacheDir.mkdirs();
        }
    }

    @Override
    public InputStream getTemplate(String templateName) throws IOException {
        File cachedFile = new File(cacheDir, templateName);

        // If cached, return it
        if (cachedFile.exists()) {
            return new FileInputStream(cachedFile);
        }

        // Otherwise fetch from S3 and cache
        try (S3Object s3Object = s3Client.getObject(bucketName, templateName);
             InputStream s3Stream = s3Object.getObjectContent();
             FileOutputStream fos = new FileOutputStream(cachedFile)) {

            byte[] buffer = new byte[8192];
            int bytesRead;
            while ((bytesRead = s3Stream.read(buffer)) != -1) {
                fos.write(buffer, 0, bytesRead);
            }
        } catch (Exception e) {
            throw new IOException("Failed to fetch template from S3: " + templateName, e);
        }

        return new FileInputStream(cachedFile);
    }
}
```

---

## **4️⃣ Using TemplateProvider in PDF Engine**

```java
TemplateProvider templateProvider;

// Example 1: Local filesystem
templateProvider = new LocalTemplateProvider("/opt/app/pdf-templates");

// Example 2: AWS S3 with cache
// AmazonS3 s3Client = ... initialize AWS S3 client ...
// templateProvider = new S3TemplateProvider(s3Client, "my-bucket", new File("/tmp/pdf-cache"));

// Fetch template dynamically in PDF workflow
try (InputStream templateStream = templateProvider.getTemplate("formTemplate.pdf")) {
    PDDocument templateDoc = PDDocument.load(templateStream);
    // Use templateDoc for form page generation
}
```

---

## **5️⃣ Benefits**

1. **Flexible** – switch between local or cloud storage without changing PDF generation logic.
2. **Cache-friendly** – avoids repeated downloads from S3.
3. **YAML-driven** – workflow only needs the `templateName`; fetching is handled automatically.
4. **Extensible** – can add `CmsTemplateProvider` or `DatabaseTemplateProvider` later.

---

This abstraction can now integrate into your **YAML-driven PDF engine**. For example, in YAML you only specify:

```yaml
formPages:
  - template: "formTemplate.pdf"
```

The engine calls `templateProvider.getTemplate("formTemplate.pdf")` to fetch it **from the configured source**.

---

If you want, I can also **update the full PDF engine implementation** to **use this TemplateProvider abstraction** so all templates (cover, forms, annexures) are fetched dynamically instead of hardcoded paths.

Do you want me to do that next?
