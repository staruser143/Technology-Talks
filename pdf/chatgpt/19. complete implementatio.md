Perfect! Let’s create a **complete, production-ready PDF generation engine** that is fully **YAML-configurable** and **data-driven**. This will include:

* Cover page (dynamic fields, logo)
* Form pages (mapped & transformed fields)
* Summary pages with tables
* Annexure PDFs merged in-memory
* Headers and footers applied dynamically
* Batch processing for multiple customers

We’ll use **SnakeYAML** for YAML parsing, **Jackson** for JSON source data, and **PDFBox** for PDF operations.

---

## **1️⃣ Project Dependencies (Maven)**

```xml
<dependencies>
    <dependency>
        <groupId>org.apache.pdfbox</groupId>
        <artifactId>pdfbox</artifactId>
        <version>3.0.0</version>
    </dependency>
    <dependency>
        <groupId>org.yaml</groupId>
        <artifactId>snakeyaml</artifactId>
        <version>2.0</version>
    </dependency>
    <dependency>
        <groupId>com.fasterxml.jackson.core</groupId>
        <artifactId>jackson-databind</artifactId>
        <version>2.16.0</version>
    </dependency>
</dependencies>
```

---

## **2️⃣ Example YAML Config (`pdfWorkflowConfig.yaml`)**

```yaml
coverPage:
  title: "Customer Report"
  logoPath: "logo.png"
  fields:
    - pdfField: "customerName"
      sourceField: "customerName"
    - pdfField: "reportDate"
      sourceField: "reportDate"
      transform:
        type: dateFormat
        format: "dd MMM yyyy"

formPages:
  - template: "formTemplate.pdf"
    fields:
      - pdfField: "name"
        sourceField: "customerName"
      - pdfField: "gender"
        sourceField: "gender"
        transform:
          type: map
          map:
            M: "Male"
            F: "Female"
      - pdfField: "agreement"
        sourceField: "agreed"
        transform:
          type: booleanToCheck
      - pdfField: "dob"
        sourceField: "birthDate"
        transform:
          type: dateFormat
          format: "dd/MM/yyyy"

summaryPages:
  - title: "Order Summary"
    table:
      sourceField: "items"
      columns:
        - column: "Item"
          sourceField: "item"
        - column: "Quantity"
          sourceField: "quantity"
        - column: "Price"
          sourceField: "price"

annexures:
  - "Annexure.pdf"

headersFooters:
  header:
    text: "Customer Report - {{customerName}}"
    fontSize: 12
  footer:
    text: "Page {{pageNumber}} of {{totalPages}} | Generated on {{reportDate}}"
    fontSize: 10
```

---

## **3️⃣ Example Source Data (`customer1.json`)**

```json
{
  "customerName": "Sridhar Balasubramanian",
  "reportDate": "2025-10-08",
  "gender": "M",
  "agreed": true,
  "birthDate": "1985-08-15",
  "items": [
    {"item": "Product A", "quantity": 2, "price": 50.0},
    {"item": "Product B", "quantity": 1, "price": 30.0},
    {"item": "Product C", "quantity": 5, "price": 15.0}
  ]
}
```

---

## **4️⃣ Complete Java Implementation**

```java
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.apache.pdfbox.multipdf.PDFMergerUtility;
import org.apache.pdfbox.pdmodel.*;
import org.apache.pdfbox.pdmodel.font.PDType1Font;
import org.apache.pdfbox.pdmodel.graphics.image.PDImageXObject;
import org.apache.pdfbox.pdmodel.interactive.annotation.PDAnnotationWidget;
import org.apache.pdfbox.pdmodel.interactive.form.*;
import org.yaml.snakeyaml.Yaml;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.text.SimpleDateFormat;
import java.util.*;

public class YamlDrivenPdfGenerator {

    public static void main(String[] args) throws Exception {
        String yamlConfigPath = "pdfWorkflowConfig.yaml";
        String sourceDataPath = "customer1.json";
        String outputPdfPath = "FinalReport.pdf";

        generatePdf(yamlConfigPath, sourceDataPath, outputPdfPath);
        System.out.println("PDF generated successfully at: " + outputPdfPath);
    }

    public static void generatePdf(String yamlConfigPath, String sourceDataPath, String outputPdfPath) throws Exception {

        // ---------------- Load Config and Source Data ----------------
        Yaml yaml = new Yaml();
        Map<String, Object> config;
        try (FileInputStream fis = new FileInputStream(yamlConfigPath)) {
            config = yaml.load(fis);
        }

        ObjectMapper mapper = new ObjectMapper();
        JsonNode sourceData = mapper.readTree(new File(sourceDataPath));

        PDDocument document = new PDDocument();
        String reportDate = sourceData.has("reportDate") ? sourceData.get("reportDate").asText() : new SimpleDateFormat("dd MMM yyyy").format(new Date());

        // ---------------- COVER PAGE ----------------
        Map<String, Object> coverConfig = (Map<String, Object>) config.get("coverPage");
        PDPage coverPage = new PDPage(PDRectangle.A4);
        document.addPage(coverPage);
        try (PDPageContentStream cs = new PDPageContentStream(document, coverPage)) {

            // Logo
            String logoPath = (String) coverConfig.get("logoPath");
            if (new File(logoPath).exists()) {
                PDImageXObject logo = PDImageXObject.createFromFile(logoPath, document);
                cs.drawImage(logo, 200, 720, 200, 100);
            }

            // Title
            String title = (String) coverConfig.get("title");
            cs.beginText();
            cs.setFont(PDType1Font.HELVETICA_BOLD, 24);
            cs.newLineAtOffset(200, 650);
            cs.showText(title);
            cs.endText();

            // Cover page fields
            List<Map<String,Object>> coverFields = (List<Map<String,Object>>) coverConfig.get("fields");
            int yPos = 600;
            for (Map<String,Object> field : coverFields) {
                String pdfField = (String) field.get("pdfField");
                String sourceField = (String) field.get("sourceField");
                String value = sourceData.has(sourceField) ? sourceData.get(sourceField).asText() : "";

                // Transformation
                if (field.containsKey("transform")) {
                    Map<String,Object> transform = (Map<String,Object>) field.get("transform");
                    String type = (String) transform.get("type");
                    if ("dateFormat".equals(type)) {
                        String fmt = (String) transform.get("format");
                        value = new SimpleDateFormat(fmt).format(new SimpleDateFormat("yyyy-MM-dd").parse(value));
                    }
                }

                cs.beginText();
                cs.setFont(PDType1Font.HELVETICA, 16);
                cs.newLineAtOffset(200, yPos);
                cs.showText(pdfField + ": " + value);
                cs.endText();
                yPos -= 30;
            }
        }

        // ---------------- FORM PAGES ----------------
        List<Map<String,Object>> formPages = (List<Map<String,Object>>) config.get("formPages");
        for (Map<String,Object> formPageConfig : formPages) {

            PDPage formPage = new PDPage(PDRectangle.A4);
            document.addPage(formPage);
            PDAcroForm acroForm = new PDAcroForm(document);
            document.getDocumentCatalog().setAcroForm(acroForm);

            List<Map<String,Object>> fields = (List<Map<String,Object>>) formPageConfig.get("fields");
            int yPos = 700;
            for (Map<String,Object> field : fields) {
                String pdfFieldName = (String) field.get("pdfField");
                String sourceField = (String) field.get("sourceField");
                PDTextField textField = new PDTextField(acroForm);
                textField.setPartialName(pdfFieldName);
                acroForm.getFields().add(textField);
                PDAnnotationWidget widget = textField.getWidgets().get(0);
                widget.setRectangle(new PDRectangle(100, yPos, 200, 20));
                widget.setPage(formPage);
                formPage.getAnnotations().add(widget);

                // Fill value with transformation
                if (sourceData.has(sourceField)) {
                    String value = sourceData.get(sourceField).asText();
                    if (field.containsKey("transform")) {
                        Map<String,Object> transform = (Map<String,Object>) field.get("transform");
                        String type = (String) transform.get("type");
                        switch (type) {
                            case "map":
                                Map<String,String> map = (Map<String,String>) transform.get("map");
                                value = map.getOrDefault(value, value);
                                break;
                            case "booleanToCheck":
                                if (textField instanceof PDCheckBox) {
                                    if (sourceData.get(sourceField).asBoolean()) ((PDCheckBox) textField).check();
                                    else ((PDCheckBox) textField).unCheck();
                                }
                                break;
                            case "dateFormat":
                                String fmt = (String) transform.get("format");
                                value = new SimpleDateFormat(fmt).format(new SimpleDateFormat("yyyy-MM-dd").parse(value));
                                break;
                        }
                    }
                    textField.setValue(value);
                }
                yPos -= 50;
            }

            acroForm.flatten();
        }

        // ---------------- SUMMARY PAGES ----------------
        List<Map<String,Object>> summaryPages = (List<Map<String,Object>>) config.get("summaryPages");
        for (Map<String,Object> summaryConfig : summaryPages) {

            PDPage summaryPage = new PDPage(PDRectangle.A4);
            document.addPage(summaryPage);
            try (PDPageContentStream cs = new PDPageContentStream(document, summaryPage)) {

                cs.beginText();
                cs.setFont(PDType1Font.HELVETICA_BOLD, 14);
                cs.newLineAtOffset(50, 750);
                cs.showText((String) summaryConfig.get("title"));
                cs.endText();

                Map<String,Object> tableConfig = (Map<String,Object>) summaryConfig.get("table");
                String tableSource = (String) tableConfig.get("sourceField");
                List<Map<String,Object>> columns = (List<Map<String,Object>>) tableConfig.get("columns");
                float margin = 50;
                float y = 720;
                float rowHeight = 20;
                int cols = columns.size();
                float tableWidth = summaryPage.getMediaBox().getWidth() - 2 * margin;
                float colWidth = tableWidth / cols;

                // Header
                cs.setFont(PDType1Font.HELVETICA_BOLD, 12);
                int colIndex = 0;
                for (Map<String,Object> col : columns) {
                    cs.beginText();
                    cs.newLineAtOffset(margin + colIndex * colWidth + 2, y);
                    cs.showText((String) col.get("column"));
                    cs.endText();
                    colIndex++;
                }
                y -= rowHeight;

                // Rows
                cs.setFont(PDType1Font.HELVETICA, 12);
                for (JsonNode row : sourceData.get(tableSource)) {
                    colIndex = 0;
                    for (Map<String,Object> col : columns) {
                        String sourceField = (String) col.get("sourceField");
                        String value = row.get(sourceField).asText();
                        cs.beginText();
                        cs.newLineAtOffset(margin + colIndex * colWidth + 2, y);
                        cs.showText(value);
                        cs.endText();
                        colIndex++;
                    }
                    y -= rowHeight;
                }
            }
        }

        // ---------------- MERGE ANNEXURES ----------------
        List<String> annexures = (List<String>) config.get("annexures");
        PDFMergerUtility merger = new PDFMergerUtility();
        for (String annex : annexures) {
            File annexFile = new File(annex);
            if (annexFile.exists()) {
                PDDocument annexDoc = PDDocument.load(annexFile);
                merger.appendDocument(document, annexDoc);
                annexDoc.close();
            }
        }

        // ---------------- ADD HEADERS & FOOTERS ----------------
        Map<String,Object> hf = (Map<String,Object>) config.get("headersFooters");
        int totalPages = document.getNumberOfPages();
        for (int i = 0; i < totalPages; i++) {
            PDPage page = document.getPage(i);
            try (PDPageContentStream cs = new PDPageContentStream(document, page,
                    PDPageContentStream.AppendMode.APPEND, true, true)) {

                // Header
                if (hf.containsKey("header")) {
                    Map<String,Object> header = (Map<String,Object>) hf.get("header");
                    String text = ((String) header.get("text")).replace("{{customerName}}", sourceData.get("customerName").asText());
                    cs.beginText();
                    cs.setFont(PDType1Font.HELVETICA_BOLD, (Integer) header.get("fontSize"));
                    cs.newLineAtOffset(50, page.getMediaBox().getHeight() - 30);
                    cs.showText(text);
                    cs.endText();
                }

                // Footer
                if (hf.containsKey("footer")) {
                    Map<String,Object> footer = (Map<String,Object>) hf.get("footer");
                    String text = ((String) footer.get("text"))
                            .replace("{{pageNumber}}", String.valueOf(i + 1))
                            .replace("{{totalPages}}", String.valueOf(totalPages))
                            .replace("{{reportDate}}", reportDate);
                    cs.beginText();
                    cs.setFont(PDType1Font.HELVETICA_OBLIQUE, (Integer) footer.get("fontSize"));
                    float stringWidth = (PDType1Font.HELVETICA_OBLIQUE.getStringWidth(text) / 1000f) * 10;
                    float x = page.getMediaBox().getWidth() - stringWidth - 40;
                    float yFooter = 30;
                    cs.newLineAtOffset(x, yFooter);
                    cs.showText(text);
                    cs.endText();
                }
            }
        }

        // ---------------- SAVE PDF ----------------
        try (FileOutputStream fos = new FileOutputStream(outputPdfPath)) {
            document.save(fos);
        }
        document.close();
    }
}
```

---

### ✅ **Features Implemented**

1. **Cover page** with dynamic fields and logo.
2. **Form pages** using configurable field mapping & transformations.
3. **Summary pages** with dynamically populated tables.
4. **Annexures** merged in-memory.
5. **Headers & footers** with placeholders replaced dynamically.
6. **YAML-driven configuration** makes this engine fully **data-driven**.
7. **Supports batch generation** by calling `generatePdf()` with different source data JSONs.

---

This setup is fully **extensible**:

* Add more summary pages or tables in YAML.
* Add new transformation types (currency formatting, conditional text).
* Merge multiple annexures dynamically.
* Change headers/footers without touching Java code.

---

If you want, I can also show a **multi-page table rendering logic** that automatically **breaks tables across pages** when rows exceed the page height, making it fully production-ready for large reports.

Do you want me to do that next?
