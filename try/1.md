Great â€” since you're using **Java with Apache PDFBox**, here's how you can implement a **dynamic field mapping strategy** based on your naming convention.

---

### ðŸ§¾ Assumed JSON Structure
```json
{
  "PrimaryApplicant": {
    "FName": "Sridhar",
    "LName": "Balasubramanian"
  },
  "Dependent": [
    {"FName": "Ravi", "LName": "Kumar"},
    {"FName": "Meena", "LName": "Kumari"}
  ]
}
```

---

### ðŸ§  Field Naming Convention Recap
- **Single object**: `PrimaryApplicant.FName.1`
- **Array object**: `Dependent.FName.1`, `Dependent.FName.2`, etc.

---

### ðŸ§° Java Code Snippet Using PDFBox

```java
import org.apache.pdfbox.pdmodel.PDDocument;
import org.apache.pdfbox.pdmodel.interactive.form.PDAcroForm;
import org.apache.pdfbox.pdmodel.interactive.form.PDField;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;

import java.io.File;
import java.util.Iterator;

public class PdfFormFiller {

    public static void main(String[] args) throws Exception {
        File pdfFile = new File("template.pdf");
        File jsonFile = new File("data.json");

        PDDocument document = PDDocument.load(pdfFile);
        PDAcroForm acroForm = document.getDocumentCatalog().getAcroForm();

        ObjectMapper mapper = new ObjectMapper();
        JsonNode root = mapper.readTree(jsonFile);

        for (PDField field : acroForm.getFields()) {
            String fieldName = field.getFullyQualifiedName(); // e.g., Dependent.FName.1
            String[] parts = fieldName.split("\\.");

            if (parts.length == 3) {
                String objectName = parts[0];     // e.g., Dependent
                String propertyName = parts[1];   // e.g., FName
                int index = Integer.parseInt(parts[2]) - 1;

                JsonNode objectNode = root.get(objectName);

                if (objectNode != null) {
                    if (objectNode.isArray()) {
                        if (index < objectNode.size()) {
                            JsonNode valueNode = objectNode.get(index).get(propertyName);
                            if (valueNode != null) {
                                field.setValue(valueNode.asText());
                            }
                        }
                    } else {
                        if (index == 0) { // Only fill .1 for single objects
                            JsonNode valueNode = objectNode.get(propertyName);
                            if (valueNode != null) {
                                field.setValue(valueNode.asText());
                            }
                        }
                    }
                }
            }
        }

        acroForm.flatten(); // Optional: make fields non-editable
        document.save("filled_form.pdf");
        document.close();
    }
}
```

---

### âœ… Highlights
- **No config file needed** â€” relies on naming convention.
- **Supports arrays and single objects**.
- **Scalable** â€” works for any number of dependents.

---

Would you like this packaged as a Maven project with sample JSON and PDF placeholders? Or do you want to extend this to support nested objects like `PrimaryApplicant.Address.City.1`?
