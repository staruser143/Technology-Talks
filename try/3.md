Here‚Äôs a complete **Java class** that uses **Apache PDFBox** and **Jackson** to fill a PDF form using a **recursive JSON path resolution** strategy. This approach supports deeply nested JSON structures and array indexing based on your field naming convention.

---

### üì¶ Dependencies (Maven)
Add these to your `pom.xml`:
```xml
<dependencies>
    <dependency>
        <groupId>org.apache.pdfbox</groupId>
        <artifactId>pdfbox</artifactId>
        <version>2.0.29</version>
    </dependency>
    <dependency>
        <groupId>com.fasterxml.jackson.core</groupId>
        <artifactId>jackson-databind</artifactId>
        <version>2.15.2</version>
    </dependency>
</dependencies>
```

---

### üßë‚Äçüíª Java Class: `PdfFormFiller.java`

```java
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.apache.pdfbox.pdmodel.PDDocument;
import org.apache.pdfbox.pdmodel.interactive.form.PDAcroForm;
import org.apache.pdfbox.pdmodel.interactive.form.PDField;

import java.io.File;
import java.util.List;

public class PdfFormFiller {

    public static void main(String[] args) throws Exception {
        File pdfFile = new File("template.pdf");
        File jsonFile = new File("data.json");

        PDDocument document = PDDocument.load(pdfFile);
        PDAcroForm acroForm = document.getDocumentCatalog().getAcroForm();

        ObjectMapper mapper = new ObjectMapper();
        JsonNode rootNode = mapper.readTree(jsonFile);

        List<PDField> fields = acroForm.getFields();

        for (PDField field : fields) {
            String fieldName = field.getFullyQualifiedName(); // e.g., PrimaryApplicant.FName.1 or Dependent.Education.Grades.Score.2.1
            String[] pathParts = fieldName.split("\\.");

            JsonNode valueNode = resolveJsonPath(rootNode, pathParts);
            if (valueNode != null && valueNode.isValueNode()) {
                field.setValue(valueNode.asText());
            }
        }

        acroForm.flatten(); // Optional: make fields non-editable
        document.save("filled_form.pdf");
        document.close();
    }

    /**
     * Recursively resolves a JSON path from a field name like A.B.C.2.1
     * Treats numeric segments as array indices (1-based).
     */
    public static JsonNode resolveJsonPath(JsonNode root, String[] pathParts) {
        JsonNode current = root;
        for (String part : pathParts) {
            if (current == null) return null;

            if (part.matches("\\d+")) {
                int index = Integer.parseInt(part) - 1;
                if (current.isArray() && index < current.size()) {
                    current = current.get(index);
                } else {
                    return null;
                }
            } else {
                current = current.get(part);
            }
        }
        return current;
    }
}
```

---

### ‚úÖ Features
- Supports **deeply nested JSON**.
- Handles **arrays at any level** using `1-based indexing`.
- No need for a separate mapping config ‚Äî relies on **field name convention**.

---

Would you like me to generate a sample `data.json` and `template.pdf` field list to test this class? Or help you extend this to support default values or logging for missing fields?
