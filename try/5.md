Here‚Äôs a **Java class** that implements a **hybrid mapping strategy** using Apache PDFBox and Jackson. It supports:

- **Dynamic mapping** based on field name conventions (`Object.Property.Index`)
- **Custom mapping** via a configuration file (`mapping.json`) for fields that don‚Äôt follow the convention

---

### üì¶ Required Files

#### 1. `data.json` ‚Äî your actual data  
#### 2. `mapping.json` ‚Äî optional custom mappings
```json
{
  "PrimaryApplicant.FName": "First_Name_Field",
  "PrimaryApplicant.LName": "Last_Name_Field"
}
```

---

### üßë‚Äçüíª Java Class: `HybridPdfFormFiller.java`

```java
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.apache.pdfbox.pdmodel.PDDocument;
import org.apache.pdfbox.pdmodel.interactive.form.PDAcroForm;
import org.apache.pdfbox.pdmodel.interactive.form.PDField;

import java.io.File;
import java.util.*;

public class HybridPdfFormFiller {

    public static void main(String[] args) throws Exception {
        File pdfFile = new File("template.pdf");
        File jsonFile = new File("data.json");
        File mappingFile = new File("mapping.json");

        PDDocument document = PDDocument.load(pdfFile);
        PDAcroForm acroForm = document.getDocumentCatalog().getAcroForm();

        ObjectMapper mapper = new ObjectMapper();
        JsonNode rootNode = mapper.readTree(jsonFile);

        Map<String, String> customMapping = new HashMap<>();
        if (mappingFile.exists()) {
            JsonNode mappingNode = mapper.readTree(mappingFile);
            Iterator<String> keys = mappingNode.fieldNames();
            while (keys.hasNext()) {
                String jsonPath = keys.next();
                customMapping.put(jsonPath, mappingNode.get(jsonPath).asText());
            }
        }

        for (PDField field : acroForm.getFields()) {
            String fieldName = field.getFullyQualifiedName();

            // Check custom mapping first
            String jsonPath = customMapping.entrySet().stream()
                .filter(entry -> entry.getValue().equals(fieldName))
                .map(Map.Entry::getKey)
                .findFirst()
                .orElse(null);

            JsonNode valueNode = null;

            if (jsonPath != null) {
                String[] pathParts = jsonPath.split("\\.");
                valueNode = resolveJsonPath(rootNode, pathParts);
            } else {
                String[] pathParts = fieldName.split("\\.");
                valueNode = resolveJsonPath(rootNode, pathParts);
            }

            if (valueNode != null && valueNode.isValueNode()) {
                field.setValue(valueNode.asText());
            }
        }

        acroForm.flatten(); // Optional
        document.save("filled_form.pdf");
        document.close();
    }

    public static JsonNode resolveJsonPath(JsonNode root, String[] pathParts) {
        JsonNode current = root;
        for (String part : pathParts) {
            if (current == null) return null;

            if (part.matches("\\d+")) {
                int index = Integer.parseInt(part) - 1;
                if (current.isArray() && index < current.size()) {
                    current = current.get(index);
                } else {
                    return null;
                }
            } else {
                current = current.get(part);
            }
        }
        return current;
    }
}
```

---

### ‚úÖ Features
- **Custom mapping** for non-standard field names.
- **Dynamic mapping** for convention-based field names.
- **Recursive JSON path resolution** for deep nesting.

---

Would you like me to generate a sample `mapping.json` file based on the earlier `data.json` and `pdf_fields.txt`?
